<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>细雨流年</title>
  <subtitle>夢裡不覺秋已深，余情豈是為他人</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.ajavac.com/"/>
  <updated>2017-08-24T06:21:09.000Z</updated>
  <id>https://blog.ajavac.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MacOS系统自带简体拼音输入法Tips</title>
    <link href="https://blog.ajavac.com/2017/08/24/Common/mac_pinyin_input_method/"/>
    <id>https://blog.ajavac.com/2017/08/24/Common/mac_pinyin_input_method/</id>
    <published>2017-08-24T06:20:31.000Z</published>
    <updated>2017-08-24T06:21:09.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Mac上的简体中文拼音输入法主要有<a href="https://pinyin.sogou.com/mac/" target="_blank" rel="external">搜狗</a>、<a href="http://rime.im/" target="_blank" rel="external">鼠须管</a>、系统自带输入法这几种。本文将介绍MacOS系统自带的简体拼音输入法的一些使用技巧。</p>
</blockquote>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="http://www.pc6.com/edu/81700.html" target="_blank" rel="external">Mac OS X 自带拼音输入法小技巧</a></li>
<li><a href="http://www.ifanr.com/app/800591" target="_blank" rel="external">Mac 自带输入法这么好用，不看不知道 | 有用功</a></li>
<li><a href="http://www.jianshu.com/p/c258940a62cb" target="_blank" rel="external">Mac 里的文字输入效率</a></li>
</ul>
<h2 id="候选词切换"><a href="#候选词切换" class="headerlink" title="候选词切换"></a>候选词切换</h2><ol>
<li><code>－+</code>或者<code>←→</code>，在单页候选词中切换，一个个切换</li>
<li><code>［ ］</code>或者<code>↑↓</code>，在多页候选词中切换，一页页切换</li>
</ol>
<h2 id="中英文数字混合输入"><a href="#中英文数字混合输入" class="headerlink" title="中英文数字混合输入"></a>中英文数字混合输入</h2><ol>
<li>短按<code>Caps lock</code>切换中／英文输入法</li>
<li>长按<code>Caps lock</code>锁定／解锁大小写输入状态</li>
<li><code>Shift</code>键用来输入大写</li>
<li>拼音输入法状态下，<code>Return</code>直接输入字母，空格则输入当前高亮的候选词</li>
<li>输入文字时，按住<code>Shift</code>就能输入大写字母，按住<code>Option</code>能输入数字</li>
</ol>
<h2 id="简体中文输入"><a href="#简体中文输入" class="headerlink" title="简体中文输入"></a>简体中文输入</h2><ol>
<li><code>&#39;</code> 符号作为拼音之间的分隔符，例如：<code>bei&#39;jing</code> 北京</li>
<li><code>u</code> 可以打开笔画输入框</li>
<li><code>Tab</code> 可以在 1234 声调中切换选择</li>
<li><code>Shift+空格键</code>就能输入可组合的汉字，如 jiji后按组合键即可输入喆</li>
<li><code>Option+Shift+L</code>即可打开输入码搜索框</li>
<li><code>Control+Shift+空格键</code>即可打开手写输入窗口（前提是有选择手写输入法） </li>
<li><code>Command+Control+空格键</code>，即可看到表情符号窗口</li>
<li><code>Option+Shift+B」或者「Shift+6</code>，即可看到颜文字窗口</li>
<li><code>Control+Command+Shift+C</code>转为繁体</li>
<li><code>Control+Option+Command+Shift+C</code>转为简体</li>
<li><code>Delete</code> 删除光标前内容</li>
<li><code>Fn+Delete</code> 删除光标后内容</li>
<li><code>Shift+Delete</code> 删除错误的个人候选词</li>
</ol>
<h2 id="输入特殊字符"><a href="#输入特殊字符" class="headerlink" title="输入特殊字符"></a>输入特殊字符</h2><p>按住「Option」 +其他按键输入特殊字符</p>
<p><img src="/img/mac/input_method_option.png" alt="input_method_option"></p>
<p>按住「Option」+ 「Shift」+ 其他按键输入特殊字符</p>
<p><img src="/img/mac/input_method_option_shift.png" alt="input_method_option_shift"></p>
<h2 id="快捷键总结"><a href="#快捷键总结" class="headerlink" title="快捷键总结"></a>快捷键总结</h2><h3 id="按键标志符"><a href="#按键标志符" class="headerlink" title="按键标志符"></a>按键标志符</h3><table>
<thead>
<tr>
<th>标志符</th>
<th>对应按键</th>
</tr>
</thead>
<tbody>
<tr>
<td>⌃</td>
<td>Control</td>
</tr>
<tr>
<td>⌥</td>
<td>Option</td>
</tr>
<tr>
<td>⌘</td>
<td>Command</td>
</tr>
<tr>
<td>⇧</td>
<td>Shift</td>
</tr>
<tr>
<td>␣</td>
<td>空格</td>
</tr>
<tr>
<td>⇪</td>
<td>Caps Lock</td>
</tr>
<tr>
<td>⌫</td>
<td>Delete</td>
</tr>
</tbody>
</table>
<h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><table>
<thead>
<tr>
<th>功能</th>
<th>标志符</th>
<th>快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td>切换输入法</td>
<td>⌃ ␣</td>
<td>Control+空格</td>
</tr>
<tr>
<td>手写输入法</td>
<td>⌃⇧ ␣</td>
<td>Control+⇧+空格</td>
</tr>
<tr>
<td>切换中／英文输入法</td>
<td>⇪</td>
<td>Caps Lock</td>
</tr>
<tr>
<td>候选词切换</td>
<td>+-←→</td>
<td><code>－+</code>或者<code>←→</code></td>
</tr>
<tr>
<td>候选词页切换</td>
<td>[]↑↓</td>
<td><code>［ ］</code>或者<code>↑↓</code></td>
</tr>
<tr>
<td>表情与符号</td>
<td>⌃ ⌘ ␣</td>
<td>Control+Command+空格</td>
</tr>
<tr>
<td>颜文字与符号</td>
<td>⌥ ⇧ B</td>
<td>Option+Shift+B</td>
</tr>
<tr>
<td>颜文字与符号</td>
<td>⇧ 6</td>
<td>Shift+6</td>
</tr>
<tr>
<td>听写</td>
<td>Fn Fn</td>
<td>Fn+Fn</td>
</tr>
<tr>
<td>查找输入码</td>
<td>⌥ ⇧ L</td>
<td>Option+Shift+L</td>
</tr>
<tr>
<td>拆字输入</td>
<td>⇧ ␣</td>
<td>Shift+空格</td>
</tr>
<tr>
<td>中文输入过程中输入大写字母</td>
<td>⇧</td>
<td>Shift</td>
</tr>
<tr>
<td>中文输入过程中输入数字</td>
<td>⌥</td>
<td>Option</td>
</tr>
<tr>
<td>转为繁体</td>
<td>⌃ ⌘⇧ C</td>
<td>Control+Command+Shift+C</td>
</tr>
<tr>
<td>转为简体</td>
<td>⌃ ⌥ ⌘ ⇧ C</td>
<td>Control+Option+Command+Shift+C</td>
</tr>
<tr>
<td>音调切换</td>
<td>Tab</td>
<td>Tab</td>
</tr>
<tr>
<td>笔画输入</td>
<td>u</td>
<td>u</td>
</tr>
<tr>
<td>拼音之间的分隔符</td>
<td>‘</td>
<td>‘</td>
</tr>
<tr>
<td>删除光标前内容</td>
<td>⌫</td>
<td>Delete</td>
</tr>
<tr>
<td>删除光标后内容</td>
<td>Fn ⌫</td>
<td>Fn+Delete</td>
</tr>
<tr>
<td>删除错误的个人候选词</td>
<td>⇧ ⌫</td>
<td>Shift+Delete</td>
</tr>
</tbody>
</table>
<h2 id="Alfred中设置输入法"><a href="#Alfred中设置输入法" class="headerlink" title="Alfred中设置输入法"></a>Alfred中设置输入法</h2><p>在<code>Alfred</code>的<code>Preferences</code>中的<code>Advanced</code>页中设置<code>Force Keyboard</code>为英文</p>
<p><img src="/img/mac/alfred_preferences_advanced.png" alt="alfred_preferences_advanced"></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Mac上的简体中文拼音输入法主要有&lt;a href=&quot;https://pinyin.sogou.com/mac/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;搜狗&lt;/a&gt;、&lt;a href=&quot;http://rime.im/&quot; tar
    
    </summary>
    
      <category term="Mac" scheme="https://blog.ajavac.com/categories/Mac/"/>
    
    
      <category term="Mac" scheme="https://blog.ajavac.com/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Java 7 新特性</title>
    <link href="https://blog.ajavac.com/2017/08/15/Java/java7/"/>
    <id>https://blog.ajavac.com/2017/08/15/Java/java7/</id>
    <published>2017-08-15T07:39:45.000Z</published>
    <updated>2017-08-15T08:09:22.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Oracle 公司于 2011 年 7 月 7 日发布 Java 7，添加了许多新特性</p>
</blockquote>
<table>
<thead>
<tr>
<th>序号</th>
<th>特性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>switch中添加对字符串的支持</td>
<td>开关语句支持字符串</td>
</tr>
<tr>
<td>2</td>
<td>try-with-resource</td>
<td>自动化资源管理</td>
</tr>
<tr>
<td>3</td>
<td>钻石符号<code>&lt;&gt;</code></td>
<td>类型自动推导</td>
</tr>
<tr>
<td>4</td>
<td>多异常捕捉</td>
<td>一次性捕捉多种异常</td>
</tr>
<tr>
<td>5</td>
<td>访问文件系统</td>
<td>新的文件访问方式</td>
</tr>
<tr>
<td>6</td>
<td>异步I/O</td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>二进制常量以及下划线支持</td>
</tr>
</tbody>
</table>
<h2 id="switch中添加对字符串的支持"><a href="#switch中添加对字符串的支持" class="headerlink" title="switch中添加对字符串的支持"></a>switch中添加对字符串的支持</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">	String aStr = <span class="string">"string"</span>;</div><div class="line">  	<span class="keyword">switch</span> (aStr) &#123;</div><div class="line">      <span class="keyword">case</span> <span class="string">"1"</span>:</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      <span class="keyword">case</span> <span class="string">"2"</span>:</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      <span class="keyword">default</span>:</div><div class="line">        System.out.println(aStr);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="try-with-resource"><a href="#try-with-resource" class="headerlink" title="try-with-resource"></a>try-with-resource</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> ( InputStream is  = <span class="keyword">new</span> FileInputStream(<span class="string">"a.txt"</span>);</div><div class="line">      OutputStream os = <span class="keyword">new</span> FileOutputStream(<span class="string">"b.txt"</span>)) &#123;</div><div class="line">    <span class="keyword">char</span> charStr = (<span class="keyword">char</span>) is.read();</div><div class="line">    os.write(charStr);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>只要操作类实现了<code>AutoCloseable</code>接口就可以在try语句块退出时自动调用close方法来关闭资源流</li>
<li>关闭方法的异常也可以直接catch</li>
<li>可以声明多个资源</li>
</ol>
<h3 id="钻石符号"><a href="#钻石符号" class="headerlink" title="钻石符号"></a>钻石符号</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 钻石符号自动判断类型</span></div><div class="line">List&lt;String&gt; strList = <span class="keyword">new</span> ArrayList&lt;&gt;();</div></pre></td></tr></table></figure>
<h3 id="多异常捕捉"><a href="#多异常捕捉" class="headerlink" title="多异常捕捉"></a>多异常捕捉</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    Thread.sleep(<span class="number">20000</span>);</div><div class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"/a/b.txt"</span>);</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException | IOException e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用<code>|</code>可以声明同时对多类异常进行捕捉</p>
<h3 id="访问文件系统"><a href="#访问文件系统" class="headerlink" title="访问文件系统"></a>访问文件系统</h3><h3 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h3><blockquote>
<p>表示文件路径和文件</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Path path   = Paths.get(<span class="string">"/home/"</span>, <span class="string">"a.txt"</span>);</div><div class="line">File file = path.toFile();</div></pre></td></tr></table></figure>
<h3 id="Files"><a href="#Files" class="headerlink" title="Files"></a>Files</h3><blockquote>
<p>快速操作文件</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 读取文件内容</span></div><div class="line"><span class="keyword">byte</span>[] data    = Files.readAllBytes(Paths.get(<span class="string">"a.txt"</span>));</div><div class="line">String content = <span class="keyword">new</span> String(data, StandardCharsets.UTF_8);</div><div class="line"></div><div class="line"><span class="comment">// 按行读取文件</span></div><div class="line">List&lt;String&gt; lines = Files.readAllLines(Paths.get(<span class="string">"a.txt"</span>));</div><div class="line"></div><div class="line"><span class="comment">// 写入文件</span></div><div class="line">Files.write(Paths.get(<span class="string">"b.txt"</span>), <span class="string">"Hello World"</span>.getBytes());</div><div class="line"></div><div class="line"><span class="comment">// 创建文件夹，若父文件夹不存在则自动创建</span></div><div class="line">Files.createDirectories(Paths.get(<span class="string">"abc"</span>,<span class="string">"cda"</span>,<span class="string">"a.txt"</span>));</div><div class="line"></div><div class="line"><span class="comment">// 拷贝文件</span></div><div class="line">Files.copy(Paths.get(<span class="string">"a.txt"</span>),Paths.get(<span class="string">"b.txt"</span>));</div></pre></td></tr></table></figure>
<p>### </p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Oracle 公司于 2011 年 7 月 7 日发布 Java 7，添加了许多新特性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;序号&lt;/th&gt;
&lt;th&gt;特性&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
    
    </summary>
    
      <category term="Java" scheme="https://blog.ajavac.com/categories/Java/"/>
    
    
      <category term="Java" scheme="https://blog.ajavac.com/tags/Java/"/>
    
      <category term="Basic" scheme="https://blog.ajavac.com/tags/Basic/"/>
    
  </entry>
  
  <entry>
    <title>Docker Registry （Docker仓库）</title>
    <link href="https://blog.ajavac.com/2017/08/07/Docker/docker_registry/"/>
    <id>https://blog.ajavac.com/2017/08/07/Docker/docker_registry/</id>
    <published>2017-08-07T07:00:06.000Z</published>
    <updated>2017-08-09T02:09:20.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote>
<p>registry 是存放和分发Docker镜像的一个服务</p>
</blockquote>
<ol>
<li>Docker hub 可以类比为 Github，是一个公共的镜像服务中心</li>
<li>搭建 Registry 可以类比为搭建 GitLab 服务器，是一个私有的镜像服务中心</li>
<li>自建 Registry 可以让镜像私有化，也可以提高镜像拉取速度</li>
</ol>
<h3 id="运行Registry"><a href="#运行Registry" class="headerlink" title="运行Registry"></a>运行Registry</h3><p><a href="https://hub.docker.com/_/registry/" target="_blank" rel="external">Officical</a></p>
<p><code>docker run -d -p 5000:5000 --restart always --name registry registry</code></p>
<h4 id="使用Registry"><a href="#使用Registry" class="headerlink" title="使用Registry"></a>使用Registry</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> 本地运行registry</div><div class="line">docker run -d -p 5000:5000 --restart always --name registry registry</div><div class="line"><span class="meta">#</span> 从官方拉取镜像</div><div class="line">docker pull nginx:alpine</div><div class="line"><span class="meta">#</span> 给镜像加标签</div><div class="line">docker tag nginx:alpine localhost:5000/nginx:alpine</div><div class="line"><span class="meta">#</span> 推送镜像到本地registry</div><div class="line">docker push localhost:5000/nginx:alpine</div><div class="line"><span class="meta">#</span> 删除本地镜像</div><div class="line">docker rmi nginx:alpine localhost:5000/nginx:alpine</div><div class="line"><span class="meta">#</span> 从本地registry 拉取镜像</div><div class="line">docker pull localhost:5000/nginx:alpine</div></pre></td></tr></table></figure>
<h3 id="Registry-API"><a href="#Registry-API" class="headerlink" title="Registry API"></a>Registry API</h3><blockquote>
<p>Registry 有一些API可以方便的看到Registry上都有哪些镜像</p>
</blockquote>
<p><a href="https://docs.docker.com/registry/spec/api/#scope" target="_blank" rel="external">官方文档</a></p>
<table>
<thead>
<tr>
<th>API</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>/v2/</code></td>
<td><code>curl http://localhost:5000/v2/</code></td>
<td>版本检查</td>
</tr>
<tr>
<td><code>/v2/_catalog</code></td>
<td><code>curl http://localhost:5000/v2/_catalog</code></td>
<td>列出资源</td>
</tr>
<tr>
<td><code>/v2/&lt;name&gt;/tags/list</code></td>
<td><code>curl http://localhost:5000/v2/mysql/tags/list</code></td>
<td>列出镜像标签</td>
</tr>
</tbody>
</table>
<h3 id="关于HTTPS问题"><a href="#关于HTTPS问题" class="headerlink" title="关于HTTPS问题"></a>关于HTTPS问题</h3><blockquote>
<p>使用registry时，如果没有配置https会导致其他机器无法拉取镜像</p>
</blockquote>
<p><strong>错误提示：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Error response from daemon: Get https://xx.xx.xx.xx:5000/v1/_ping: http: server gave HTTP response to HTTPS client</div></pre></td></tr></table></figure>
<p><strong>解决方法：</strong></p>
<ol>
<li>方法1: 配置HTTPS，参考<a href="https://docs.docker.com/registry/deploying/#run-an-externally-accessible-registry" target="_blank" rel="external">官方文档</a></li>
<li>方法2: 在客户机配置该registry为非安全源</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> 编辑或者创建 daemon.json 配置文件</div><div class="line">vi /etc/docker/daemon.json</div><div class="line"><span class="meta">#</span> 添加或者输入如下内容</div><div class="line">&#123; "insecure-registries":["10.30.20.214:5000"] &#125;</div><div class="line"><span class="meta">#</span> 重启 docker</div><div class="line">sudo service docker restart</div><div class="line"><span class="meta">#</span> 至此便可以正常拉取镜像了</div></pre></td></tr></table></figure>
<h3 id="定制可迁移的registry"><a href="#定制可迁移的registry" class="headerlink" title="定制可迁移的registry"></a>定制可迁移的registry</h3><blockquote>
<p>若需要在一个内网环境部署docker，那么定制一个可迁移的registry会变使部署变得方便</p>
</blockquote>
<h4 id="1-准备好一个registry容器"><a href="#1-准备好一个registry容器" class="headerlink" title="1. 准备好一个registry容器"></a>1. 准备好一个registry容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> 1. 运行registry容器</div><div class="line">docker run --name some_registry -d -p 5000:5000 --restart always  registry</div><div class="line"><span class="meta">#</span> 2. 从docker hub拉取镜像,如nginx:alpine</div><div class="line">docker pull nginx:alpine</div><div class="line"><span class="meta">#</span> 3. 标记该镜像</div><div class="line">docker tag nginx:alpine localhost:5000/nginx:alpine</div><div class="line"><span class="meta">#</span> 4. 推送该镜像到本地registry</div><div class="line">docker push localhost:5000/nginx:alpine</div><div class="line"><span class="meta">#</span> 重复3和4的步骤，将需要的镜像都推送到本地registry</div></pre></td></tr></table></figure>
<h4 id="2-导出旧registry的数据"><a href="#2-导出旧registry的数据" class="headerlink" title="2. 导出旧registry的数据"></a>2. 导出旧registry的数据</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> some_registry为旧registry容器名</div><div class="line">docker run --rm --volumes-from some_registry -v $(pwd):/backup registry sh -c "cd /var/lib/ &amp;&amp; tar cvf /backup/backup.tar registry"</div></pre></td></tr></table></figure>
<h4 id="3-运行新registry容器"><a href="#3-运行新registry容器" class="headerlink" title="3. 运行新registry容器"></a>3. 运行新registry容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> 在目标机器运行新registry容器（注意端口占用）</div><div class="line">docker run --name new_registry -d -v /var/lib/registry  -p 5000:5000 --restart always registry</div></pre></td></tr></table></figure>
<h4 id="4-导入数据"><a href="#4-导入数据" class="headerlink" title="4. 导入数据"></a>4. 导入数据</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> 导入数据（注意backup.tar要在当前路径下）</div><div class="line">docker run --rm --volumes-from new_registry -v $(pwd):/backup registry sh -c "cd /var/lib/ &amp;&amp; tar xvf /backup/backup.tar"</div><div class="line"><span class="meta">#</span> 查看registry目录，检查是否导入数据成功</div><div class="line">curl localhost:5000/v2/_catalog</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;registry 是存放和分发Docker镜像的一个服务&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;D
    
    </summary>
    
      <category term="Docker" scheme="https://blog.ajavac.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://blog.ajavac.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Nginx跨域</title>
    <link href="https://blog.ajavac.com/2017/07/17/Nginx/nginx_cors/"/>
    <id>https://blog.ajavac.com/2017/07/17/Nginx/nginx_cors/</id>
    <published>2017-07-17T03:31:22.000Z</published>
    <updated>2017-07-17T06:13:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol>
<li>跨域(CORS)全称是 (Cross-origin resource sharing),</li>
<li>由于浏览器的安全限制, 所以才会存在跨域问题</li>
<li>当一个网站的去请求另一个网站的资源时会发生</li>
<li>新版浏览器都支持该功能 (不低于IE10)</li>
</ol>
<p><img src="/img/nginx/cors.jpg" alt="跨域请求流程"></p>
<h2 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>必须同时满足以下条件:</p>
<ol>
<li>请求方法是以下三种方法之一:<ol>
<li>HEAD</li>
<li>GET</li>
<li>POST</li>
</ol>
</li>
<li>头信息不超过以下字段:<ol>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Last-Event-ID</li>
<li>Content-Type: 只限(<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code>)</li>
</ol>
</li>
</ol>
<p>不满足条件的为非简单请求, 浏览器会直接发出CORS请求, 也就是在头信息中增加一个<code>Origin</code>字段</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>Nginx可以通过简单的配置实现简单请求的跨域</p>
<p>在<code>http</code>或者<code>server</code>或者<code>location</code>里面添加<code>add_header &#39;Access-Control-Allow-Origin&#39; &#39;*&#39;;</code>这行命令, 即允许任意<code>Origin</code>地址进行跨域请求</p>
<p>比如在http里面添加:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">http &#123;</div><div class="line">	add_header Access-Control-Allow-Origin *;</div><div class="line">	</div><div class="line">	# 以下省略</div></pre></td></tr></table></figure>
<h2 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>不满足简单请求的皆为非简单请求:</p>
<ol>
<li>比如请求方法是PUT或者DELETE</li>
<li>比如<code>Content-Type</code>是<code>application/json</code></li>
</ol>
<p>非简单请求在正式通信(简单请求)之前会进行一次预检请求(preflight)</p>
<p>预检请求是一个<code>OPTIONS</code>请求, 所以需要对该请求进行处理</p>
<h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><p>在<code>location</code>里面对<code>OPTIONS</code>请求进行特殊配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">location / &#123;</div><div class="line">	if ($request_method = &apos;OPTIONS&apos;) &#123;</div><div class="line">      add_header &apos;Access-Control-Allow-Origin&apos; &apos;*&apos;;</div><div class="line">      add_header &apos;Access-Control-Allow-Methods&apos; &apos;*&apos;;</div><div class="line">      # Custom headers and headers various </div><div class="line">      add_header &apos;Access-Control-Allow-Headers&apos; &apos;Content-Type&apos;;</div><div class="line">      # Tell client that this pre-flight info is valid for 20 days</div><div class="line">      add_header &apos;Access-Control-Max-Age&apos; 1728000;</div><div class="line">      add_header &apos;Content-Type&apos; &apos;text/plain charset=UTF-8&apos;;</div><div class="line">      add_header &apos;Content-Length&apos; 0;</div><div class="line">      return 204;</div><div class="line">	&#125; </div><div class="line">	# 以下省略</div></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="external">跨域资源共享 CORS 详解</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;跨域(CORS)全称是 (Cross-origin resource sharing),&lt;/li&gt;
&lt;li&gt;由于浏览器的安全限制
    
    </summary>
    
      <category term="Nginx" scheme="https://blog.ajavac.com/categories/Nginx/"/>
    
    
      <category term="Common" scheme="https://blog.ajavac.com/tags/Common/"/>
    
      <category term="Nginx" scheme="https://blog.ajavac.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Java 集合框架</title>
    <link href="https://blog.ajavac.com/2017/06/28/Java/java_collection/"/>
    <id>https://blog.ajavac.com/2017/06/28/Java/java_collection/</id>
    <published>2017-06-28T09:50:51.000Z</published>
    <updated>2017-07-23T12:59:49.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><blockquote>
<p>Java集合框架是指导Java的集合类。Collection 接口是一组允许重复的对象。Set 接口继承 Collection，但不允许重复，使用自己内部的一个排列机制。 List 接口继承 Collection，允许重复，以元素安插的次序来放置元素，不会重新排列。Map接口是一组成对的键－值对象，即所持有的是key-value pairs。Map中不能有重复的key。拥有自己的内部排列机制。</p>
<p> ——  wiki</p>
</blockquote>
<p><img src="/img/java/java_collection.jpg" alt="Java集合框架"></p>
<ol>
<li><code>Collection</code> 接口继承了 <code>Iterable</code> 接口</li>
<li><code>List</code> <code>Queue</code> <code>Set</code> 接口继承了 <code>Collection</code> 接口</li>
</ol>
<h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><ol>
<li><code>List</code> 接口继承了 <code>Collection</code> 接口</li>
<li>表示一个有序集合(有序序列), 所有元素通过插入产生, 可以通过数字索引查找</li>
<li>允许重复元素</li>
</ol>
<h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><ol>
<li><code>List</code>的一种基于<strong>可变数组</strong>的实现</li>
<li>允许所有的元素, 包括<code>null</code></li>
<li>与<code>ArrayList</code>大致相同, 除了它是<strong>同步</strong>的, 在单线程环境下优先使用<code>ArrayList</code></li>
<li>特点是: 线程安全(同步), 查找速度快(可按索引), 添加和删除速度较慢( 相对<code>LinkedList</code> )</li>
<li>当<code>capacity</code>(容量) 不足时候自动进行扩容, 为原来2倍(可定制)</li>
<li>通过预先确定容量可以节省扩容消耗的时间</li>
<li><code>fail-fast</code>机制避免遍历时列表被修改(会抛出异常<code>ConcurrentModificationException</code>)</li>
<li>不能过分依赖<code>fail-fast</code>机制,  只能充当一份基本的保障, 用来查找bug</li>
<li>遍历优先使用<code>forEach</code>方法</li>
<li>当需要在遍历时候添加或者删除元素时, 使用<code>ListIterator</code></li>
</ol>
<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><ol>
<li><code>List</code>的一种基于<strong>可变数组</strong>的实现</li>
<li>允许所有的元素, 包括<code>null</code></li>
<li>与<code>Vector</code>大致相同, 除了它是<strong>非同步</strong>的</li>
<li>特点是: 非线程安全(非同步), 查找速度快(可按索引), 添加和删除速度较慢( 相对<code>LinkedList</code> )</li>
<li>当<code>capacity</code>(容量) 不足时候自动进行扩容, 为原来1.5倍</li>
<li>通过预先确定容量可以节省扩容消耗的时间</li>
<li><code>fail-fast</code>机制避免遍历时列表被修改(会抛出异常<code>ConcurrentModificationException</code>)</li>
<li>不能过分依赖<code>fail-fast</code>机制,  只能充当一份基本的保障, 用来查找bug</li>
<li>遍历优先使用<code>forEach</code>方法</li>
<li>当需要在遍历时候添加或者删除元素时, 使用<code>ListIterator</code></li>
</ol>
<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><ol>
<li><code>List</code> 的一种基于<strong>双向链表</strong>的实现</li>
<li>允许所有的元素, 包括<code>null</code></li>
<li>特点是: 非线程安全(<strong>非同步</strong>), 查找速度慢(需要遍历), 添加和删除速度快(相对<code>ArrayList</code>不需要数组拷贝)</li>
<li><code>fail-fast</code>机制避免遍历时列表被修改(会抛出异常<code>ConcurrentModificationException</code>)</li>
<li>不能过分依赖<code>fail-fast</code>机制,  只能充当一份基本的保障, 用来查找bug</li>
<li>遍历优先使用<code>forEach</code>方法</li>
<li>当需要在遍历时候添加或者删除元素时, 使用<code>ListIterator</code></li>
</ol>
<h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><ol>
<li><code>Queue</code> 接口继承了 <code>Collection</code> 接口</li>
<li>表示一个有优先级的队列</li>
<li>部分队列有容量的限制, 大部分则没有限制(即插入操作不会失败)</li>
<li>一般队列是<strong>FIFO (first-in-first-out)</strong>方式的</li>
<li>优先队列(PriorityQueue) 通过比较来排列元素顺序</li>
<li>没有定义非阻塞队列方法, 非阻塞队列接口为 <code>BlockingQueue</code></li>
<li>通常不允许添加<code>null</code>元素, <code>LinkedList</code>允许, 但最好不要, 因为<code>null</code>常常用来作为特殊的返回值</li>
<li>队列的实现类通常没有实现基于元素的<code>equals</code>和<code>hashCode</code>方法, 因为即使队列元素相同, 队列顺序也常常不同</li>
</ol>
<table>
<thead>
<tr>
<th>功能</th>
<th>抛出异常</th>
<th>返回特殊值(如<code>null</code>或者<code>false</code>)</th>
</tr>
</thead>
<tbody>
<tr>
<td>添加元素</td>
<td>add(e)</td>
<td>offer(e)</td>
</tr>
<tr>
<td>获取并删除队列头部元素</td>
<td>remove()</td>
<td>poll()</td>
</tr>
<tr>
<td>获取队列头部元素</td>
<td>element()</td>
<td>peek()</td>
</tr>
</tbody>
</table>
<h2 id="LinkedList-1"><a href="#LinkedList-1" class="headerlink" title="LinkedList"></a>LinkedList</h2><ol>
<li><code>Dqueue</code> (双端队列)/<code>Queue</code>(队列)的一种基于<strong>双向链表</strong>的实现</li>
<li>也可以用作栈, 即 <strong>LIFO (last-in-first-out)</strong></li>
<li>允许所有的元素, 包括<code>null</code>, 但是不建议</li>
<li>特点是: 非线程安全(<strong>非同步</strong>), 可充当队列或者栈, 无容量限制</li>
</ol>
<h2 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h2><ol>
<li>继承自<code>AbstractQueue</code>, 是优先级队列的一种实现 (小顶堆)</li>
<li>不允许<code>null</code>元素</li>
<li>无外部容量限制, 内部容量限制为数组最大容量</li>
<li>特点是: 非线程安全(<strong>非同步</strong>), 可自定义优先级(比较规则)</li>
<li>容量不足时自动扩容, 若原容量小于64则扩容为原来2倍加2, 否则扩容为原来1.5倍</li>
</ol>
<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><ol>
<li><code>Set</code> 接口继承了 <code>Collection</code> 接口</li>
<li>存储一组不重复的元素, 他们之间都是不相等的(通过<code>equals</code>方法判断)</li>
<li>最多存储一个<code>null</code>元素</li>
<li>虽然没有禁止, 但是如果保存可变元素, 可能会破坏<code>Set</code>的不重复特性</li>
<li>一般来说, 禁止保存自身作为元素</li>
<li><code>Set</code>接口的实现类可以选择对元素进行限制</li>
</ol>
<h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><ol>
<li>基于<code>HashMap</code>实现</li>
<li>允许<code>null</code>元素</li>
<li>无序, 非同步</li>
</ol>
<h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><ol>
<li>基于<code>LinkedHashMap</code>实现, 继承了<code>HashSet</code></li>
<li>允许<code>null</code>元素</li>
<li>有序, 非同步</li>
<li>相同元素重复插入时, 顺序不变</li>
</ol>
<h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><ol>
<li>通常情况下基于<code>TreeMap</code>实现, 实现了<code>NavigableSet</code>接口</li>
<li>不允许<code>null</code>元素</li>
<li>有序, 非同步</li>
<li>相同元素重复插入时, 顺序不变</li>
</ol>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><ol>
<li>一种用户保存键值对映射的数据结构</li>
<li>不可保存重复的键值</li>
<li>每个键可以映射最多一个值</li>
<li>取代了类<code>Dictionary</code></li>
<li>提供了三种视图(view): 键视图/值视图/键值对视图</li>
<li>警惕可变类作为map的键的情况, 可能导致键值对不可达</li>
<li>一般不允许自引用</li>
</ol>
<h2 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h2><ol>
<li>继承了<code>Dictionary&lt;K,V&gt;</code>, 实现了<code>Map&lt;K,V&gt;</code></li>
<li><code>非null</code>的对象可以作为键或者值</li>
<li>线程安全, 有序</li>
<li>键必须要实现<code>hashCode</code>和<code>equals</code>方法</li>
<li><code>initial capacity</code>(初始容量) 和 <code>load factor</code>(负载因子, 默认0.75) 影响其性能</li>
<li>扩容时是原来的两倍+1</li>
<li><code>fail-fast</code>机制避免了在<code>iterator</code>(遍历)过程中对Hashtable进行操作, 若发生操作则抛出<code>ConcurrentModificationException</code>异常</li>
<li>不能过分依赖<code>fail-fast</code>机制,  只能充当一份基本的保障, 用来查找bug</li>
<li><code>Hashtable</code>是同步的, 现在版本已不推荐使用. 需要线程安全可以使用<code>ConcurrentHashMap</code>, 不需要线程安全可以使用<code>HashMap</code></li>
</ol>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><ol>
<li>继承了<code>AbstractMap&lt;K,V&gt;</code>, 实现了<code>Map&lt;K,V&gt;</code></li>
<li>允许<code>null</code>作为键或者值</li>
<li>非线程安全, 无序</li>
<li>除了允许<code>null</code>和非同步外和<code>Hashtable</code>比较类似</li>
<li><code>initial capacity</code>(初始容量, 默认16) 和 <code>load factor</code>(负载因子, 默认0.75) 影响其性能</li>
<li>扩容时是原来的两倍</li>
<li><code>fail-fast</code>机制避免了在<code>iterator</code>(遍历)过程中对HashMap进行操作, 若发生操作则抛出<code>ConcurrentModificationException</code>异常</li>
<li>不能过分依赖<code>fail-fast</code>机制,  只能充当一份基本的保障, 用来查找bug</li>
</ol>
<h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><ol>
<li>继承了<code>HashMap&lt;K,V&gt;</code>, 实现了<code>Map&lt;K,V&gt;</code></li>
<li>允许<code>null</code>作为键或者值</li>
<li>非线程安全, 有序</li>
<li>它比<code>HashMap</code>多记录了插入键值对的顺序(使用双向链表, 可以改为访问顺序), 重复插入同个键不影响顺序</li>
<li><code>initial capacity</code>(初始容量, 默认16) 和 <code>load factor</code>(负载因子, 默认0.75) 影响其性能</li>
<li>扩容时是原来的两倍</li>
<li><code>fail-fast</code>机制避免了在<code>iterator</code>(遍历)过程中对LinkedHashMap进行操作, 若发生操作则抛出<code>ConcurrentModificationException</code>异常</li>
<li>不能过分依赖<code>fail-fast</code>机制,  只能充当一份基本的保障, 用来查找bug</li>
<li>因为维持了双向链表, 所以遍历性能比<code>HashMap</code>高</li>
</ol>
<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><ol>
<li>继承了<code>AbstractMap&lt;K,V&gt;</code>, 实现了<code>NavigableMap&lt;K,V&gt;</code></li>
<li>基于红黑树实现，通过键的比较方法（compareTo）或者比较器（Comparator）进行排序，开销是log(n)</li>
<li>不允许<code>null</code>作为键或者值</li>
<li>非线程安全, 有序</li>
<li>插入后不应该再修改该键</li>
<li><code>fail-fast</code>机制避免了在<code>iterator</code>(遍历)过程中对TreeMap进行操作, 若发生操作则抛出<code>ConcurrentModificationException</code>异常</li>
<li>不能过分依赖<code>fail-fast</code>机制,  只能充当一份基本的保障, 用来查找bug</li>
</ol>
<h1 id="Utils"><a href="#Utils" class="headerlink" title="Utils"></a>Utils</h1><blockquote>
<p>JDK 提供了一些工具类用来方便地操作集合和数组</p>
</blockquote>
<h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><blockquote>
<p>包含许多操作数组的静态方法</p>
</blockquote>
<ol>
<li><code>sort</code> 方法用来对数组进行排序</li>
<li><code>parallelSort</code> 方法用来对数组进行并行排序</li>
<li><code>binarySearch</code> 方法用来二分查找数组中的元素</li>
<li><code>equals</code> 用来比较两个数组的内容</li>
<li><code>fill</code> 用来往数组中填充内容</li>
<li><code>copyOf</code> 用来复制数组</li>
<li><code>asList</code> 用来将数组转化成ArrayList</li>
<li><code>hashCode</code> 用来计算数组的hash值</li>
<li><code>toString</code> 用来将数组转化成字符串</li>
</ol>
<h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2><blockquote>
<p> 包含许多操作集合的静态方法</p>
</blockquote>
<ol>
<li><code>sort</code> 方法用来对List进行排序</li>
<li><code>binarySearch</code> 方法用来对List进行二分查找</li>
<li><code>reverse</code> 方法用来对List进行顺序反转操作</li>
<li><code>shuffle</code> 方法用来对List进行随机排列</li>
<li><code>swap</code> 方法用来交换List中两个元素</li>
<li><code>fill</code> 方法用来对List进行填充</li>
<li><code>copy</code> 方法用来拷贝List</li>
<li><code>min</code> 方法用来获取集合中的最小值</li>
<li><code>max</code> 方法用来获取集合中的最大值</li>
<li><code>replaceAll</code> 方法用来对List中的某一值进行替换</li>
<li><code>unmodifiableList</code> 方法用来包装List以获得一个不可变的List</li>
<li><code>synchronizedList</code> 方法用来包装List以获得一个线程安全的List</li>
<li><code>emptyList</code> 方法用来获得一个不可变的空List</li>
<li><code>singletonList</code> 方法用来获得一个单值的List</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://zh.wikipedia.org/wiki/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6" target="_blank" rel="external">Java 集合框架 — Wiki</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;集合&quot;&gt;&lt;a href=&quot;#集合&quot; class=&quot;headerlink&quot; title=&quot;集合&quot;&gt;&lt;/a&gt;集合&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Java集合框架是指导Java的集合类。Collection 接口是一组允许重复的对象。Set 接口继承 Coll
    
    </summary>
    
      <category term="Java" scheme="https://blog.ajavac.com/categories/Java/"/>
    
    
      <category term="Java" scheme="https://blog.ajavac.com/tags/Java/"/>
    
      <category term="Collection" scheme="https://blog.ajavac.com/tags/Collection/"/>
    
      <category term="Basic" scheme="https://blog.ajavac.com/tags/Basic/"/>
    
  </entry>
  
  <entry>
    <title>Linux 网卡配置</title>
    <link href="https://blog.ajavac.com/2017/06/25/Linux/linux_network/"/>
    <id>https://blog.ajavac.com/2017/06/25/Linux/linux_network/</id>
    <published>2017-06-25T13:15:02.000Z</published>
    <updated>2017-06-25T13:18:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一般情况"><a href="#一般情况" class="headerlink" title="一般情况"></a>一般情况</h1><h2 id="查看网卡信息"><a href="#查看网卡信息" class="headerlink" title="查看网卡信息"></a>查看网卡信息</h2><p><code>ip add</code> 或者 <code>ifconfig</code></p>
<h2 id="重启网络"><a href="#重启网络" class="headerlink" title="重启网络"></a>重启网络</h2><p><code>sudo service network restart</code></p>
<h1 id="ubuntu"><a href="#ubuntu" class="headerlink" title="ubuntu"></a>ubuntu</h1><h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><p><code>sudo vi /etc/network/interfaces</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">auto  enp0s3</div><div class="line">iface enp0s3 inet static</div><div class="line">address  192.168.56.5</div><div class="line">network  192.168.56.0</div><div class="line">netmask  255.255.255.0</div><div class="line">gateway  192.168.56.1</div><div class="line">dns-nameservers  8.8.8.8  192.168.56.1</div></pre></td></tr></table></figure>
<h3 id="重启网络配置"><a href="#重启网络配置" class="headerlink" title="重启网络配置"></a>重启网络配置</h3><p><code>sudo service networking restart</code></p>
<h3 id="查看网卡信息-1"><a href="#查看网卡信息-1" class="headerlink" title="查看网卡信息"></a>查看网卡信息</h3><p><code>ip add</code> 或者 <code>ifconfig</code></p>
<h3 id="安装ssh"><a href="#安装ssh" class="headerlink" title="安装ssh"></a>安装ssh</h3><p><code>sudo apt-get install openssh-server</code></p>
<h3 id="检查是否启动"><a href="#检查是否启动" class="headerlink" title="检查是否启动"></a>检查是否启动</h3><p><code>ps -e|grep ssh</code></p>
<h1 id="centos"><a href="#centos" class="headerlink" title="centos"></a>centos</h1><h2 id="修改配置-1"><a href="#修改配置-1" class="headerlink" title="修改配置"></a>修改配置</h2><p><code>sudo vi /etc/sysconfig/network-scripts/ifcfg-enp0s3</code></p>
<p>创建或修改配置文件信息如下（根据你实际的环境进行修改）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">BOOTPROTO=static</div><div class="line">ONBOOT=yes</div><div class="line">IPADDR=192.168.56.10</div><div class="line">NETMASK=255.255.255.0</div><div class="line">GATEWAY=192.168.56.1 #双网卡下删除此项,避免覆盖</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一般情况&quot;&gt;&lt;a href=&quot;#一般情况&quot; class=&quot;headerlink&quot; title=&quot;一般情况&quot;&gt;&lt;/a&gt;一般情况&lt;/h1&gt;&lt;h2 id=&quot;查看网卡信息&quot;&gt;&lt;a href=&quot;#查看网卡信息&quot; class=&quot;headerlink&quot; title=&quot;查看网卡信
    
    </summary>
    
      <category term="Linux" scheme="https://blog.ajavac.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://blog.ajavac.com/tags/Linux/"/>
    
      <category term="Config" scheme="https://blog.ajavac.com/tags/Config/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令</title>
    <link href="https://blog.ajavac.com/2017/06/25/Linux/linux_command/"/>
    <id>https://blog.ajavac.com/2017/06/25/Linux/linux_command/</id>
    <published>2017-06-25T13:11:20.000Z</published>
    <updated>2017-06-25T13:14:02.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>开发过程中可能用到的一些命令</p>
</blockquote>
<h2 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h2><blockquote>
<p>查看网络信息</p>
</blockquote>
<p><code>netstat -an | grep 8080</code><br><code>8080</code>替换成需要查看的端口号</p>
<h2 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a>lsof</h2><blockquote>
<p>查看网络信息</p>
</blockquote>
<p><code>lsof -i:80</code><br>-i参数表示网络链接，:80指明端口号，该命令会同时列出PID，方便kill</p>
<h2 id="lscpu"><a href="#lscpu" class="headerlink" title="lscpu"></a>lscpu</h2><blockquote>
<p>查看cpu信息</p>
</blockquote>
<p>类似效果</p>
<ol>
<li><code>cat /proc/cpuinfo</code></li>
</ol>
<h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><blockquote>
<p>查看内存信息</p>
</blockquote>
<p><code>free -m</code></p>
<p><code>free -h</code></p>
<p>类似效果</p>
<ol>
<li><code>cat /proc/meminfo</code></li>
<li><code>dmidecode -t memory</code></li>
</ol>
<h2 id="lsblk"><a href="#lsblk" class="headerlink" title="lsblk"></a>lsblk</h2><blockquote>
<p>查看磁盘信息</p>
</blockquote>
<p>类似效果</p>
<ol>
<li><code>fdisk -l</code></li>
</ol>
<h2 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h2><blockquote>
<p>查看网卡信息</p>
</blockquote>
<p><code>ifconfig -a</code></p>
<p>类似效果</p>
<ol>
<li><code>lspci | grep -i &#39;eth&#39;</code></li>
<li><code>ip add</code></li>
<li><code>ip link show</code></li>
<li><code>ethtool eth0</code></li>
</ol>
<h2 id="lspci"><a href="#lspci" class="headerlink" title="lspci"></a>lspci</h2><blockquote>
<p>查看硬件信息</p>
</blockquote>
<p><code>lscpi -t</code></p>
<p><code>lspci -v</code> 或者 <code>lspci -vv</code></p>
<p>类似效果</p>
<ol>
<li><code>dmidecode -q</code></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;开发过程中可能用到的一些命令&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;netstat&quot;&gt;&lt;a href=&quot;#netstat&quot; class=&quot;headerlink&quot; title=&quot;netstat&quot;&gt;&lt;/a&gt;netstat&lt;/h2&gt;&lt;blo
    
    </summary>
    
      <category term="Linux" scheme="https://blog.ajavac.com/categories/Linux/"/>
    
    
      <category term="Terminal" scheme="https://blog.ajavac.com/tags/Terminal/"/>
    
      <category term="Linux" scheme="https://blog.ajavac.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Java IO</title>
    <link href="https://blog.ajavac.com/2017/06/20/Java/java_io/"/>
    <id>https://blog.ajavac.com/2017/06/20/Java/java_io/</id>
    <published>2017-06-20T01:15:39.000Z</published>
    <updated>2017-06-25T13:02:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h1><blockquote>
<p>面向流, 阻塞IO</p>
</blockquote>
<h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><h3 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>read()</td>
<td>一次读取一个字节(0-255), 当读取到文件末尾时返回<code>-1</code></td>
</tr>
<tr>
<td>read(byte[])</td>
<td>一次性读取一个字节数组, 返回读取到的字节数, 当读取到末尾时返回<code>-1</code></td>
</tr>
</tbody>
</table>
<h3 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>write(int)</td>
<td>写入一个字节(0-255)的数据</td>
</tr>
<tr>
<td>write(byet[])</td>
<td>写入一个字节数组</td>
</tr>
</tbody>
</table>
<h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><h3 id="InputStreamReader"><a href="#InputStreamReader" class="headerlink" title="InputStreamReader"></a>InputStreamReader</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>read()</td>
<td>一次读取一个字符(int), 当读取到文件末尾时返回<code>-1</code></td>
</tr>
<tr>
<td>read(char[])</td>
<td>一次性读取一个字符数组, 返回读取到的字符数, 当读取到末尾时返回<code>-1</code></td>
</tr>
</tbody>
</table>
<h3 id="OutputStreamReader"><a href="#OutputStreamReader" class="headerlink" title="OutputStreamReader"></a>OutputStreamReader</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>write(int)</td>
<td>写入一个字符的数据</td>
</tr>
<tr>
<td>write(char[])</td>
<td>写入一个字符数组</td>
</tr>
</tbody>
</table>
<h2 id="try-with-resource"><a href="#try-with-resource" class="headerlink" title="try-with-resource"></a>try-with-resource</h2><blockquote>
<p>Java 7 开始引入, 替代传统用<code>finally</code>关闭流的方式</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">	<span class="keyword">try</span>(InputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">"file.txt"</span>)) &#123;</div><div class="line">      <span class="keyword">int</span> data = input.read();</div><div class="line">      <span class="keyword">while</span>(data != -<span class="number">1</span>)&#123;</div><div class="line">        System.out.println((<span class="keyword">char</span>) data);</div><div class="line">        data = input.read();</div><div class="line">      &#125;</div><div class="line">	&#125; <span class="keyword">catch</span>(IOException e) &#123;</div><div class="line">      <span class="keyword">throw</span> UncheckedIOException(e);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li><p>在try块结束后, 自动完成流的关闭操作, 大大简化的流操作的编程</p>
</li>
<li><p>不用进行<code>finally</code>块的流关闭操作以及关闭操作的异常处理, 直接在catch块对异常进行统一处理)</p>
</li>
<li><p>可以使用多个资源, 关闭时按顺序进行关闭</p>
</li>
<li><p>可以自定义类, 只要实现了 <code>AutoClosable</code> 即可</p>
</li>
<li><p>当关闭流异常时, 直接由catch块捕捉</p>
</li>
<li><p>当try块和关闭流都抛出异常时, 抛出try块的异常, 关闭流的异常被抑制, 情况正好与<code>finally</code>方式相反</p>
<p>​</p>
</li>
</ol>
<h1 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h1><blockquote>
<p>面向缓冲, 非阻塞IO, 三大组件</p>
</blockquote>
<h2 id="通道-Channel"><a href="#通道-Channel" class="headerlink" title="通道 (Channel)"></a>通道 (Channel)</h2><blockquote>
<p>既可以从通道中读取数据, 又可以写数据到通道</p>
</blockquote>
<ol>
<li>可读可写</li>
<li>可以异步</li>
<li>总是先读取到一个Buffer, 或者从一个Buffer中写入</li>
</ol>
<table>
<thead>
<tr>
<th>通道实现</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>FileChannel</td>
<td>从文件中读写数据</td>
</tr>
<tr>
<td>DatagramChannel</td>
<td>能通过UDP读写网络中的数据</td>
</tr>
<tr>
<td>SocketChannel</td>
<td>能通过TCP读写网络中的数据</td>
</tr>
<tr>
<td>ServerSocketChannel</td>
<td>可以监听新进来的TCP连接, 对每个新进来的连接都会创建一个SocketChannel</td>
</tr>
</tbody>
</table>
<h2 id="缓冲区-Buffer"><a href="#缓冲区-Buffer" class="headerlink" title="缓冲区 (Buffer)"></a>缓冲区 (Buffer)</h2><blockquote>
<p>用于和NIO通道进行交互, 本质是一块可以写入数据, 然后可以从中读取数据的内存</p>
</blockquote>
<p>用法:</p>
<ol>
<li>写入数据到Buffer</li>
<li>调用flip()方法</li>
<li>从Buffer中读取数据</li>
<li>调用clear()方法或者compact()方法</li>
</ol>
<h2 id="选择器-Selector"><a href="#选择器-Selector" class="headerlink" title="选择器 (Selector)"></a>选择器 (Selector)</h2><blockquote>
<p>选择器允许一个单独的线程来监视多个通道</p>
</blockquote>
<h1 id="I-O模型"><a href="#I-O模型" class="headerlink" title="I/O模型"></a>I/O模型</h1><h2 id="I-O类型"><a href="#I-O类型" class="headerlink" title="I/O类型"></a>I/O类型</h2><ul>
<li>同步(Sync)/异步(Async)</li>
<li>阻塞(Block)/非阻塞(Unblock)</li>
</ul>
<p>主要针对Client端:</p>
<ul>
<li>同步: 一个功能调用,在没有得到结果前,该调用不返回.期间不能干其他事</li>
<li>异步: 一个功能调用后,调用者不能立刻得到结果.实际处理调用的部件在完成后,通过状态/通知和回调来通知调用者.举例:Ajax请求</li>
</ul>
<p>主要针对Server端:</p>
<ul>
<li>阻塞: 调用结果返回之前,当前线程被挂起(线程暂停运行,不同于同步).</li>
<li>非阻塞: 与阻塞概念对立,不能立刻得到结果时,该函数不会阻塞当前线程,而会立刻返回.</li>
</ul>
<ol>
<li>阻塞对象上可以有非阻塞的调用方式,非阻塞对象上可以有阻塞的调用方式.</li>
<li>同/异步由Client端控制,但是需要Server端配合实现,Client端不关心Server端是否阻塞/非阻塞</li>
<li>同/异步区别: 数据访问的时候进程是否阻塞</li>
<li>阻塞/非阻塞区别: 应用程序的调用是否立即返回</li>
</ol>
<h2 id="Linux-下的五种I-O模型"><a href="#Linux-下的五种I-O模型" class="headerlink" title="Linux 下的五种I/O模型"></a>Linux 下的五种I/O模型</h2><ol>
<li>阻塞I/O（blocking I/O）</li>
<li>非阻塞I/O （nonblocking I/O）</li>
<li>I/O复用(select 和poll) （I/O multiplexing）</li>
<li>信号驱动I/O （signal driven I/O (SIGIO)）</li>
<li>异步I/O （asynchronous I/O (the POSIX aio_functions)）</li>
</ol>
<p>前4种都是同步IO,第5种才是异步IO</p>
<p>NIO给我们带来了些什么：</p>
<blockquote>
<ul>
<li>事件驱动模型</li>
<li>避免多线程</li>
<li>单线程处理多任务</li>
<li>非阻塞I/O，I/O读写不再阻塞，而是返回0</li>
<li>基于block的传输，通常比基于流的传输更高效</li>
<li>更高级的IO函数，zero-copy</li>
<li>IO多路复用大大提高了Java网络应用的可伸缩性和实用性</li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;BIO&quot;&gt;&lt;a href=&quot;#BIO&quot; class=&quot;headerlink&quot; title=&quot;BIO&quot;&gt;&lt;/a&gt;BIO&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;面向流, 阻塞IO&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;字节流&quot;&gt;&lt;a href=&quot;#字节
    
    </summary>
    
      <category term="Java" scheme="https://blog.ajavac.com/categories/Java/"/>
    
    
      <category term="Java" scheme="https://blog.ajavac.com/tags/Java/"/>
    
      <category term="Basic" scheme="https://blog.ajavac.com/tags/Basic/"/>
    
  </entry>
  
  <entry>
    <title>JVM</title>
    <link href="https://blog.ajavac.com/2017/06/14/Java/jvm/"/>
    <id>https://blog.ajavac.com/2017/06/14/Java/jvm/</id>
    <published>2017-06-14T09:41:03.000Z</published>
    <updated>2017-06-18T15:51:42.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>主要讨论 HotSpot 虚拟机</p>
</blockquote>
<h2 id="Java平台体系"><a href="#Java平台体系" class="headerlink" title="Java平台体系"></a>Java平台体系</h2><p><img src="/img/java/java_platform.jpg" alt="Java平台"></p>
<p>图片来源: <a href="http://docs.oracle.com/javase/8/docs/index.html" target="_blank" rel="external">Java Platform Standard Edition 8 Documentation</a></p>
<h2 id="JVM五大区"><a href="#JVM五大区" class="headerlink" title="JVM五大区"></a>JVM五大区</h2><p><img src="/img/java/jvm_runtime_data_area.jpg" alt="JVM运行时数据区"></p>
<table>
<thead>
<tr>
<th>JVM运行时数据区(Runtime Data Area)</th>
<th>可能抛出异常</th>
<th>线程私有</th>
</tr>
</thead>
<tbody>
<tr>
<td>程序计数器(Program Counter Register)</td>
<td>无</td>
<td>是</td>
</tr>
<tr>
<td>虚拟机栈(VM Stack)</td>
<td>StackOverflowError/OutOfMemoryError</td>
<td>是</td>
</tr>
<tr>
<td>本地方法栈(Native Method Stack)</td>
<td>StackOverflowError/OutOfMemoryError</td>
<td>是</td>
</tr>
<tr>
<td>堆(Heap)</td>
<td>OutOfMemoryError</td>
<td>否</td>
</tr>
<tr>
<td>方法区(Method Area)</td>
<td>OutOfMemoryError</td>
<td>否</td>
</tr>
</tbody>
</table>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><blockquote>
<p>程序计数器(Program Counter Register)是一块较小的内存空间,可以看作当前线程所执行的字节码的行号指示器</p>
</blockquote>
<ol>
<li>字节码解释器工作时通过改变程序计数器的值来选取下一条需要执行的字节码指令</li>
<li>分支/循环/跳转/异常处理/线程恢复等基础功能都需要依赖程序计数器来完成</li>
<li>每条线程的程序计数器互补影响,独立存储</li>
<li>执行Java方法时,程序计数器记录的是正在执行的虚拟机字节码指令的地址</li>
<li>执行Native方法时,程序计数器的值为空(Undefined)</li>
<li>程序计数器是<strong>唯一一个</strong>在Java虚拟机规范中没有规定任何<code>OutOfMemoryError</code>情况的区域</li>
</ol>
<h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><blockquote>
<p>Java虚拟机栈(Java Virtual Machine Stacks) 也是线程私有的, 它的生命周期与线程相同</p>
</blockquote>
<ol>
<li>虚拟机栈描述的是Java方法执行的内存模型</li>
<li>每个Java方法在执行时都会创建一个栈帧(Stack Frame)用于存储局部变量表/操作数栈/动态链接/方法出口等信息</li>
<li>每个Java方法从调用到执行完成的过程,对应一个栈帧在虚拟机栈中入栈到出栈的过程</li>
<li>64位长度的long和double类型的数据会占用2个局部变量空间(Slot),其余的数据类型只占用1个</li>
<li>局部变量表所需的内存空间在编译期间完成分配,当进入一个方法时,这个方法所需在帧中分配多大的局部变量空间是完全确定的,在方法运行期间不会改变局部变量表的大小</li>
<li>若线程请求的栈深度大于虚拟机锁允许的深度, 将抛出<code>StackOverflowError</code>异常</li>
<li>若虚拟机可以动态扩展(大部分Java虚拟机都支持)且扩展时无法申请到足够的内存, 将抛出<code>OutOfMemoryError</code>异常</li>
</ol>
<p>局部变量表存放的各种基本数据类型:</p>
<table>
<thead>
<tr>
<th>局部变量表基本数据类型</th>
<th>默认值</th>
<th>占用空间bit</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean</td>
<td>false</td>
<td>1</td>
</tr>
<tr>
<td>byte</td>
<td>0x00</td>
<td>16</td>
</tr>
<tr>
<td>char</td>
<td>ux0000</td>
<td>16</td>
</tr>
<tr>
<td>short</td>
<td>0</td>
<td>8</td>
</tr>
<tr>
<td>int</td>
<td>0</td>
<td>32</td>
</tr>
<tr>
<td>float</td>
<td>0.0</td>
<td>32</td>
</tr>
<tr>
<td>long</td>
<td>0</td>
<td>64</td>
</tr>
<tr>
<td>double</td>
<td>0.0</td>
<td>64</td>
</tr>
<tr>
<td>reference</td>
<td>null</td>
<td>32/64</td>
</tr>
</tbody>
</table>
<p>对象引用(reference类型), 不等同于对象本身,可能是指向对象起始地址的引用指针,也可能是指向一个代表对象的句柄或其他与此对象相关的位置</p>
<p>returnAddress类型指向了一条字节码指令的地址</p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><blockquote>
<p>本地方法栈(Native Method Stack)与虚拟机栈的作用非常相识, 只不过是虚拟机栈为Java方法服务, 而本地方法栈为虚拟机使用到的Native方法服务</p>
</blockquote>
<ol>
<li>若线程请求的栈深度大于虚拟机锁允许的深度, 将抛出<code>StackOverflowError</code>异常</li>
<li>若虚拟机可以动态扩展(大部分Java虚拟机都支持)且扩展时无法申请到足够的内存, 将抛出<code>OutOfMemoryError</code>异常</li>
</ol>
<h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><blockquote>
<p>一般情况下Java堆(Java Heap) 是Java虚拟机所管理的内存中最大的一块</p>
</blockquote>
<ol>
<li>Java 堆是被所有线程共享的一块内存区域, 在虚拟机启动时创建</li>
<li>唯一目的是存放对象实例, <strong>几乎所有</strong>对象实现都在这里分配内存</li>
<li>Java 堆是垃圾收集器管理的主要区域,所以也成为<code>GC堆(Garbage Collected Heap)</code></li>
<li>根据垃圾收集器的分代收集算法, Java堆还可以细分为: 新生代和老年代等</li>
<li>Java 堆可以处于物理上不连续的内存空间中, 只要逻辑上是连续的即可</li>
<li>可以通过<code>-Xmx</code>和<code>-Xms</code>控制Java 堆的大小</li>
<li>当Java 堆中没有内存完成实例分配, 并且堆也无法再扩展时, 将会抛出<code>OutOfMemoryError</code>异常</li>
</ol>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><blockquote>
<p>方法区(Method Area) 与Java 堆一样, 是各个线程共享的内存区域, 用于存储已被虚拟机加载的类信息/常量/静态变量/即使编译器(JITC)编译后的代码等数据</p>
</blockquote>
<ol>
<li>别名为Non-Heap(非堆), 目的在于和Java 堆区分开来</li>
<li>常被称为永久代(Permanent Generation), 本质上两者并不等价</li>
<li>当方法区无法满足内存分配需求时, 将抛出<code>OutOfMemoryError</code>异常</li>
</ol>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><blockquote>
<p>运行时常量池(Runtime Constant Pool)是方法区的一部分</p>
</blockquote>
<ol>
<li>用于存放编译器生成的各种字面量和符合引用, 将在类加载后进入方法区的运行时常量池中存放</li>
<li>具备动态性, 比如String的intern()方法</li>
<li>当常量池无法再申请到内存时会抛出<code>OutOfMemoryError</code>异常</li>
</ol>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><blockquote>
<p>直接内存(Direct Memory) 不是虚拟机运行时数据区的一部分,但是也能导致OutOfMemoryError异常出现</p>
</blockquote>
<ol>
<li>JDK 1.4 中新加入 <code>NIO</code> 类,引入了基于通道(<code>Channel</code>)和缓冲区(<code>Buffer</code>)的I/O方式,它可以使用Native函数库直接分配堆外内存,然后通过操作存储在Java堆中的<code>DirectByteBuffer</code>对象作为这块内存的引用进行操作</li>
<li>避免了在Java堆和Native堆来回复制数据,显著提高性能</li>
<li>不受Java堆大小限制,受本机总内存(RAM和SWAP或者分页文件)大小和处理器寻址空间的限制</li>
<li>通过<code>-Xmx</code>配置虚拟机参数时要注意直接内存并不受这个参数限制,需要考虑内存区域总和是否大于物理内存限制</li>
<li>可能抛出<code>OutOfMemoryError</code>异常</li>
</ol>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><blockquote>
<p>垃圾收集 (Garbage Collection, GC) 需要解决3件事情: 那些内存需要回收(What)/什么时候回收(When)/如何回收(How)</p>
</blockquote>
<h3 id="对象存活判断"><a href="#对象存活判断" class="headerlink" title="对象存活判断"></a>对象存活判断</h3><blockquote>
<p>常见判断方法有引用计数算法和可达性分析算法</p>
</blockquote>
<h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><ol>
<li>给对象添加引用计数器, 当有一个地方引用它时就加1, 当引用失效时就减1, 引用计数器为0的对象就是不可能再被使用的</li>
<li>实现简单, 判定效率高</li>
<li>应用案例有: 微软的COM技术/FlashPlayer/Python/Squirrel等</li>
<li>主流Java虚拟机并没有选用引用计数算法来管理内存, 因为其难以解决对象之间相互循环引用问题</li>
</ol>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><ol>
<li>主流的商用程序语言(Java/C#/Lisp)就是使用可达性分析算法 (Reachability Analysis)来判定对象是否存活</li>
<li>通过一系列称之为<code>GC Roots</code>的对象作为起始点, 从这些节点开始向下搜索, 搜索锁走过的路径称为引用链 (Reference Chain), 当一个对象到<code>GC Roots</code>没有任何引用链相连(即<code>GC Roots</code>到这个对象不可达),则此对象是不可用的</li>
</ol>
<p>在Java中, 可作为<code>GC Roots</code>的对象有:</p>
<ol>
<li>虚拟机栈 (栈帧中的本地变量表) 中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI (Native方法) 引用的对象</li>
</ol>
<h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><blockquote>
<p>Java 对引用的概念进行了扩充, 分为4种引用类型</p>
</blockquote>
<ol>
<li><strong>强引用 (Strong Reference)</strong>: 即代码中普遍存在的引用,  只要引用还存在, 垃圾收集器永远不会回收掉被引用的对象, 如<code>String str = &quot;I am OK&quot;;</code></li>
<li><strong>软引用 (Soft Reference)</strong>: 用来描述一些还有用但并非必需的对象, 在系统将要发生内存溢出异常之前, 将会对这些对象列入回收范围之中进行第二次回收,若回收后内存还是不足, 才会抛出内存溢出溢出. 在 <code>JDK 1.2</code> 之后, 提供了<code>SoftReference</code> 类来实现软引用</li>
<li><strong>弱引用 (weak Reference)</strong>: 弱引用也是用来描述非必需对象的, 但是它比软引用更弱一些, 被弱引用关联的对象只能生存到下一次垃圾收集发生之前, 无论当前内存是否足够. 在 <code>JDK 1.2</code> 之后, 提供了<code>WeakReference</code> 类来实现弱引用</li>
<li><strong>虚引用 (Phantom Reference)</strong>: 也称幽灵引用或者幻影引用, 它是最弱的一种引用关系. 一个对象是否有虚引用存在, 完全不会对其生存时间构成影响, 也无法通过虚引用来取得一个对象实例. 为一个对象设置虚引用的唯一目的是能在这个对象被收集器回收时收到一个系统通知. 在 <code>JDK 1.2</code> 之后, 提供了<code>PhantomReference</code> 类来实现虚引用</li>
</ol>
<h4 id="对象回收"><a href="#对象回收" class="headerlink" title="对象回收"></a>对象回收</h4><ol>
<li>在可达性分析算法中不可达的对象, 也并非一定会被回收, 至少要经历两次标记过程</li>
<li>如果对象进行可达性分析后发现没有与 <code>GC Roots</code> 相连接的引用链, 那他将会被第一次标记并且进行一次筛选, 筛选条件是该对象是否有必要执行<code>finalize()</code>方法</li>
<li>当对象没有覆盖 <code>finalize()</code>方法或者<code>finalize()</code>方法已经被虚拟机调用过, 虚拟机将这两种情况都视为 “没必要执行”</li>
<li>若对象被判定为有必要执行 <code>finalize()</code> 方法, 那么该对象将会被放置在一个叫做 <code>F-Queue</code> 的队列中, 并在稍后由一个虚拟机自动建立的、低优先级的<code>Finalizer</code> 线程去执行它, 但是并不承诺会等待它运行结束 (避免该方法长久占用执行资源, 导致其他队列中的对象永久等待, 甚至导致整个内存回收系统崩溃)</li>
<li><code>finalize()</code>方法是对象逃脱死亡命运的最后一次机会, 稍后 GC 将对 F-Queue 中的对象进行第二次小规模的标记, 检查其中对象是否有重新与 <code>GC Roots</code> 建立引用链</li>
<li><code>finalize()</code>方法运行代价高昂, 不建议使用它</li>
</ol>
<h4 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h4><ol>
<li>永久代的垃圾收集主要回收 <strong>废弃常量</strong> 和 <strong>无用的类</strong></li>
<li>回收废弃常量与回收Java堆中的对象非常类似</li>
<li>类需要同时满足3个条件才能算作无用的类,才<strong>可以</strong>被回收: 该类所有实例都已经被回收(即 Java 堆中不存在该类的任何实例) / 加载该类的 <code>ClassLoader</code> 已经被回收 / 该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用, 无法在任何地方通过反射访问该类的方法</li>
<li>Hotspot 虚拟机可以通过 <code>-Xnoclassgc</code> 控制是否对类进行回收</li>
<li>Hotspot 虚拟机可以通过 <code>-verbose:class</code> 以及 <code>-XX:+TraceClassLoading</code> 和 <code>-XX:TraceClassUnLoading</code> 查看类加载和卸载信息</li>
<li>在大量使用反射/动态代理/CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁定义ClassLoader的场景都需要虚拟机具备类卸载功能， 以保证永久代不会溢出 </li>
</ol>
<h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><blockquote>
<p>常见的垃圾收集(GC)算法有: 标记-清除算法/复制算法/标记-整理算法/分代收集算法</p>
</blockquote>
<h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><ol>
<li>标记-清除 (Mark-Sweep) 算法是最基础的收集算法, 后续的算法都是基于这种思路并对其不足进行改进而得到的</li>
<li>算法分为标记和清除两个阶段,首先标记出要回收的对象, 在标记完成后统一回收所有被标记的对象</li>
<li>不足一, 效率问题, 标记和清除这两个过程效率都不高.</li>
<li>不足二, 空间问题, 标记清除之后会产生大量不连续的内存碎片, 导致下次分配大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作</li>
</ol>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><ol>
<li>复制(Copying) 算法, 将可用内存按容量划分为大小相等的两块, 每次只用其中一块</li>
<li>当使用的那一快内存用完了, 就将存活着的对象复制到另一块上面, 然后将已使用过的内存空间一次清理掉</li>
<li>内存分配时不用考虑内存空间碎片等复杂情况, 实现简单, 运行高效</li>
<li>不足一, 将内存缩小为原来的一半</li>
<li>不足二, 在对象存活率较高时就要进行较多的复制操作, 效率将会变低, 所以老年代一般不直接使用这种算法</li>
<li>现在的商业虚拟机都采用这种收集算法来回收新生代 (可能采用8:1:1的方式)</li>
</ol>
<h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><ol>
<li>标记-整理(Mark-Compact) 算法, 标记过程和标记-清除算法一样, 但是后续步骤不是直接对可回收对象进行清理, 而是让所有存活对象都向一端移动, 然后直接清理掉端边界以外的内存</li>
<li>不足, 效率问题, 标记和整理这两个过程效率都不高</li>
</ol>
<h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><ol>
<li>分代收集(Generational Collection) 算法, 根据对象存活周期的不同将内存划分为几块</li>
<li>一般讲Java堆划分为新生代和老年代, 根据各个年代的特定采用最适当的收集算法. 新生代每次垃圾收集都有大批对象死去, 只有少量存活, 那就选用复制算法. 老年代对象存活率高, 没有额外空间对它进行分配担保, 使用标记-清除算法或者标记-整理算法</li>
</ol>
<h4 id="HotSpot-的算法实现"><a href="#HotSpot-的算法实现" class="headerlink" title="HotSpot 的算法实现"></a>HotSpot 的算法实现</h4><ol>
<li>枚举根节点, 可达性分析会导致GC停顿(Stop the World), 使用称为OopMap的数据结构实现</li>
<li>安全点(Safep`oint), 使用主动式中断(Voluntary Suspension) , 不使用抢先式中断(Preemptive Suspension)</li>
<li>安全区域(Safe Region), 线程处于Sleep状态或者Blocked 状态时, 无法响应JVM的中断请求, 所以需要安全区域来解决这个问题, 所以JVM发起GC时就不用管标识自己为Safe Region 状态的线程了</li>
</ol>
<h3 id="常见的垃圾收集器"><a href="#常见的垃圾收集器" class="headerlink" title="常见的垃圾收集器"></a>常见的垃圾收集器</h3><blockquote>
<p>如果说垃圾收集算法是内存回收的方法论, 那么垃圾收集器就是内存回收的具体实现</p>
</blockquote>
<p><img src="/img/java/jvm_gc_collection.jpg" alt="HotSpot垃圾收集器"></p>
<p>对垃圾收集器来说的并行和并发</p>
<ol>
<li>并行 (Parallel) : 多条垃圾收集器线程并行工作, 此时用户线程仍然处于等待状态</li>
<li>并发 (Concurrent): 用户线程和垃圾收集线程同时执行(不一定并行, 可能交替执行)</li>
</ol>
<h4 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h4><ol>
<li>新生代收集器,  是最基本/发展历史最悠久的收集器, 在<code>JDK 1.3.1</code>之前是新生代收集器的唯一选择</li>
<li>单线程, 一条收集线程, 而且收集时必须暂停其他所有的工作线程直到收集结束</li>
<li>是虚拟机运行在<code>Client</code>模式下的默认新生代收集器</li>
<li>优点: 简单/高效</li>
<li>缺点: 单线程收集/必须暂停其他所有工作线程</li>
</ol>
<h4 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h4><ol>
<li>新生代收集器, 是Serial 收集器的多线程版本</li>
<li>多线程, 多条收集线程, 而且收集时必须暂停其他所有的工作线程直到收集结束</li>
<li>是虚拟机运行在<code>Server</code>模式下的默认新生代收集器</li>
<li>只有它能与<code>CMS</code>收集器配合工作</li>
<li>在单CPU环境下绝不会有比Serial 收集器更好的效果</li>
<li>优点: 简单/高效/多线程</li>
<li>缺点: 必须暂停其他所有工作线程</li>
</ol>
<h4 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h4><ol>
<li>新生代收集器, 使用复制算法的收集器, 并行的多线程收集器</li>
<li>目标是达到一个可控制的吞吐量 (Throughput) , 吞吐量= 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)</li>
<li>适合用在后台运算而不需要太多交互的任务, 比如服务器</li>
<li>优点: 吞吐量可控/多线程</li>
<li>缺点: 不适合对响应速度要求高的地方/必须暂停其他所有工作线程</li>
</ol>
<h4 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h4><ol>
<li>老年代收集器, 单线程收集器, 使用标记-整理算法</li>
<li>主要给<code>Client</code>模式下的虚拟机使用</li>
<li><code>Server</code>模式下, 用途: 一在<code>JDK 1.5</code>及以前版本中与Parallel Scavenge 收集器搭配使用, 二作为CMS收集器的后备方案, 在并发收集发生 <code>Concurrent Mode Failure</code>时使用</li>
<li>优点: 简单/高效</li>
<li>缺点: 单线程收集/必须暂停其他所有工作线程</li>
</ol>
<h4 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h4><ol>
<li>老年代收集器, 使用多线程和标记-整理算法, 是Parallel Scavenge 收集器的老年代版本</li>
<li><code>JDK 1.6</code>及之后版本才提供</li>
<li>在注重吞吐量以及CPU资源敏感的场合(如服务器), 优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器的组合</li>
<li>优点: 吞吐量优先/多线程</li>
<li>缺点: 必须暂停其他所有工作线程</li>
</ol>
<h4 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h4><ol>
<li>老年代收集器, CMS (Concurrent Mark Sweep) 收集器是一种以获取最短回收停顿时间为目标的收集器, 基于标记-清除算法实现的</li>
<li>B/S 架构的服务器尤其重视服务的响应速度, 希望系统停顿时间最短, 以给用户带来较好的体验</li>
<li>过程: 初始标记 (CMS initial mark, 会Stop the World), 并发标记(CMS concurrent mark), 重新标记(CMS remark, 会Stop the World), 并发清除(CMS concurrent sweep)</li>
<li>优点: 并发收集/低停顿 (Concurrent Low Pause Collector)</li>
<li>缺点:  对CPU资源非常敏感 /无法处理浮动垃圾(Floating Garbage) /清理后会有大量空间碎片产生</li>
</ol>
<h4 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h4><ol>
<li>新生代/老年代收集器, G1(Garbage First) 是当今收集器技术发展的最前沿成果之一, 在 <code>JDK 1.7</code> 后提供</li>
<li>G1 是一款面向服务端应用的垃圾收集器, 可以独立管理整个GC堆</li>
<li>特点: 并行与并发/分代收集/空间整合/</li>
<li>优点: 停顿时间短且可预测/收集效果好/不会产生空间碎片</li>
<li>缺点: 不够成熟</li>
</ol>
<h3 id="MinorGC"><a href="#MinorGC" class="headerlink" title="MinorGC"></a>MinorGC</h3><ol>
<li>指发生在新生代中的垃圾收集动作, 采用复制算法, 也称<strong>新生代GC</strong></li>
<li>一般回收速度比较快, 次数也非常频繁</li>
<li>大对象直接进入老年代, 避免短命大对象</li>
<li>长期存活对象进入老年代, 动态对象年龄判断, 空间分配担保</li>
<li>触发条件:  只要<code>Eden</code>空间不足就开始进行</li>
<li>新生代按<code>8:1:1</code>的比例分为三个区: <code>Eden</code>/<code>from</code>/<code>to</code></li>
<li><code>-XX:+PrintGCDetails</code> 可以打印内存回收日志</li>
</ol>
<h3 id="FullGC-Major-GC"><a href="#FullGC-Major-GC" class="headerlink" title="FullGC / Major GC"></a>FullGC / Major GC</h3><ol>
<li>针对整个新生代/老生代/元空间的全局范围的GC, 老年代采用标记-清除算法, 也称<strong>老年代GC</strong></li>
<li>经常会伴随至少一次的 Minor GC (并非绝对)</li>
<li>一般比Minor GC 慢10倍以上</li>
<li>触发条件: 老年代空间不足/ PermSpace (元空间) 不足 / 统计得到的Minor GC 晋升到老年代的平均大小大于老年代的剩余空间</li>
</ol>
<h2 id="JVM监控和优化"><a href="#JVM监控和优化" class="headerlink" title="JVM监控和优化"></a>JVM监控和优化</h2><blockquote>
<p>监控数据: 运行日志/异常堆栈/GC日志/线程快照(threaddump / javacore 文件)/堆转储快照( heapdump / hprof 文件) 等</p>
</blockquote>
<h3 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h3><table>
<thead>
<tr>
<th>名称</th>
<th>主要作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>jps</td>
<td>JVM Process Status Tool, 显示指定系统内所有的 HotSpot 虚拟机进程</td>
</tr>
<tr>
<td>jstat</td>
<td>JVM Statistics Monitoring Toll, 用于收集 HotSpot 虚拟机各方面的运行数据</td>
</tr>
<tr>
<td>jinfo</td>
<td>Configuration Info for Java, 显示虚拟机配置信息</td>
</tr>
<tr>
<td>jmap</td>
<td>Memory Map for Java, 生成虚拟机的内存转储快照 (heapdump 文件)</td>
</tr>
<tr>
<td>jhat</td>
<td>JVM Heap Dump Browser, 用于分析heapdump 文件, 会建立 HTTP 服务器, 可在浏览器中查看分析结果</td>
</tr>
<tr>
<td>jstack</td>
<td>Stack Trace for Java, 显示虚拟机的线程快照</td>
</tr>
</tbody>
</table>
<h3 id="可视化工具"><a href="#可视化工具" class="headerlink" title="可视化工具"></a>可视化工具</h3><table>
<thead>
<tr>
<th>名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>jconsole</td>
<td>JConsole (Java Monitoring and Management Console) Java 监视与管理控制台, 是一种基于 JMX 的可视化监视/管理工具</td>
</tr>
<tr>
<td>jvisualvm</td>
<td>JVisual (All-in-One Java Trobleshooting Tool)多合一运行监控和故障处理工具</td>
</tr>
</tbody>
</table>
<h3 id="日志查询"><a href="#日志查询" class="headerlink" title="日志查询"></a>日志查询</h3><p><code>-XX:+PrintGCDetails</code> 可以打印内存回收日志</p>
<h3 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h3><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-Xms20M</td>
<td>限制Java堆的初始大小/最小大小为20M</td>
</tr>
<tr>
<td>-Xmx30M</td>
<td>限制Java堆的最大大小为30M</td>
</tr>
<tr>
<td>-Xmn10M</td>
<td>限制Java堆的新生代大小为10M</td>
</tr>
<tr>
<td>-XX:SurvivorRatio=8</td>
<td>新生代中Eden区与一个Survivor区的空间比例是8:1</td>
</tr>
</tbody>
</table>
<h2 id="JVM-类加载"><a href="#JVM-类加载" class="headerlink" title="JVM 类加载"></a>JVM 类加载</h2><blockquote>
<p>类从被加载到虚拟机内存中开始, 到卸载出内存位置, 它的整个生命周期包括: 加载(Loading) 、验证 (Verification) 、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)、卸载(Unloading). 其中验证、准备、解析3个部分统称为连接(Linking)</p>
</blockquote>
<p><img src="/img/java/jvm_class_lifecycle.jpg" alt="类的生命周期"></p>
<h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><ol>
<li>通过一个类的全限定名来获取定义此类的二进制流, 来源可以是: class文件/zip包/网络/运行时计算生成(动态代理)/由其他文件生成(JSP)/从数据库中读取</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象,作为方法区这个类的各种数据的访问入口</li>
<li>加载阶段和连接阶段的部分内容是交叉进行的, 但是两个阶段的开始时间仍然保持固定的先后顺序</li>
</ol>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><ol>
<li>确保Class文件的字节流中包含的信息符合当前虚拟机的要求, 并且不会危害虚拟机自身的安全</li>
<li>大致分为4个阶段的检验动作: <strong>文件格式验证</strong>(文件格式规范)/ <strong>元数据验证</strong>(语义分析,数据类型分析)/ <strong>字节码验证</strong>(数据流/控制流分析,方法体校验分析)/  <strong>符号引用验证</strong>(访问性分析)</li>
</ol>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><ol>
<li>正式为类变量(static 变量)分配内存, 并设置类变量初始值, 在方法区中分配</li>
<li>通常情况下初始值是零值, 除非是<code>final</code>类型常量</li>
</ol>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><ol>
<li>将常量池内的符号引用替换为直接引用</li>
</ol>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><ol>
<li>真正开始执行类中定义的Java 程序代码(字节码)</li>
<li>父类初始化方法先执行完毕, 再开始执行子类的初始化方法</li>
<li>同一个类加载器下, 一个类型只会初始化一次</li>
</ol>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><blockquote>
<p>从Java 虚拟机角度, 只有两种不同的类加载器: 启动类加载器(Bootstrap ClassLoader)和其他类加载器(Other ClassLoader)</p>
<p>从Java开发人员角度, 类加载器有三类: 启动类加载器(Bootstrap ClassLoader) / 扩展类加载器(Extension ClassLoader) / 应用程序类加载器(Application ClassLoader)</p>
</blockquote>
<ol>
<li>类加载器的关系模型一般为双亲委派模型 (Parents Delegation Model)</li>
<li>除了顶层的启动类加载器外, 其余的加载器都应有自己的父类加载器</li>
<li>类加载器之间的关系一般是<strong>组合(Composition)</strong>而不是继承(Inheritance)</li>
<li>工作过程: 如果一个类加载器收到了类加载请求, 它首先不会自己去尝试加载这个类, 而是把这个请求委派给父类加载器去完成, 每一层加载器都是如此, 只有当父加载器反馈自己无法完成(它的搜索范围内未找到所需的类)这个加载请求时, 子加载器才会尝试自己去加载</li>
<li>保证Java程序的稳定运行, 避免重复加载</li>
</ol>
<p><img src="/img/java/jvm_pdm.jpg" alt="双亲委派模型"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li>《深入理解Java虚拟机》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;主要讨论 HotSpot 虚拟机&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Java平台体系&quot;&gt;&lt;a href=&quot;#Java平台体系&quot; class=&quot;headerlink&quot; title=&quot;Java平台体系&quot;&gt;&lt;/a&gt;Java平台体系&lt;/h
    
    </summary>
    
      <category term="Java" scheme="https://blog.ajavac.com/categories/Java/"/>
    
    
      <category term="Java" scheme="https://blog.ajavac.com/tags/Java/"/>
    
      <category term="Basic" scheme="https://blog.ajavac.com/tags/Basic/"/>
    
  </entry>
  
  <entry>
    <title>Docker之清理</title>
    <link href="https://blog.ajavac.com/2017/05/31/Docker/docker_cleanup/"/>
    <id>https://blog.ajavac.com/2017/05/31/Docker/docker_cleanup/</id>
    <published>2017-05-31T08:45:53.000Z</published>
    <updated>2017-05-31T08:53:41.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> 清理退出的容器</div><div class="line">docker rm $(docker ps -q -f status=exited)</div><div class="line"></div><div class="line"><span class="meta">#</span> 杀死所有正在运行的容器</div><div class="line">docker kill $(docker ps -a -q)</div><div class="line"></div><div class="line"><span class="meta">#</span> 删除所有已经停止的容器</div><div class="line">docker rm $(docker ps -a -q)</div></pre></td></tr></table></figure>
<h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> 清理虚悬镜像</div><div class="line">docker rmi $(docker images -q -f "dangling=true")</div><div class="line"></div><div class="line"><span class="meta">#</span> 删除所有虚悬镜像</div><div class="line">docker rmi $(docker images -q -f dangling=true)</div><div class="line"></div><div class="line"><span class="meta">#</span> 删除所有镜像</div><div class="line">docker rmi $(docker images -q)</div></pre></td></tr></table></figure>
<h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> 列出虚悬数据卷</div><div class="line">docker volume ls -qf dangling=true</div><div class="line"><span class="meta">#</span> 删除虚悬数据卷</div><div class="line">docker volume rm $(docker volume ls -qf dangling=true)</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;容器&quot;&gt;&lt;a href=&quot;#容器&quot; class=&quot;headerlink&quot; title=&quot;容器&quot;&gt;&lt;/a&gt;容器&lt;/h2&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div c
    
    </summary>
    
      <category term="Docker" scheme="https://blog.ajavac.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://blog.ajavac.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>利用Docker搭建开发环境</title>
    <link href="https://blog.ajavac.com/2017/05/31/Docker/docker_dev/"/>
    <id>https://blog.ajavac.com/2017/05/31/Docker/docker_dev/</id>
    <published>2017-05-31T08:40:53.000Z</published>
    <updated>2017-07-27T02:42:25.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><p><a href="https://www.docker.com/community-edition#/download" target="_blank" rel="external">Docker官网</a></p>
<h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><blockquote>
<p><a href="https://hub.docker.com/_/mysql/" target="_blank" rel="external">官方Repository</a></p>
</blockquote>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p><code>docker run --name some-mysql -p 3306:3306 -v ~/my_data/mysql:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=admin -d mysql --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci</code></p>
<p>说明：</p>
<ol>
<li><code>some-mysql</code> 是自定义的容器名称</li>
<li><code>-p 3306:3306</code> 是端口映射配置</li>
<li><code>~/my_data/mysql</code> 代表存储mysql的配置以及数据的目录</li>
</ol>
<h3 id="连接测试"><a href="#连接测试" class="headerlink" title="连接测试"></a>连接测试</h3><p><code>docker run -it --link some-mysql:mysql --rm mysql sh -c &#39;exec mysql -h&quot;$MYSQL_PORT_3306_TCP_ADDR&quot; -P&quot;$MYSQL_PORT_3306_TCP_PORT&quot; -uroot -p&quot;$MYSQL_ENV_MYSQL_ROOT_PASSWORD&quot;&#39;</code></p>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><blockquote>
<p><a href="https://hub.docker.com/_/redis/" target="_blank" rel="external">官方Repository</a></p>
</blockquote>
<h3 id="运行-1"><a href="#运行-1" class="headerlink" title="运行"></a>运行</h3><p><code>docker run --name some-redis -d -p 6379:6379 redis:alpine redis-server</code></p>
<p>说明：</p>
<ol>
<li><code>some-redis</code> 是自定义的容器名称</li>
<li><code>-p 6379:6379</code> 是端口映射配置</li>
</ol>
<h3 id="连接测试-1"><a href="#连接测试-1" class="headerlink" title="连接测试"></a>连接测试</h3><p><code>docker run -it --link some-redis:redis --rm redis:alpine redis-cli -h redis -p 6379</code></p>
<h2 id="Mongo"><a href="#Mongo" class="headerlink" title="Mongo"></a>Mongo</h2><blockquote>
<p><a href="https://hub.docker.com/_/mongo/" target="_blank" rel="external">官方Repository</a></p>
</blockquote>
<h3 id="运行-2"><a href="#运行-2" class="headerlink" title="运行"></a>运行</h3><p><code>docker run --name some-mongo -v ~/my_data/mongo:/data/db -d -p 27017:27017 mongo</code></p>
<p>说明：</p>
<ol>
<li><code>some-mongo</code> 是自定义的容器名称</li>
<li><code>-p 27017:27017</code> 是端口映射配置</li>
<li><code>~/my_data/mongo</code> 代表存储mongo的配置以及数据的目录</li>
</ol>
<h3 id="连接测试-2"><a href="#连接测试-2" class="headerlink" title="连接测试"></a>连接测试</h3><p><code>docker run -it --link some-mongo:mongo --rm mongo sh -c &#39;exec mongo &quot;$MONGO_PORT_27017_TCP_ADDR:$MONGO_PORT_27017_TCP_PORT/test&quot;&#39;</code></p>
<h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><blockquote>
<p><a href="https://hub.docker.com/_/nginx/" target="_blank" rel="external">官方Repository</a></p>
</blockquote>
<h3 id="运行-3"><a href="#运行-3" class="headerlink" title="运行"></a>运行</h3><p><code>docker run --name some-nginx -v ~/my_data/nginx:/usr/share/nginx/html:ro -d -p 8080:80 nginx:alpine</code></p>
<p>说明：</p>
<ol>
<li><code>some-nginx</code> 是自定义的容器名称</li>
<li><code>-p 8080:80</code> 是端口映射配置</li>
<li><code>~/my_data/nginx</code> 代表存储nginx静态文件的目录</li>
</ol>
<h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><blockquote>
<p><a href="https://hub.docker.com/_/java/" target="_blank" rel="external">官方Repository</a></p>
</blockquote>
<h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><blockquote>
<p><a href="https://hub.docker.com/_/node/" target="_blank" rel="external">官方Repository</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;安装Docker&quot;&gt;&lt;a href=&quot;#安装Docker&quot; class=&quot;headerlink&quot; title=&quot;安装Docker&quot;&gt;&lt;/a&gt;安装Docker&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.docker.com/community-edit
    
    </summary>
    
      <category term="Docker" scheme="https://blog.ajavac.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://blog.ajavac.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker之容器</title>
    <link href="https://blog.ajavac.com/2017/05/31/Docker/docker_container/"/>
    <id>https://blog.ajavac.com/2017/05/31/Docker/docker_container/</id>
    <published>2017-05-31T08:35:53.000Z</published>
    <updated>2017-05-31T08:53:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><h3 id="新建并启动"><a href="#新建并启动" class="headerlink" title="新建并启动"></a>新建并启动</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> -t 分配伪终端并绑定到容器标准输出 -i 让容器标准输入打开</div><div class="line"><span class="meta">#</span> docker run 创建容器</div><div class="line">sudo docker run -t -i ubuntu:14.04 /bin/bash</div><div class="line">pwd</div><div class="line">ls</div></pre></td></tr></table></figure>
<ol>
<li>若本地不存在镜像会自动下载</li>
<li>利用镜像创建并启动容器</li>
<li>分配一个文件系统,并在只读镜像层外挂载一层读写层</li>
<li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li>
<li>从地址池配置一个 ip 地址给容器</li>
<li>执行用户指定的应用程序</li>
<li>执行完毕后容器被终止</li>
</ol>
<h3 id="启动已终止的容器"><a href="#启动已终止的容器" class="headerlink" title="启动已终止的容器"></a>启动已终止的容器</h3><p><code>docker start &lt;容器标识&gt;</code></p>
<h2 id="守护态运行"><a href="#守护态运行" class="headerlink" title="守护态运行"></a>守护态运行</h2><p>通常通过参数<code>-d</code>实现</p>
<p>要获取容器的输出信息，可以通过 <code>docker logs</code> 命令</p>
<h2 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h2><ol>
<li><p><code>docker stop &lt;容器标识&gt;</code>来终止守护态运行中的容器</p>
</li>
<li><p><code>exit</code>或<code>Ctrl+d</code>来退出终端容器</p>
</li>
<li><p>终止状态的容器可以用 <code>docker ps -a</code> 命令看到</p>
</li>
<li><p>处于终止状态的容器，可以通过 <code>docker start &lt;容器标识&gt;</code> 命令来重新启动</p>
</li>
<li><p><code>docker restart &lt;容器标识&gt;</code> 命令会将一个运行态的容器终止，然后再重新启动它</p>
<p>​</p>
</li>
</ol>
<h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><p>进入守护态运行中的容器</p>
<h3 id="attach命令"><a href="#attach命令" class="headerlink" title="attach命令"></a><code>attach</code>命令</h3><p><code>docker attach  &lt;容器标识&gt;</code></p>
<p>当多个窗口同时 <code>attach</code> 到同一个容器的时候，所有窗口都会同步显示</p>
<h3 id="nsenter命令"><a href="#nsenter命令" class="headerlink" title="nsenter命令"></a><code>nsenter</code>命令</h3><p><a href="https://yeasy.gitbooks.io/docker_practice/content/container/enter.html" target="_blank" rel="external">方法步骤</a></p>
<h2 id="导出和导入"><a href="#导出和导入" class="headerlink" title="导出和导入"></a>导出和导入</h2><h3 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h3><p><code>docker export 7691a814370e &gt; ubuntu.tar</code></p>
<h3 id="导入容器"><a href="#导入容器" class="headerlink" title="导入容器"></a>导入容器</h3><p><code>cat ubuntu.tar | sudo docker import - test/ubuntu:v1.0</code></p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><ol>
<li>删除终止状态容器<code>docker rm  &lt;容器标识&gt;</code></li>
<li>强制删除运行中的容器<code>docker rm -f &lt;容器标识&gt;</code></li>
<li>清理所有处于终止状态的容器<code>docker rm $(docker ps -a -q)</code></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;启动&quot;&gt;&lt;a href=&quot;#启动&quot; class=&quot;headerlink&quot; title=&quot;启动&quot;&gt;&lt;/a&gt;启动&lt;/h2&gt;&lt;h3 id=&quot;新建并启动&quot;&gt;&lt;a href=&quot;#新建并启动&quot; class=&quot;headerlink&quot; title=&quot;新建并启动&quot;&gt;&lt;/a&gt;新建并启
    
    </summary>
    
      <category term="Docker" scheme="https://blog.ajavac.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://blog.ajavac.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker之镜像</title>
    <link href="https://blog.ajavac.com/2017/05/31/Docker/docker_image/"/>
    <id>https://blog.ajavac.com/2017/05/31/Docker/docker_image/</id>
    <published>2017-05-31T08:30:53.000Z</published>
    <updated>2017-05-31T08:53:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>从官方Docker Hub获取ubuntu:14.04</div><div class="line">docker pull ubuntu:14.04</div><div class="line"><span class="meta">#</span>运行</div><div class="line">docker run -it --rm ubuntu:14.04 bash</div><div class="line">cat /etc/os-release</div><div class="line">exit</div></pre></td></tr></table></figure>
<p><code>docker run</code>: 就是运行容器的命令</p>
<p><code>-it</code>：这是两个参数， <code>-i</code>交互式操作， <code>-t</code> 终端</p>
<p><code>—rm</code>：这个参数是说容器退出后随之将其删除</p>
<p><code>ubuntu:14.04</code>：这是指用 ubuntu:14.04 镜像为基础来启动容器</p>
<p><code>bash</code>：放在镜像名后的是命令</p>
<p><code>cat /etc/os-release</code>:这是 Linux 常用的查看当前系统版本的命令</p>
<p><code>exit</code> :退出了这个容器</p>
<h2 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>列出当前镜像</div><div class="line">docker images</div><div class="line"><span class="meta">#</span>仓库名和标签都为&lt;none&gt;的是虚悬镜像,列出虚悬镜像</div><div class="line">docker images -f dangling=true</div><div class="line"><span class="meta">#</span>删除虚悬镜像</div><div class="line">docker rmi $(docker images -q -f dangling=true)</div><div class="line"><span class="meta">#</span>列出所有镜像,可能包括库名和标签都为&lt;none&gt;的中间层镜像</div><div class="line">docker images -a</div><div class="line"><span class="meta">#</span>列出部分镜像,比如ubuntu</div><div class="line">docker images ubuntu</div><div class="line"><span class="meta">#</span>过滤镜像</div><div class="line">docker images -f since=mongo:3.2</div><div class="line">docker images -f before=mongo:3.2</div><div class="line">docker images -f label=com.example.version=0.1</div><div class="line"><span class="meta">#</span>以特定格式列出镜像</div><div class="line">docker images -q</div><div class="line">docker images --format "&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;"</div><div class="line">docker images --format "table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Repository&#125;&#125;\t&#123;&#123;.Tag&#125;&#125;"</div></pre></td></tr></table></figure>
<h2 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>运行一个镜像</div><div class="line">docker run --name webserver -d -p 80:80 nginx</div><div class="line"><span class="meta">#</span>进入容器命令行交互界面,并做修改</div><div class="line">docker exec -it webserver bash</div><div class="line">echo '&lt;h1&gt;Hello, Docker!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html</div><div class="line">exit</div><div class="line"><span class="meta">#</span>查看修改</div><div class="line">docker diff webserver</div><div class="line"><span class="meta">#</span>将容器保存为镜像</div><div class="line">docker commit \</div><div class="line">    --author "test &lt;test@gmail.com&gt;" \</div><div class="line">    --message "修改了默认网页" \</div><div class="line">    webserver \</div><div class="line">    nginx:v2</div><div class="line"><span class="meta">#</span>查看镜像</div><div class="line">docker images nginx</div><div class="line"><span class="meta">#</span>查看镜像内的历史记录</div><div class="line">docker history nginx:v2</div><div class="line"><span class="meta">#</span>运行新的镜像</div><div class="line">docker run --name web2 -d -p 81:80 nginx:v2</div></pre></td></tr></table></figure>
<h3 id="慎用-docker-commit"><a href="#慎用-docker-commit" class="headerlink" title="慎用 docker commit"></a>慎用 docker commit</h3><ol>
<li>若清理不当会导致镜像臃肿</li>
<li>操作为黑箱操作，生成的是黑箱镜像</li>
<li>每次commit都在当前层操作，可能导致镜像臃肿</li>
<li>一般在学习和被入侵后保存现场时用</li>
<li>定制镜像用Dockerfile</li>
</ol>
<h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><blockquote>
<p>Dockerfile 是一个文本文件，其内包含了一条条的<strong>指令(Instruction)</strong>，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p>
</blockquote>
<h3 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># FROM 指定基础镜像必须放在第一个,其中scratch为是一个空镜像</span></div><div class="line"><span class="keyword">FROM</span> nginx</div><div class="line"><span class="comment"># RUN 就像直接在命令行中输入的命令一样  </span></div><div class="line"><span class="comment"># shell 格式：RUN &lt;命令&gt;</span></div><div class="line"><span class="comment"># exec 格式：RUN ["可执行文件", "参数1", "参数2"]</span></div><div class="line"><span class="keyword">RUN</span> echo '&lt;h1&gt;Hello, Docker!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html</div><div class="line"># 使用 &amp;&amp; 将各个所需命令串联起来。简化为 1 层,并进行了清理操作</div><div class="line">RUN buildDeps='gcc libc6-dev make' \</div><div class="line">    &amp;&amp; apt-get update \</div><div class="line">    &amp;&amp; apt-get install -y $buildDeps \</div><div class="line">    &amp;&amp; wget -O redis.tar.gz "http://download.redis.io/releases/redis-3.2.5.tar.gz" \</div><div class="line">    &amp;&amp; mkdir -p /usr/src/redis \</div><div class="line">    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \</div><div class="line">    &amp;&amp; make -C /usr/src/redis \</div><div class="line">    &amp;&amp; make -C /usr/src/redis install \</div><div class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/* \</div><div class="line">    &amp;&amp; rm redis.tar.gz \</div><div class="line">    &amp;&amp; rm -r /usr/src/redis \</div><div class="line">    &amp;&amp; apt-get purge -y --auto-remove $buildDeps</div></pre></td></tr></table></figure>
<h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> 方式1.在Dockerfile文件所在目录执行命令 格式如:docker build [选项] &lt;上下文路径/URL/-&gt; </div><div class="line"><span class="meta">#</span> 涉及了上下文的概念以及Docker的C/S设计</div><div class="line">docker build -t nginx:v3 .</div><div class="line"><span class="meta">#</span> 方式2.直接用 Git repo 进行构建</div><div class="line">docker build https://github.com/twang2218/gitlab-ce-zh.git#:8.14</div><div class="line"><span class="meta">#</span> 方式3.用给定的 tar 压缩包构建</div><div class="line">docker build http://server/context.tar.gz</div><div class="line"><span class="meta">#</span> 方式4.从标准输入中读取 Dockerfile 进行构建,它没有上下文,所以不能copy本地文件</div><div class="line">docker build - &lt; Dockerfile # 或者cat Dockerfile | docker build -</div><div class="line"><span class="meta">#</span>方式5.从标准输入中读取上下文压缩包进行构建,并将压缩包内容作为上下文</div><div class="line">docker build - &lt; context.tar.gz</div></pre></td></tr></table></figure>
<h2 id="Dockerfile指令"><a href="#Dockerfile指令" class="headerlink" title="Dockerfile指令"></a>Dockerfile指令</h2><h3 id="COPY-复制文件"><a href="#COPY-复制文件" class="headerlink" title="COPY 复制文件"></a>COPY 复制文件</h3><ol>
<li><code>COPY package.json /usr/src/app/</code></li>
<li>从上下文目录中复制,可以是通配符</li>
<li><code>目标路径</code>可以是容器内的绝对路径，也可以是相对于工作目录的相对路径，不存在会自动生成</li>
<li>源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。</li>
</ol>
<h3 id="ADD-更高级的复制文件"><a href="#ADD-更高级的复制文件" class="headerlink" title="ADD 更高级的复制文件"></a>ADD 更高级的复制文件</h3><ol>
<li><code>ADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz /</code></li>
<li>若源文件为压缩文件，将会自动解压缩这个压缩文件到<code>目标路径</code>去</li>
<li>所有的文件复制均使用 <code>COPY</code> 指令，仅在需要自动解压缩的场合使用 <code>ADD</code></li>
</ol>
<h3 id="CMD-容器启动命令"><a href="#CMD-容器启动命令" class="headerlink" title="CMD 容器启动命令"></a>CMD 容器启动命令</h3><ol>
<li><code>CMD echo $HOME</code> 相当于 <code>CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ]</code></li>
<li>容器中的应用都应该以前台执行，容器内没有后台服务的概念</li>
<li><code>CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]</code> 以前台形式运行nginx</li>
</ol>
<h3 id="ENTRYPOINT-入口点"><a href="#ENTRYPOINT-入口点" class="headerlink" title="ENTRYPOINT 入口点"></a>ENTRYPOINT 入口点</h3><ol>
<li><code>ENTRYPOINT</code> 的目的和 <code>CMD</code> 一样，都是在指定容器<strong>启动程序</strong>及参数</li>
<li>当指定了 <code>ENTRYPOINT</code> 后，<code>CMD</code>不再是直接的运行其命令，而是将 <code>CMD</code> 的内容作为参数传给 <code>ENTRYPOINT</code> 指令，实际执行时<code>&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;</code></li>
<li>通过 <code>docker run</code> 的参数 <code>—entrypoint</code> 可以指定别的入口点</li>
<li>可以让镜像变成像命令一样使用，<code>docker run</code>可以直接加上参数运行</li>
<li>应用运行前的准备工作，启动容器就是启动主进程，但有些时候，启动主进程前，需要一些准备工作</li>
</ol>
<h3 id="ENV-设置环境变量"><a href="#ENV-设置环境变量" class="headerlink" title="ENV 设置环境变量"></a>ENV 设置环境变量</h3><blockquote>
<p>通过环境变量，我们可以让一份 Dockerfile 制作更多的镜像，只需使用不同的环境变量即可。</p>
</blockquote>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 方式1</span></div><div class="line"><span class="keyword">ENV</span> VERSION <span class="number">1.0</span></div><div class="line"><span class="comment"># 方式2</span></div><div class="line"><span class="keyword">ENV</span> VERSION=<span class="number">1.0</span> DEBUG=on \</div><div class="line">    NAME=<span class="string">"Happy Feet"</span></div></pre></td></tr></table></figure>
<p>可以使用<code>$VERSION</code>这种形式来获取环境变量值</p>
<h3 id="ARG-构建参数"><a href="#ARG-构建参数" class="headerlink" title="ARG 构建参数"></a>ARG 构建参数</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 方式1</span></div><div class="line"><span class="keyword">ARG</span> VERSION <span class="number">1.0</span></div><div class="line"><span class="comment"># 方式2</span></div><div class="line"><span class="keyword">ARG</span> VERSION=<span class="number">1.0</span> DEBUG=on \</div><div class="line">    NAME=<span class="string">"Happy Feet"</span></div></pre></td></tr></table></figure>
<ol>
<li>效果同<code>ENV</code> 但是只在构建时有效</li>
<li><code>docker history</code> 可以看到所有值</li>
<li><code>docker build</code> 中可以用 <code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code> 来覆盖</li>
</ol>
<h3 id="VOLUME-定义匿名卷"><a href="#VOLUME-定义匿名卷" class="headerlink" title="VOLUME 定义匿名卷"></a>VOLUME 定义匿名卷</h3><ol>
<li><code>VOLUME /data</code> 或者 <code>VOLUME [&quot;/data&quot;,&quot;/test&quot;]</code></li>
<li>挂在卷用以保存动态数据</li>
<li>运行时可以覆盖这个挂载设置<code>docker run -d -v mydata:/data xxxx</code></li>
</ol>
<h3 id="EXPOSE-声明端口"><a href="#EXPOSE-声明端口" class="headerlink" title="EXPOSE 声明端口"></a>EXPOSE 声明端口</h3><ol>
<li><code>EXPOSE 8080</code>或者<code>EXPOSE [&quot;80&quot;,&quot;8080&quot;]</code></li>
<li>仅仅是声明运行时容器提供服务端口，并不会自动在宿主进行端口映射</li>
<li><code>docker run -P</code> 时，会自动随机映射 <code>EXPOSE</code> 的端口</li>
</ol>
<h3 id="WORKDIR-指定工作目录"><a href="#WORKDIR-指定工作目录" class="headerlink" title="WORKDIR 指定工作目录"></a>WORKDIR 指定工作目录</h3><ol>
<li><code>WORKDIR /app</code></li>
<li>指定工作目录（或者称为当前目录），改变环境状态并影响以后的层</li>
<li>该目录需要已经存在，<code>WORKDIR</code> 并不会建立目录</li>
<li>如果需要改变以后各层的工作目录的位置，那么应该使用 <code>WORKDIR</code> 指令</li>
</ol>
<h3 id="USER-指定当前用户"><a href="#USER-指定当前用户" class="headerlink" title="USER 指定当前用户"></a>USER 指定当前用户</h3><ol>
<li><code>USER redis</code></li>
<li>指定当前用户，改变环境状态并影响以后的层</li>
<li>用户必须是事先建立好的，否则无法切换</li>
</ol>
<h3 id="HEALTHCHECK-健康检查"><a href="#HEALTHCHECK-健康检查" class="headerlink" title="HEALTHCHECK 健康检查"></a>HEALTHCHECK 健康检查</h3><blockquote>
<p>Docker 1.12 后引入</p>
</blockquote>
<p>HEALTHCHECK 支持下列选项：</p>
<ul>
<li><code>--interval=&lt;间隔&gt;</code>：两次健康检查的间隔，默认为 30 秒；</li>
<li><code>--timeout=&lt;时长&gt;</code>：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒；</li>
<li><code>--retries=&lt;次数&gt;</code>：当连续失败指定次数后，则将容器状态视为 unhealthy，默认 3 次。</li>
</ul>
<p>命令的返回值决定了该次健康检查的成功与否：0：成功；1：失败；</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令</span></div><div class="line"><span class="keyword">HEALTHCHECK</span> NONE</div><div class="line">#每 5 秒检查一次，如果健康检查命令超过 3 秒没响应就视为失败，并且使用 curl -fs http://localhost/ || exit 1 作为健康检查命令。</div><div class="line">HEALTHCHECK --interval=5s --timeout=3s \</div><div class="line">  CMD curl -fs http://localhost/ || exit 1</div></pre></td></tr></table></figure>
<h3 id="ONBUILD-为他人做嫁衣裳"><a href="#ONBUILD-为他人做嫁衣裳" class="headerlink" title="ONBUILD 为他人做嫁衣裳"></a>ONBUILD 为他人做嫁衣裳</h3><ol>
<li><code>ONBUILD &lt;其它指令&gt;</code></li>
<li>只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行</li>
</ol>
<h2 id="其他方式"><a href="#其他方式" class="headerlink" title="其他方式"></a>其他方式</h2><h3 id="从rootfs压缩包导入"><a href="#从rootfs压缩包导入" class="headerlink" title="从rootfs压缩包导入"></a>从rootfs压缩包导入</h3><p>格式:<code>docker import [选项] &lt;文件&gt;|&lt;URL&gt;|- [&lt;仓库名&gt;[:&lt;标签&gt;]]</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>创建一个OpenVZ的ubuntu14.04的镜像</div><div class="line">docker import \</div><div class="line">    http://download.openvz.org/template/precreated/ubuntu-14.04-x86_64-minimal.tar.gz \</div><div class="line">    openvz/ubuntu:14.04</div></pre></td></tr></table></figure>
<h3 id="docker-save和docker-load"><a href="#docker-save和docker-load" class="headerlink" title="docker save和docker load"></a><code>docker save</code>和<code>docker load</code></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> 保存镜像</div><div class="line">docker save alpine | gzip &gt; alpine-latest.tar.gz</div><div class="line"></div><div class="line"><span class="meta">#</span> 导入镜像</div><div class="line">docker load -i alpine-latest.tar.gz</div><div class="line"></div><div class="line"><span class="meta">#</span> 从一个机器将镜像迁移到另一个机器，并且带进度条的功能</div><div class="line">docker save &lt;镜像名&gt; | bzip2 | pv | ssh &lt;用户名&gt;@&lt;主机名&gt; 'cat | docker load'</div></pre></td></tr></table></figure>
<h2 id="删除本地镜像"><a href="#删除本地镜像" class="headerlink" title="删除本地镜像"></a>删除本地镜像</h2><p>格式:<code>docker rmi [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</code></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://yeasy.gitbooks.io/docker_practice/content/" target="_blank" rel="external">Docker — 从入门到实践</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;获取镜像&quot;&gt;&lt;a href=&quot;#获取镜像&quot; class=&quot;headerlink&quot; title=&quot;获取镜像&quot;&gt;&lt;/a&gt;获取镜像&lt;/h2&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
    
    </summary>
    
      <category term="Docker" scheme="https://blog.ajavac.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://blog.ajavac.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>初识Docker</title>
    <link href="https://blog.ajavac.com/2017/05/31/Docker/docker_info/"/>
    <id>https://blog.ajavac.com/2017/05/31/Docker/docker_info/</id>
    <published>2017-05-31T08:27:53.000Z</published>
    <updated>2017-05-31T08:57:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="docker-是什么？"><a href="#docker-是什么？" class="headerlink" title="docker 是什么？"></a>docker 是什么？</h2><blockquote>
<p>Docker是一个开放源代码软件项目，让应用程序布署在软件容器下的工作可以自动化进行，借此在Linux操作系统上，提供一个额外的软件抽象层，以及操作系统层虚拟化的自动管理机制。Docker利用Linux核心中的资源分离机制，例如cgroups，以及Linux核心命名空间（name space），来建立独立的软件容器（containers）。这可以在单一Linux实体下运作，避免启动一个虚拟机器造成的额外负担。</p>
<p>——摘自维基百科</p>
</blockquote>
<h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机:"></a>虚拟机:</h3><p><img src="/img/docker/VM.png" alt="vm"></p>
<h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker:"></a>Docker:</h3><p><img src="/img/docker/Docker.png" alt="docker"></p>
<blockquote>
<p>——图片来自www.docker.com</p>
</blockquote>
<h2 id="docker-跟原有的工具有何区别？"><a href="#docker-跟原有的工具有何区别？" class="headerlink" title="docker 跟原有的工具有何区别？"></a>docker 跟原有的工具有何区别？</h2><blockquote>
<p>实现更轻量级的虚拟化，方便快速部署</p>
</blockquote>
<ol>
<li>docker技术使软件交付标准化</li>
<li>像集装箱一样生成镜像，使得开发环境与生产环境一致</li>
<li>docker的出现使得[一次构建，到处部署]成为了可能</li>
<li>统一的管理服务</li>
<li>持续交付应用</li>
<li>快速(秒级)启动</li>
</ol>
<ul>
<li>传统的部署模式是：安装(包管理工具或者源码包编译)-&gt;配置-&gt;运行；</li>
<li>Docker的部署模式是：复制-&gt;运行。</li>
</ul>
<h2 id="docker-会对服务器端开发-部署带来什么变化？"><a href="#docker-会对服务器端开发-部署带来什么变化？" class="headerlink" title="docker 会对服务器端开发/部署带来什么变化？"></a>docker 会对服务器端开发/部署带来什么变化？</h2><ol>
<li>对开发的影响不大</li>
<li>对于部署来说，是场革命。极大的减少部署的时间成本和人力成本</li>
</ol>
<h2 id="诱人之处"><a href="#诱人之处" class="headerlink" title="诱人之处"></a>诱人之处</h2><ul>
<li>资源独立/隔离</li>
<li>环境一致性</li>
<li>轻量化</li>
<li>Build Once, Run Everywhere </li>
</ul>
<h2 id="Linux系统要求"><a href="#Linux系统要求" class="headerlink" title="Linux系统要求"></a>Linux系统要求</h2><ol>
<li>64位操作系统</li>
<li>Linux内核大于等于3.10</li>
</ol>
<p>推荐操作系统(全部为64位Linux操作系统):</p>
<ol>
<li>Ubuntu 16.10</li>
<li>Ubuntu 16.04</li>
<li>Ubuntu 14.04</li>
<li>RHEL 7</li>
<li>CentOS 7</li>
<li>Fedora 24</li>
<li>Fedora 25</li>
<li>Debian 7.7</li>
<li>Debian 8.0</li>
</ol>
<h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><p><a href="http://dockone.io/article/126" target="_blank" rel="external">docker八个应用场景</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;docker-是什么？&quot;&gt;&lt;a href=&quot;#docker-是什么？&quot; class=&quot;headerlink&quot; title=&quot;docker 是什么？&quot;&gt;&lt;/a&gt;docker 是什么？&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Docker是一个开放源代码软件项目，让应
    
    </summary>
    
      <category term="Docker" scheme="https://blog.ajavac.com/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://blog.ajavac.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Linux 基础</title>
    <link href="https://blog.ajavac.com/2017/04/10/Linux/linux_basic/"/>
    <id>https://blog.ajavac.com/2017/04/10/Linux/linux_basic/</id>
    <published>2017-04-10T01:19:17.000Z</published>
    <updated>2017-08-03T01:18:35.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="包管理器"><a href="#包管理器" class="headerlink" title="包管理器"></a>包管理器</h2><h3 id="apt-get"><a href="#apt-get" class="headerlink" title="apt-get"></a>apt-get</h3><blockquote>
<p>apt-get 是Debian/Ubuntu等Debian系列系统自带的包管理工具</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> 命令:</div><div class="line">update - 检索 新的包列表</div><div class="line">upgrade - 升级 可更新的所有软件包</div><div class="line">install - 安装 新软件包（pkg是libc6不是libc6.deb）</div><div class="line">remove - 删除 软件包</div><div class="line">autoremove - 自动删除 所有未使用的软件包</div><div class="line">purge - 删除 软件包和配置文件</div><div class="line">clean - 清除 已下载的归档文件</div><div class="line">autoclean - 清除 旧的下载的档案文件</div><div class="line">check - 验证 是否有损坏的依赖</div><div class="line">download - 下载 二进制包到当前目录</div><div class="line"> </div><div class="line"><span class="meta">#</span> 选项：</div><div class="line">-q ：不输出任何信息</div><div class="line">-qq ：除了错误之外，没有输出</div><div class="line">-d ：仅下载，不要安装或解压缩存档</div><div class="line">-y ：对所有确定询问都选择 Yes，并且不提示</div><div class="line">-f ：尝试纠正 被破坏依赖关系的系统</div><div class="line">-m ：如果存档是可定位的，则尝试继续</div><div class="line">-u ：显示升级包的列表</div><div class="line">-b ：在获取源代码包后构建源包</div><div class="line"> </div><div class="line"><span class="meta">#</span> 更多的命令可以用 apt-get --help 查看。</div><div class="line"></div><div class="line"><span class="meta">#</span> 示例</div><div class="line"><span class="meta">#</span> 检索 新的包列表</div><div class="line">apt-get update</div><div class="line"> </div><div class="line"><span class="meta">#</span> 升级 可更新的所有软件包（注意这个命令会升级所有的软件包，所以会升级很长时间）</div><div class="line">apt-get upgrade</div><div class="line"> </div><div class="line"><span class="meta">#</span> 安装 Nginx 软件包</div><div class="line">apt-get install nginx</div><div class="line"> </div><div class="line"><span class="meta">#</span> 卸载 Nginx 软件包</div><div class="line">apt-get remove nginx</div><div class="line"> </div><div class="line"><span class="meta">#</span> 卸载 Nginx 软件包 并删除所有相关配置文件</div><div class="line">apt-get remove --purge nginx</div><div class="line"> </div><div class="line"><span class="meta">#</span> 在安装软件和卸载的时候，为了避免误操作，都会询问是否继续，每次都要输入 y 来确定会很麻烦，可以加上 -y 参数</div><div class="line"><span class="meta">#</span> 安装 Nginx 软件包 并不显示确定提示</div><div class="line">apt-get install nginx -y</div><div class="line"> </div><div class="line"><span class="meta">#</span> 卸载 Nginx 软件包，删除所有相关配置文件 并不显示提示</div><div class="line">apt-get remove --purge nginx -y</div><div class="line"> </div><div class="line"><span class="meta">#</span> 清除 旧的/无用 的软件包</div><div class="line">apt-get clean &amp;&amp; apt-get autoclean</div><div class="line"> </div><div class="line"><span class="meta">#</span> 下载 Nginx 二进制软件包到当前目录，但不解压和安装</div><div class="line">apt-get download nginx -d</div></pre></td></tr></table></figure>
<h3 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h3><blockquote>
<p>yum 是 CentOS等REHAL系列系统自带的包管理工具</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> 命令：</div><div class="line"> </div><div class="line">update - 检索 新的包列表</div><div class="line">upgrade - 升级 软件包</div><div class="line">search - 搜索 软件包</div><div class="line">install - 安装 软件包</div><div class="line">list - 列出 软件包或者软件包组</div><div class="line">info - 显示软件包或者软件包组的详细信息</div><div class="line">erase - 删除 软件包（这两个命令一样）</div><div class="line">remove - 删除 软件包（这两个命令一样）</div><div class="line">groupinfo - 显示 有关包组的详细信息</div><div class="line">groupinstall - 安装 软件包组（就像一种软件合集）</div><div class="line">grouplist - 列出 可用的软件包组</div><div class="line">groupremove - 删除 软件包组</div><div class="line">check - 检查 软件包</div><div class="line">check-update - 检查 可更新的软件包</div><div class="line">clean - 清除 缓存目录内的软件包</div><div class="line">deplist - 列出 一个包的依赖关系</div><div class="line">distribution-synchronization - 同步 已安装的软件包到最新的版本</div><div class="line">downgrad - 降级 一个软件包</div><div class="line">reinstall - 重新安装 软件包（自动删除重装）</div><div class="line">repolist - 显示 配置的软件包仓库</div><div class="line">resolvedep - 确定 软件包需要的依赖关系</div><div class="line"> </div><div class="line"><span class="meta">#</span> 选项：</div><div class="line">-t ：容忍错误</div><div class="line">-C ：完全从系统缓存运行，不要更新缓存</div><div class="line">-R 分钟 ：最大命令等待时间</div><div class="line">-q ：安静的操作</div><div class="line">-y ：对于所有问题回答是</div><div class="line">--nogpgcheck ：禁用gpg签名检查</div><div class="line"> </div><div class="line"><span class="meta">#</span> 更多的命令可以用 yum --help 查看。</div><div class="line"></div><div class="line"><span class="meta">#</span> 示例</div><div class="line"><span class="meta">#</span> 检索 新的包列表</div><div class="line">yum update</div><div class="line"> </div><div class="line"><span class="meta">#</span> 安装 Nginx 软件包</div><div class="line">yum install nginx</div><div class="line"> </div><div class="line"><span class="meta">#</span> 安装 Development Tools 软件包组（这个软件包组中包含了编译所需的软件）</div><div class="line"><span class="meta">#</span> 注意：当软件包或者软件包组的名字中包含空格的时候，请把 软件包或软件包组 加上双引号！</div><div class="line">yum groupinstall "Development Tools"</div><div class="line"> </div><div class="line"><span class="meta">#</span> 卸载 Nginx 软件包</div><div class="line">yum erase nginx / yum remove nginx</div><div class="line"> </div><div class="line"><span class="meta">#</span> 卸载 Development Tools 软件包组</div><div class="line">yum groupremove "Development Tools"</div><div class="line"> </div><div class="line"><span class="meta">#</span> 升级 所有可更新的软件包</div><div class="line">yum upgrade</div><div class="line"> </div><div class="line"><span class="meta">#</span> 升级 Nginx 可更新的软件包</div><div class="line">yum upgrade nginx</div><div class="line"> </div><div class="line"><span class="meta">#</span> 在安装软件和卸载的时候，为了避免误操作，都会询问是否继续，每次都要输入 y 来确定会很麻烦，可以加上 -y 参数</div><div class="line"><span class="meta">#</span> 安装 Nginx 软件包 并不显示确定提示</div><div class="line">yum install nginx -y</div><div class="line"> </div><div class="line"><span class="meta">#</span> 卸载 Nginx 软件包 并不显示确定提示</div><div class="line">yum erase nginx -y / yum remove nginx -y</div><div class="line"> </div><div class="line"><span class="meta">#</span> 搜索 Nginx 软件包是否存着</div><div class="line">yum search nginx</div><div class="line"> </div><div class="line"><span class="meta">#</span> 列出 可用的软件包</div><div class="line">yum list</div><div class="line"> </div><div class="line"><span class="meta">#</span> 列出 可用的软件包组</div><div class="line">yum grouplist</div><div class="line"> </div><div class="line"><span class="meta">#</span> 清除 缓存目录中的所有软件包</div><div class="line">yum clean</div><div class="line"> </div><div class="line"><span class="meta">#</span> 清除 缓存目录中的 Nginx 软件包</div><div class="line">yum clean nginx</div><div class="line"> </div><div class="line"><span class="meta">#</span> 重装 Nginx 软件包</div><div class="line">yum reinstall nginx</div></pre></td></tr></table></figure>
<h2 id="文件-文件夹"><a href="#文件-文件夹" class="headerlink" title="文件/文件夹"></a>文件/文件夹</h2><p>默认以当前目录<code>/root</code>为例</p>
<h3 id="mkdir-新建-文件夹"><a href="#mkdir-新建-文件夹" class="headerlink" title="mkdir 新建 文件夹"></a>mkdir 新建 文件夹</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> 在当前文件夹新建一个 bash 文件夹，完整的绝对路径就是 /root/bash</div><div class="line">mkdir bash</div><div class="line"><span class="meta">#</span> 更多的命令可以用 mkdir --help 查看。</div></pre></td></tr></table></figure>
<h3 id="cd-进入文件夹"><a href="#cd-进入文件夹" class="headerlink" title="cd 进入文件夹"></a>cd 进入文件夹</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> 你当前在 /root目录中，使用这个命令会进入 /root/bash目录，这是相对路径</div><div class="line">cd bash</div><div class="line"><span class="meta">#</span> 如果你不在 /root目录中的话，就不能用上面的相对路径了，就需要绝对路径</div><div class="line">cd /root/bash</div><div class="line"></div><div class="line"><span class="meta">#</span> 假设你当前在 /root/bash目录中，使用相对路径，你可以用这个命令进入上一级 /root目录， .. 代表相对路径 上级目录</div><div class="line">cd ..</div><div class="line"><span class="meta">#</span> 当然你也可以用绝对路径来进入上一级 /root目录</div><div class="line">cd /root</div></pre></td></tr></table></figure>
<h3 id="cp-复制或重命名-文件-文件夹"><a href="#cp-复制或重命名-文件-文件夹" class="headerlink" title="cp 复制或重命名 文件/文件夹"></a>cp 复制或重命名 文件/文件夹</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> 复制当前目录内的 log.txt文件到 /var目录</div><div class="line">cp log.txt /var/log.txt</div><div class="line"><span class="meta">#</span> 复制当前目录内的 bash文件夹到 /home目录</div><div class="line">cp -R bash /home/bash</div><div class="line"></div><div class="line"><span class="meta">#</span> 复制当前目录内的所有.txt后缀的文件到 /var/log目录</div><div class="line">cp *.txt /var/log</div><div class="line"><span class="meta">#</span> 复制当前目录内的所有以 doubi开头的文件到 /var/log目录</div><div class="line">cp doubi* /var/log</div><div class="line"><span class="meta">#</span> 复制当前目录内的所有以 doubi开头 以.txt后缀结尾的文件到 /var/log目录</div><div class="line">cp doubi*.txt /var/log</div><div class="line"></div><div class="line"><span class="meta">#</span> 假设当前目录是 /root/doubi/log，要把这个目录中的所有.txt后缀的文件复制到上一级目录 /root/doubi，那么这样做</div><div class="line">cp *.txt ..</div><div class="line"><span class="meta">#</span> .. 就是相对路径，代表上一级目录，当然你也可以用绝对路径，这样更不容易出错</div><div class="line">cp *.txt /root/doubi</div><div class="line"></div><div class="line"><span class="meta">#</span> 重命名当前目录内的 log.txt文件为 log2.txt</div><div class="line">cp log.txt log2.txt</div><div class="line"><span class="meta">#</span> 复制当前目录内的 log.txt文件到 /var目录并重命名为 log1.txt</div><div class="line">cp log.txt /var/log1.txt</div><div class="line"><span class="meta">#</span> 复制当前目录内的 bash文件夹到 /home目录并重命名为 bash2</div><div class="line">cp -R bash /home/bash2</div><div class="line"></div><div class="line"><span class="meta">#</span> 复制当前目录内的 log.txt文件到 /var目录，但是 /var 目录中已经存着 log.txt，那么会提示 cp: overwrite `/var/log.txt'? 可以用 -f 强制覆盖</div><div class="line">cp -f log /var/log.txt</div><div class="line"><span class="meta">#</span> 复制当前目录内的 log.txt log1.txt log2.txt文件和 log233目录到 /home/log目录中</div><div class="line">cp -R log.txt log1.txt log2.txt log233 /home/log</div><div class="line"> </div><div class="line"><span class="meta">#</span> 更多的命令可以用 cp --help 查看。</div></pre></td></tr></table></figure>
<h3 id="mv-移动或重命名-文件-文件夹"><a href="#mv-移动或重命名-文件-文件夹" class="headerlink" title="mv 移动或重命名 文件/文件夹"></a>mv 移动或重命名 文件/文件夹</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> 关于 mv 命令，可以参考上面 cp 的使用方法，没什么区别，只是一个是复制，一个是移动，把上面 cp 命令改成 mv 就能套用了。</div><div class="line"> </div><div class="line"><span class="meta">#</span> 移动当前目录内的 log.txt文件到 /var目录</div><div class="line">mv log.txt /var/log.txt</div><div class="line"><span class="meta">#</span> 移动当前目录内的 bash文件夹到 /home目录</div><div class="line">mv bash /home/bash</div><div class="line">————————————————————————————————————————————————————————————————————————————</div><div class="line"><span class="meta">#</span> 重命名当前目录内的 log.txt文件为 log2.txt</div><div class="line">mv log.txt log2.txt</div><div class="line"><span class="meta">#</span> 复制当前目录内的 log.txt文件到 /var目录并重命名为 log1.txt</div><div class="line">mv log.txt /var/log1.txt</div><div class="line"><span class="meta">#</span> 复制当前目录内的 bash文件夹到 /home目录并重命名为 bash2</div><div class="line">mv bash /home/bash2</div><div class="line"> </div><div class="line"><span class="meta">#</span> 更多的命令可以用 mv --help 查看。</div></pre></td></tr></table></figure>
<h3 id="rm-删除-文件-文件夹"><a href="#rm-删除-文件-文件夹" class="headerlink" title="rm 删除 文件/文件夹"></a>rm 删除 文件/文件夹</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> 删除当前目录下的 log.txt文件</div><div class="line">rm log.txt</div><div class="line"><span class="meta">#</span> 删除当前目录下所有.txt后缀的文件</div><div class="line">rm *.txt</div><div class="line"><span class="meta">#</span> 使用 rm 命令删除时，会提示你是否确定删除，输入 y 即删除，输入 n 则取消</div><div class="line"><span class="meta">#</span> rm: remove regular file `log.txt'? y</div><div class="line">————————————————————————————————————————————————————————————————————————————</div><div class="line"><span class="meta">#</span> 删除当前目录下所有.txt后缀的文件</div><div class="line">rm *.txt</div><div class="line"><span class="meta">#</span> 删除当前目录下所有以 doubi开头的文件</div><div class="line">rm doubi*</div><div class="line"><span class="meta">#</span> 删除当前目录下所有以 doubi开头 以.txt后缀结尾的文件</div><div class="line">rm doubi*.txt</div><div class="line">————————————————————————————————————————————————————————————————————————————</div><div class="line"><span class="meta">#</span> 当你用 rm 删除目录的时候会发现提示这不是一个文件</div><div class="line"><span class="meta">#</span> rm bash</div><div class="line"><span class="meta">#</span> rm: cannot remove `bash': Is a directory</div><div class="line"><span class="meta">#</span> 可以加上 -r 来归递删除目录及其目录下的内容</div><div class="line">rm -r bash</div><div class="line">————————————————————————————————————————————————————————————————————————————</div><div class="line"><span class="meta">#</span> 因为为了避免手误删除错误，所以 rm默认是加上了 -i 的参数，也就是每一次删除文件/目录都会提示，如果觉得烦可以用 -rf 参数</div><div class="line">rm -rf bash</div><div class="line"><span class="meta">#</span> rm -rf 这个命令请慎重使用，而且千万不要使用 rm -rf / 或者 rm -rf /* 之类的命令(系统自杀)，可能会让你系统爆炸，所以使用请慎重！</div><div class="line"> </div><div class="line"><span class="meta">#</span> 更多的命令可以用 rm --help 查看。</div></pre></td></tr></table></figure>
<h2 id="查看-编辑文件"><a href="#查看-编辑文件" class="headerlink" title="查看/编辑文件"></a>查看/编辑文件</h2><h3 id="ls-显示目录中文件"><a href="#ls-显示目录中文件" class="headerlink" title="ls 显示目录中文件"></a>ls 显示目录中文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> 显示当前目录下的所有文件</div><div class="line">ls -a</div><div class="line">————————————————————————————————————————————————————————————————————————————</div><div class="line"><span class="meta">#</span> 命令后面加上 绝对路径/相对路径 就会显示指定文件夹内的所有文件</div><div class="line">ls -a bash/log</div><div class="line"><span class="meta">#</span> 相对路径，当前目录是 /root ，欲查看的目录是 /root/bash/log</div><div class="line">ls -a /root/bash/log</div><div class="line"><span class="meta">#</span> 绝对路径， 当前目录是 /root ，欲查看的目录是 /root/bash/log</div><div class="line"> </div><div class="line"><span class="meta">#</span> 更多的命令可以用 ls --help 来查看。</div></pre></td></tr></table></figure>
<h3 id="du-查看-文件-文件夹-占用磁盘空间的大小"><a href="#du-查看-文件-文件夹-占用磁盘空间的大小" class="headerlink" title="du 查看 文件/文件夹 占用磁盘空间的大小"></a>du 查看 文件/文件夹 占用磁盘空间的大小</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">-h ：以人类易读的方式显示</div><div class="line">-a ：显示 目录占用的磁盘空间大小，并显示其下目录和文件占用磁盘空间的大小</div><div class="line">-s ：显示 目录占用的磁盘空间大小，但不显示其下子目录和文件占用的磁盘空间大小</div><div class="line">-c ：显示几个目录或文件占用的磁盘空间大小，还要统计它们的总和</div><div class="line">--apparent-size：显示目录或文件自身的大小</div><div class="line">-l ：统计硬链接占用磁盘空间的大小</div><div class="line">-L ：统计符号链接所指向的文件占用的磁盘空间大小</div><div class="line"><span class="meta">#</span> 待写...</div><div class="line"> </div><div class="line"><span class="meta">#</span> 更多的命令可以用 du --help 来查看。</div><div class="line"></div><div class="line"><span class="meta">#</span> 示例</div><div class="line"></div><div class="line"><span class="meta">#</span> 显示 /root 文件夹的大小，但不显示其子目录和文件的大小</div><div class="line">du -sh</div><div class="line"> </div><div class="line"><span class="meta">#</span> 显示 /root 文件夹的大小，并显示其子目录和文件的大小</div><div class="line">du -ah</div><div class="line"> </div><div class="line"><span class="meta">#</span> 待写...</div><div class="line"> </div><div class="line"><span class="meta">#</span> 更多的命令可以用 du --help 来查看。</div></pre></td></tr></table></figure>
<h3 id="cat-查看文件内容"><a href="#cat-查看文件内容" class="headerlink" title="cat 查看文件内容"></a>cat 查看文件内容</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> 查看 log.txt文件的所有内容</div><div class="line">cat log.txt</div><div class="line"><span class="meta">#</span> 查看 log.txt文件的所有内容，并对所有行编号</div><div class="line">cat -n log.txt</div><div class="line"><span class="meta">#</span> 查看 log.txt文件的所有内容，并对非空行编号</div><div class="line">cat -b log.txt</div><div class="line"><span class="meta">#</span> 查看 log.txt文件的所有内容，并对非空行编号，且不输出多行空行</div><div class="line">cat -bs log.txt</div><div class="line"></div><div class="line"><span class="meta">#</span> 清空当前目录中的 log.txt 文件</div><div class="line">cat /dev/null &gt; log.txt</div><div class="line"> </div><div class="line"><span class="meta">#</span> 清空 /var目录中的 log.txt 文件</div><div class="line">cat /dev/null &gt; /var/log.txt</div><div class="line"></div><div class="line"><span class="meta">#</span> 写入文本到当前目录中的 log.txt文件中(加入文本到文件内容最后)</div><div class="line">cat &gt;&gt; log.txt &lt;&lt;-EOF</div><div class="line">doubi</div><div class="line">doubi233</div><div class="line">doubi666</div><div class="line">EOF</div><div class="line"> </div><div class="line"><span class="meta">#</span> 清空文件并写入文本到 /var目录中的 log.txt文件中(先清空后写入)</div><div class="line">cat &gt; /var/log.txt &lt;&lt;-EOF</div><div class="line">doubi</div><div class="line">doubi233</div><div class="line">doubi666</div><div class="line">EOF</div><div class="line"> </div><div class="line"><span class="meta">#</span> 更多的命令可以用 cat --help 来查看。</div></pre></td></tr></table></figure>
<h3 id="head-查看文件内容（主要用于正查）"><a href="#head-查看文件内容（主要用于正查）" class="headerlink" title="head 查看文件内容（主要用于正查）"></a>head 查看文件内容（主要用于正查）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">-c 数字：显示指定文件的前 xx 字节的内容（bytes）</div><div class="line">-n 数字：显示指定文件的前 xx 行的内容</div><div class="line">-q ：不显示包含指定文件名的文件头（当使用 head打开多个文件的时候，会去在每个文件输出结果的顶部添加一个包含文件名的文件头用于区分）</div><div class="line"> </div><div class="line"><span class="meta">#</span> 更多的命令可以用 head --help 来查看。</div><div class="line"></div><div class="line"><span class="meta">#</span> 示例</div><div class="line"><span class="meta">#</span> 查看 log.txt文件的全部内容</div><div class="line">head log.txt</div><div class="line"> </div><div class="line"><span class="meta">#</span> 查看 log.txt文件的前 4字节的内容</div><div class="line">head -c 4 log.txt</div><div class="line"> </div><div class="line"><span class="meta">#</span> 输出示例</div><div class="line">doub</div><div class="line"> </div><div class="line"><span class="meta">#</span> 查看 log.txt文件的前 2行的内容</div><div class="line">head -n 2 log.txt</div><div class="line"> </div><div class="line"><span class="meta">#</span> 输出示例</div><div class="line">doubi1</div><div class="line">doubi2</div><div class="line"> </div><div class="line"><span class="meta">#</span> 查看 log.txt log1.txt log2.txt文件的前 3行内容</div><div class="line">head -n 3 log.txt log1.txt log2.txt</div><div class="line"> </div><div class="line"><span class="meta">#</span> 更多的命令可以用 head --help 来查看。</div></pre></td></tr></table></figure>
<h3 id="tail-查看文件内容（主要用于倒查）"><a href="#tail-查看文件内容（主要用于倒查）" class="headerlink" title="tail 查看文件内容（主要用于倒查）"></a>tail 查看文件内容（主要用于倒查）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">-c 数字：如果数字为正数(例如 -c +5)，显示指定文件从行首第 xx 字节到最后的内容；如果数字为负数(例如 -c -5)，显示指定文件从行尾第 xx 字节到最后内容。</div><div class="line">-n 数字：如果数字为正数(例如 -c +3)，显示指定文件从行首第 xx 行到最后的内容；如果数字为负数(例如 -c -3)，显示指定文件从行尾第 xx 行到最后的内容。</div><div class="line">-f ：即时输出文件变化后增加的内容，也就是监视一个文件的内容变化（常用于监视日志输出），使用 Ctrl＋C 终止</div><div class="line"> </div><div class="line"><span class="meta">#</span> 更多的命令可以用 tail --help 来查看。</div><div class="line"></div><div class="line"><span class="meta">#</span> 示例</div><div class="line"><span class="meta">#</span> 查看 log.txt文件的全部内容</div><div class="line">tail log.txt</div><div class="line"> </div><div class="line"><span class="meta">#</span> 查看 log.txt文件从行首 第25字节到最后的内容</div><div class="line">tail -c +25 log.txt</div><div class="line"> </div><div class="line"><span class="meta">#</span> 输出示例</div><div class="line">bi4</div><div class="line">doubi5</div><div class="line">doubi6</div><div class="line"> </div><div class="line"><span class="meta">#</span> 查看 log.txt文件从行尾 第4字节到最后的内容</div><div class="line">tail -c -4 log.txt</div><div class="line"> </div><div class="line"><span class="meta">#</span> 输出示例</div><div class="line">bi5</div><div class="line"> </div><div class="line"><span class="meta">#</span> 查看 log.txt文件的前 2行的内容</div><div class="line">tail -n +2 log.txt</div><div class="line"> </div><div class="line"><span class="meta">#</span> 输出示例</div><div class="line">doubi1</div><div class="line">doubi2</div><div class="line"> </div><div class="line"><span class="meta">#</span> 查看 log.txt文件的后 2行的内容</div><div class="line">tail -n -2 log.txt</div><div class="line"> </div><div class="line"><span class="meta">#</span> 输出示例</div><div class="line">doubi5</div><div class="line">doubi6</div><div class="line"> </div><div class="line"><span class="meta">#</span> 持续查看（监视） log.txt文件的变化内容（新增加的内容），使用 Ctrl＋C 终止</div><div class="line">tail -f log.txt</div><div class="line"> </div><div class="line"><span class="meta">#</span> 查看 log.txt log1.txt log2.txt文件的前 3行内容</div><div class="line">tail -n 3 log.txt log1.txt log2.txt</div><div class="line"> </div><div class="line"><span class="meta">#</span> 更多的命令可以用 tail --help 来查看。</div></pre></td></tr></table></figure>
<h3 id="sed-查看-编辑文件内容"><a href="#sed-查看-编辑文件内容" class="headerlink" title="sed 查看/编辑文件内容"></a>sed 查看/编辑文件内容</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">-i ：操作后应用保存到原文件（如果不加这个参数，那么任何修改都不会影响原文件里的内容，只会把结果输出）</div><div class="line"><span class="meta">#</span> 待写...</div><div class="line"> </div><div class="line"><span class="meta">#</span> 更多的命令可以用 sed --help 来查看。</div><div class="line"></div><div class="line"><span class="meta">#</span> 示例</div><div class="line"></div><div class="line"><span class="meta">#</span> 查看 log.txt 第3行的内容</div><div class="line">sed '3p' log.txt</div><div class="line"> </div><div class="line"><span class="meta">#</span> 查看 log.txt 第2-8行的内容</div><div class="line">sed '2,8p' log.txt</div><div class="line"> </div><div class="line"><span class="meta">#</span> 删除 log.txt 第4行</div><div class="line">sed -i '4d' log.txt</div><div class="line"> </div><div class="line"><span class="meta">#</span> 删除 log.txt 第3-7行</div><div class="line">sed -i '3,7d' log.txt</div><div class="line"> </div><div class="line"><span class="meta">#</span> 删除 log.txt 第1行</div><div class="line">sed -i '1d' log.txt</div><div class="line"> </div><div class="line"><span class="meta">#</span> 删除 log.txt 最后1行</div><div class="line">sed -i '$d' log.txt</div><div class="line"> </div><div class="line"><span class="meta">#</span> 删除 log.txt 文件中所有包含 233内容的行</div><div class="line">sed -i '/233/d' log.txt</div><div class="line"> </div><div class="line"><span class="meta">#</span> 替换 log.txt 文件中所有 233为666</div><div class="line">sed -i 's/233/666/' log.txt</div><div class="line"> </div><div class="line"><span class="meta">#</span> 替换 log.txt 文件中所有 /ver 为 doubi/，因为有斜杠，所以需要使用 \ 转义，但是单引号会导致无法转义，所以要改成双引号。</div><div class="line">sed -i "s/\/ver/doubi\//" log.txt</div><div class="line"> </div><div class="line"><span class="meta">#</span> 待写...</div><div class="line"> </div><div class="line"><span class="meta">#</span> 更多的命令可以用 sed --help 来查看。</div></pre></td></tr></table></figure>
<h3 id="vi、vim、nano-编辑文件内容"><a href="#vi、vim、nano-编辑文件内容" class="headerlink" title="vi、vim、nano 编辑文件内容"></a>vi、vim、nano 编辑文件内容</h3><blockquote>
<p>vi是Linux非常流行的文本编辑器，vim相当于vi的增强版，一般Linux操作系统会自带vi，而vim需要手动安装（yum install vim -y / apt-get install vim -y）</p>
</blockquote>
<h4 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> 打开当前目录下的 log.txt文件，如果没有那么会新建 log.txt文件（安装vim后，使用 vi和 vim打开文件没区别）</div><div class="line">vi log.txt</div><div class="line">vim log.txt</div><div class="line"> </div><div class="line"><span class="meta">#</span> 在命令行模式下，直接输入以下 符号和字母(区分大小写)</div><div class="line"><span class="meta">#</span># 进入编辑模式（插入模式，按 Esc键 即可返回命令行模式）</div><div class="line">i</div><div class="line"><span class="meta">#</span># 删除光标当前所在的一行</div><div class="line">dd</div><div class="line"><span class="meta">#</span># 删除文件内所有内容</div><div class="line">dddG</div><div class="line"><span class="meta">#</span># 复制光标当前所在的一行</div><div class="line">yy</div><div class="line"><span class="meta">#</span># 粘贴刚才复制的一行内容</div><div class="line">p</div><div class="line"><span class="meta">#</span># 撤销上个操作（误操作可以用这个恢复）</div><div class="line">u</div><div class="line"><span class="meta">#</span># 保存当前文件（ : 是英文的冒号）</div><div class="line">:w</div><div class="line"><span class="meta">#</span># 另存当前文件内容为 log2.txt</div><div class="line">:w log2.txt</div><div class="line"><span class="meta">#</span># 退出当前文件</div><div class="line">:q</div><div class="line"><span class="meta">#</span># 不保存 并强制退出当前文件</div><div class="line">:q!</div><div class="line"><span class="meta">#</span># 保存并退出当前文件</div><div class="line">:wq</div><div class="line"> </div><div class="line"><span class="meta">#</span> 更多的命令可以用 vi --help / vim --help 来查看。</div></pre></td></tr></table></figure>
<h4 id="nano"><a href="#nano" class="headerlink" title="nano"></a>nano</h4><blockquote>
<p>一般系统也会默认安装的一个文本编辑器</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> 打开当前目录下的 log.txt文件，如果没有那么会新建 log.txt文件</div><div class="line">nano log.txt</div><div class="line"><span class="meta">#</span> 进入后直接就可以输入修改文本内容了，修改后我们可以使用这个 按键保存内容</div><div class="line">Ctrl+O</div><div class="line"><span class="meta">#</span> 如果不需要编辑了，那么可以用这个 按键退出当前文件</div><div class="line">Ctrl+X</div><div class="line"><span class="meta">#</span> 如果你在退出前已经修改但没有保存，那么会提醒你是否保存，如果保存就输入 y ，不保存输入 n</div><div class="line"><span class="meta">#</span> 然后就会让你输入要保存的文件名（默认原文件名，所以直接按 Enter回车即可，除非你要另存为其他文件名）</div><div class="line">Enter</div><div class="line"><span class="meta">#</span> 更多的命令可以用 nano --help 来查看。</div></pre></td></tr></table></figure>
<h2 id="压缩文件操作"><a href="#压缩文件操作" class="headerlink" title="压缩文件操作"></a>压缩文件操作</h2><blockquote>
<p>常见压缩文件格式有：zip、rar、gz、xz、tar.gz、tar.xz、tar.bz、tar.bz2等tar 本身只是一个打包的作用，.tar后面的才是压缩格式</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div></pre></td><td class="code"><pre><div class="line">-x 是从压缩文件提取(解压)文件出来，所以在解压命令中都有这个参数。</div><div class="line">-c ：创建一个新的压缩包文件，所以在压缩命令中都有这个参数。</div><div class="line">-f ：指定要解压的压缩包文件或要压缩的文件/文件夹，所以这个参数必须放在 解压缩命令参数的最后，然后后面跟着 要解压到压缩包文件或要压缩的文件/文件夹。</div><div class="line">-j ：解压缩 bz / bz2 格式的参数</div><div class="line">-J ：解压缩 xz / lzip 格式的参数</div><div class="line">-z ：解压缩 gz / tgz 格式的参数</div><div class="line">-Z ：解压缩 Z 格式的参数</div><div class="line">-v ：详细列出解压缩过程中处理的文件</div><div class="line"> </div><div class="line"><span class="meta">#</span> 更多的命令可以用 tar --help 来查看。</div><div class="line"></div><div class="line"><span class="meta">#</span> tar gz zip等 解压 压缩包 示例</div><div class="line"><span class="meta">#</span> 解压后缀为 .tar 的压缩包</div><div class="line">tar -xf log.tar</div><div class="line">————————————————————————————————————————————————————————————————————————————</div><div class="line"><span class="meta">#</span> 解压后缀为 .tar.xz 的压缩包</div><div class="line">tar -xJf log.tar.xz</div><div class="line">————————————————————————————————————————————————————————————————————————————</div><div class="line"><span class="meta">#</span> 解压后缀为 .tar.gz 的压缩包，有两个方法</div><div class="line">tar -xzf log.tar.gz</div><div class="line">————————————————————————————————————————————————————————————————————————————</div><div class="line"><span class="meta">#</span> 解压后缀为 .gz 的压缩包，有两个方法，如提示命令不存在，请安装 yum install gzip -y / apt-get install gzip -y</div><div class="line">gzip -d log.gz</div><div class="line">gunzip log.gz</div><div class="line">————————————————————————————————————————————————————————————————————————————</div><div class="line"><span class="meta">#</span> 解压后缀为 .bz / .bz2 / tar.bz2 的压缩包，有两个方法</div><div class="line">bzip2 -d log.bz</div><div class="line">bunzip2 log.bz</div><div class="line">tar -jxf log.tar.bz</div><div class="line"> </div><div class="line">bzip2 -d log.bz2</div><div class="line">bunzip2 log.bz2</div><div class="line">tar -jxf log.tar.bz2</div><div class="line">————————————————————————————————————————————————————————————————————————————</div><div class="line"><span class="meta">#</span> 解压后缀为 .Z / tar.Z 的压缩包，有两个方法</div><div class="line">uncompress log.Z log.txt</div><div class="line">uncompress log.Z log</div><div class="line">————————————————————————————————————————————————————————————————————————————</div><div class="line">tar xZf log.tar.Z log.txt</div><div class="line">tar xZf log.tar.Z log</div><div class="line">————————————————————————————————————————————————————————————————————————————</div><div class="line"><span class="meta">#</span> 解压后缀为 .rar 的压缩包，如提示命令不存在，请安装 yum install unrar -y / apt-get install unrar -y ，注意 rar 和 unrar 是分开的</div><div class="line">unrar x log.rar</div><div class="line">————————————————————————————————————————————————————————————————————————————</div><div class="line"><span class="meta">#</span> 解压后缀为 .zip 的压缩包，如提示命令不存在，请安装 yum install unzip -y / apt-get install unzip -y，注意 zip 和 unzip 是分开的</div><div class="line">unzip log.zip</div><div class="line"> </div><div class="line"><span class="meta">#</span> 更多的命令可以用 tar --help / gzip --help / unrar --help / unzip --help 来查看。</div><div class="line"></div><div class="line"><span class="meta">#</span> 压缩 文件/文件夹 示例</div><div class="line"><span class="meta">#</span> 分别压缩当前目录下的 log.txt文件 / log文件夹为 log.tar 压缩包</div><div class="line">tar -cf log.tar log.txt</div><div class="line">tar -cf log.tar log</div><div class="line">————————————————————————————————————————————————————————————————————————————</div><div class="line"><span class="meta">#</span> 如果要压缩多个文件和文件夹，那么只需要在后面一直加下去即可</div><div class="line">tar -cf log.tar log.txt doub.txt log bash</div><div class="line">————————————————————————————————————————————————————————————————————————————</div><div class="line"><span class="meta">#</span> 分别压缩当前目录下的 log.txt文件 / log文件夹为 log.tar.xz 压缩包，以下的其他后缀压缩命令都是一样</div><div class="line">tar -cJf log.tar.xz log.txt</div><div class="line">tar -cJf log.tar.xz log</div><div class="line">————————————————————————————————————————————————————————————————————————————</div><div class="line"><span class="meta">#</span> 分别压缩当前目录下的 log.txt文件 / log文件夹为 log.tar.gz 压缩包</div><div class="line">tar -czf log.tar.gz log.txt</div><div class="line">tar -czf log.tar.gz log</div><div class="line">————————————————————————————————————————————————————————————————————————————</div><div class="line"><span class="meta">#</span> 分别压缩当前目录下的 log.txt文件 / log文件夹为 log.gz 压缩包</div><div class="line">gzip log.gz log.txt</div><div class="line">gzip log.gz log</div><div class="line">————————————————————————————————————————————————————————————————————————————</div><div class="line"><span class="meta">#</span> 分别压缩当前目录下的 log.txt文件 / log文件夹为 log.tar.bz 压缩包</div><div class="line">暂时没查到</div><div class="line">————————————————————————————————————————————————————————————————————————————</div><div class="line"><span class="meta">#</span> 分别压缩当前目录下的 log.txt文件 / log文件夹为 log.bz / log.tar.bz / log.bz2 / log.tar.bz2压缩包</div><div class="line">bzip2 -z log.txt</div><div class="line">bzip2 -z log</div><div class="line"> </div><div class="line">tar cjf log.tar.bz2 log.txt</div><div class="line">tar cjf log.tar.bz2 log</div><div class="line">————————————————————————————————————————————————————————————————————————————</div><div class="line"><span class="meta">#</span> 分别压缩当前目录下的 log.txt文件 / log文件夹为 log.Z / log.tar.Z 压缩包</div><div class="line">compress log.txt</div><div class="line">compress log</div><div class="line"> </div><div class="line">tar cZf log.tar.Z log.txt</div><div class="line">tar cZf log.tar.Z log</div><div class="line">————————————————————————————————————————————————————————————————————————————</div><div class="line"><span class="meta">#</span> 分别压缩当前目录下的 log.txt文件 / log文件夹为 log.rar 压缩包，如提示命令不存在，请安装 yum install rar -y / apt-get install rar -y ，注意 rar 和 unrar 是分开的</div><div class="line">unrar a log.rar log.txt</div><div class="line">unrar a log.rar log</div><div class="line">————————————————————————————————————————————————————————————————————————————</div><div class="line"><span class="meta">#</span> 分别压缩当前目录下的 log.txt文件 / log文件夹为 log.zip 压缩包，如提示命令不存在，请安装 yum install zip -y / apt-get install zip -y ，注意 zip 和 unzip 是分开的</div><div class="line">zip log.zip log.txt</div><div class="line">zip log.zip log</div><div class="line"> </div><div class="line"><span class="meta">#</span> 更多的命令可以用 tar --help / gzip --help / rar --help / zip --help 来查看。</div></pre></td></tr></table></figure>
<h2 id="网络工具"><a href="#网络工具" class="headerlink" title="网络工具"></a>网络工具</h2><h4 id="wget-多功能下载工具"><a href="#wget-多功能下载工具" class="headerlink" title="wget 多功能下载工具"></a>wget 多功能下载工具</h4><blockquote>
<p>wget 是Linux系统最常用的工具之一，命令行方式的多功能下载工具，支持HTTP，HTTPS和FTP协议。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> 只介绍最常用的参数</div><div class="line"><span class="meta">#</span> 如果提示命令不存在，那么使用 yum install wget -y / apt-get install wget -y 来安装（有一些非常精简的系统可能会没装）</div><div class="line"> </div><div class="line">-b ：启动后，后台下载</div><div class="line">-q ：安静模式（不输出任何信息）</div><div class="line">-c ：断点续传下载文件</div><div class="line">-O ：指定下载后的文件名（可使用绝对路径目录+文件名）</div><div class="line">-P ：指定下载后的文件目录（-P只能指定下载目录，并不能指定文件名）</div><div class="line">-t ：设置重试次数（0代表无限）</div><div class="line">-T ：设置超时时间（单位：秒）</div><div class="line">-N ：只获取比本地新的文件（新的覆盖旧的）</div><div class="line">-4 ：仅连接至 IPv4地址</div><div class="line">-6 ：仅连接至 IPv6地址</div><div class="line">--limit-rate=xxxk :限制下载速度（k代表KB/S）</div><div class="line">--post-data ：通过POST方式发送数据</div><div class="line">--no-check-certificate ：不验证服务器的SSL证书</div><div class="line"> </div><div class="line"><span class="meta">#</span> 更多的命令可以用 wget --help 来查看。</div><div class="line"><span class="meta">#</span> 示例</div><div class="line"></div><div class="line"><span class="meta">#</span> 下载一个文件到当前目录</div><div class="line">wget https://softs.pw/100MB.bin</div><div class="line"> </div><div class="line"><span class="meta">#</span> 下载文件到当前目录并重命名为 200MB.bin</div><div class="line">wget -O "200MB.bin" https://softs.pw/100MB.bin</div><div class="line"> </div><div class="line"><span class="meta">#</span> 下载文件到 /root目录（-P只能指定下载目录，并不能指定文件名）</div><div class="line">wget -P "/root" https://softs.pw/100MB.bin</div><div class="line"> </div><div class="line"><span class="meta">#</span> 下载文件到 /root/doubi目录并重命名为 200MB.bin</div><div class="line">wget -O "/root/doubi/200MB.bin" https://softs.pw/100MB.bin</div><div class="line"> </div><div class="line"><span class="meta">#</span> 下载文件完成之前 wget进程结束了，那么可以使用断点续传重新下载中断的文件（前提是下载服务器支持断点续传）</div><div class="line">wget -c https://softs.pw/100MB.bin</div><div class="line"><span class="meta">#</span> 通过后台下载文件到 /root/doubi目录并重命名为 200MB.bin</div><div class="line">wget -b -O "/root/doubi/200MB.bin" https://softs.pw/100MB.bin</div><div class="line"><span class="meta">#</span> Continuing in background, pid 2333.</div><div class="line"><span class="meta">#</span> Output will be written to `wget-log'.</div><div class="line"><span class="meta">#</span> 后台下后，你可以使用以下命令来查看下载进度：</div><div class="line">tail -f wget-log</div><div class="line"> </div><div class="line"><span class="meta">#</span> 有时候一些Linux系统中的SSL证书不完整，会导致下载一些 HTTPS网站文件的时候会验证SSL证书失败，可以这样做</div><div class="line"><span class="meta">#</span> 不验证服务器SSL证书，下载文件到当前目录并重命名为 200MB.bin</div><div class="line">wget --no-check-certificate -O "200MB.bin" https://softs.pw/100MB.bin</div><div class="line"> </div><div class="line"><span class="meta">#</span> 使用wget发送POST请求数据</div><div class="line">wget --post-data "user=doubi&amp;passwd=23333" https://xxx.xx/</div><div class="line"> </div><div class="line"><span class="meta">#</span> 下载文件到当前目录 并仅通过IPv4连接 只获取比本地新的文件，限速 200KB/S</div><div class="line">wget --limit-rate=200k -N -4 https://softs.pw/100MB.bin</div><div class="line"> </div><div class="line"><span class="meta">#</span> 下载文件到当前目录 并重试次数为 1，超时时间为 2秒</div><div class="line">wget -t1 -T2 https://softs.pw/100MB.bin</div><div class="line"> </div><div class="line"><span class="meta">#</span> 通过 wget来获取服务器的外网IP（-qO- 代表运行完会输出下载的信息，并不会保存到本地文件）</div><div class="line">wget -qO- ipinfo.io/ip</div><div class="line"> </div><div class="line"><span class="meta">#</span> 更多的命令可以用 wget --help 来查看。</div></pre></td></tr></table></figure>
<h4 id="curl-HTTP工具"><a href="#curl-HTTP工具" class="headerlink" title="curl HTTP工具"></a>curl HTTP工具</h4><blockquote>
<p>curl是Linux系统一个利用URL规则在命令行下工作的文件传输工具，是一款很强大的HTTP命令行工具。它支持文件的上传和下载，是综合传输工具，但习惯称curl为下载工具。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> 只介绍最常用的参数</div><div class="line"><span class="meta">#</span> 如果提示命令不存在，那么使用 yum install curl -y / apt-get install curl -y 来安装（有一些非常精简的系统可能会没装）</div><div class="line"> </div><div class="line">-s ：安静模式（不会输出任何信息）</div><div class="line">-C ：断点续传下载文件</div><div class="line">-o ：输出写入到文件中</div><div class="line">-O ：输出写入到文件，文件名为 远程文件的名称</div><div class="line">-k ：不验证服务器SSL证书</div><div class="line">-T ：上传文件</div><div class="line">-4 ：仅连接至 IPv4地址</div><div class="line">-6 ：仅连接至 IPv6地址</div><div class="line">-m ：设置传输总时间（单位：秒）</div><div class="line">--retry ：设置重试次数</div><div class="line">--data ：通过POST方式发送数据</div><div class="line">--limit-rate xxxK ：限制下载速度（K代表KB/S）</div><div class="line"> </div><div class="line"><span class="meta">#</span> 更多的命令可以用 curl --help 来查看。</div><div class="line"><span class="meta">#</span> 示例</div><div class="line"></div><div class="line"><span class="meta">#</span> 获取当前服务器的外网IP</div><div class="line">curl ipinfo.io/ip</div><div class="line"> </div><div class="line"><span class="meta">#</span> 获取一个文件保存到当前目录中</div><div class="line">wget -O https://softs.pw/Bash/ssr.sh</div><div class="line"> </div><div class="line"><span class="meta">#</span> 获取一个文件保存到 /root/doubi目录中 并修改文件名为 233.sh</div><div class="line">curl -o "/root/doubi/233.sh" https://softs.pw/Bash/ssr.sh</div><div class="line"> </div><div class="line"><span class="meta">#</span> 下载文件完成之前 curl进程结束了，那么可以使用断点续传重新下载中断的文件（前提是下载服务器支持断点续传）</div><div class="line">curl -C -O https://softs.pw/100MB.bin</div><div class="line"> </div><div class="line"><span class="meta">#</span> 有时候一些Linux系统中的SSL证书不完整，会导致访问/下载一些 HTTPS网站/文件的时候会验证SSL证书失败，可以这样做</div><div class="line"><span class="meta">#</span> 不验证服务器SSL证书，下载文件到当前目录并重命名为 233.sh</div><div class="line">curl -k -o "233.sh" https://softs.pw/Bash/ssr.sh</div><div class="line"> </div><div class="line"><span class="meta">#</span> 使用curl发送GET请求数据</div><div class="line">curl https://xxx.xx/?user=doubi</div><div class="line"> </div><div class="line"><span class="meta">#</span> 使用curl发送POST请求数据</div><div class="line">curl --data "user=doubi&amp;passwd=23333" https://xxx.xx/</div><div class="line"> </div><div class="line"><span class="meta">#</span> 下载文件到当前目录 并仅通过IPv4连接，限速 200KB/S</div><div class="line">curl --limit-rate 200K -4 https://softs.pw/100MB.bin</div><div class="line"> </div><div class="line"><span class="meta">#</span> 下载文件到当前目录 并重试次数为 1，超时时间为 2秒</div><div class="line">curl --retry 1 -m 10 https://softs.pw/100MB.bin</div><div class="line"> </div><div class="line"><span class="meta">#</span> 更多的命令可以用 curl --help 来查看。</div></pre></td></tr></table></figure>
<h4 id="netstat-查看链接和端口监听等信息"><a href="#netstat-查看链接和端口监听等信息" class="headerlink" title="netstat 查看链接和端口监听等信息"></a>netstat 查看链接和端口监听等信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">-n ：不显示别名（主机名/域名以 数字或IP显示）</div><div class="line">-e ：显示其他/更多信息</div><div class="line">-p ：显示进程PID/进程名</div><div class="line">-c ：持续输出（设置后会每隔 1秒输出一次，Ctrl+C 终止）</div><div class="line">-l ：显示正在监听的套接字</div><div class="line">-a ：显示全部信息</div><div class="line"> </div><div class="line"><span class="meta">#</span> 下面这些就不很常用了。</div><div class="line">-r ：显示路由表</div><div class="line">-i ：显示网络接口（网卡）</div><div class="line">-g ：显示多播组信息</div><div class="line">-s ：显示网络统计</div><div class="line">-M ：显示伪装连接</div><div class="line">-v ：显示正在进行的工作</div><div class="line"> </div><div class="line"><span class="meta">#</span> 更多的命令可以用 netstat --help 来查看。</div><div class="line"></div><div class="line"><span class="meta">#</span> 示例</div><div class="line"><span class="meta">#</span> 显示当前服务器的所有连接信息</div><div class="line">netstat -a</div><div class="line"> </div><div class="line"><span class="meta">#</span> 显示当前服务器的所有 TCP连接信息</div><div class="line">netstat -at</div><div class="line"> </div><div class="line"><span class="meta">#</span> 显示当前服务器的所有 UDP连接信息</div><div class="line">netstat -au</div><div class="line"></div><div class="line"><span class="meta">#</span> 一般来说经常使用这个命令：</div><div class="line"></div><div class="line"><span class="meta">#</span> 显示当前服务器的所有正在监听 TCP端口的信息，并且 显示进程PID和进程名，但不显示别名（域名以IP显示），这个命令算是最常用的了。</div><div class="line">netstat -lntp</div><div class="line"></div><div class="line"><span class="meta">#</span> 显示监听 80端口的进程PID和进程名，grep是匹配并显示 符合关键词的行。</div><div class="line">netstat -lntp|grep ":80"</div><div class="line"></div><div class="line"><span class="meta">#</span> 显示 ssh的监听情况，grep是匹配并显示 符合关键词的行。</div><div class="line">netstat -lntp|grep "ssh"</div><div class="line"></div><div class="line"><span class="meta">#</span> 每隔 1秒显示一次当前服务器的所有连接信息</div><div class="line">netstat -c</div><div class="line"> </div><div class="line"><span class="meta">#</span> 每隔 1秒显示一次当前服务器的所有 TCP连接信息</div><div class="line">netstat -ct</div><div class="line"> </div><div class="line"><span class="meta">#</span> 每隔 1秒显示一次当前服务器的所有 UDP连接信息</div><div class="line">netstat -cu</div><div class="line"> </div><div class="line"><span class="meta">#</span> 显示当前服务器的路由表</div><div class="line">netstat -r</div><div class="line"> </div><div class="line"><span class="meta">#</span> 显示当前服务器的网络接口信息（网卡）</div><div class="line">netstat -i</div><div class="line"> </div><div class="line"><span class="meta">#</span> 显示当前服务器的网络统计信息</div><div class="line">netstat -s</div></pre></td></tr></table></figure>
<p>名词解释</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">Proto ：连接协议（tcp/udp是IPv4，tcp6/udp6是IPv6）</div><div class="line">Recv-Q ： 接收队列（基本都是0，如果不是代表堆积）</div><div class="line">Send-Q ：发送队列（基本都是0，如果不是代表堆积）</div><div class="line">Local Address ：本地地址和端口</div><div class="line">Foreign Address ：对外地址和端口</div><div class="line">State ：连接状态</div><div class="line">PID/Program name ：进程PID/进程名</div><div class="line"></div><div class="line">LISTEN</div><div class="line"><span class="meta">#</span> 监听来自远程连接的 TCP端口连接请求</div><div class="line">SYN-SENT</div><div class="line"><span class="meta">#</span> 在发送连接请求后，等待匹配的连接请求</div><div class="line">SYN-RECEIVED</div><div class="line"><span class="meta">#</span> 在收到和发送一个连接请求后，等待对方对连接请求的确认</div><div class="line">ESTABLISHED</div><div class="line"><span class="meta">#</span> 代表一个打开的连接</div><div class="line">FIN-WAIT-1</div><div class="line"><span class="meta">#</span> 等待远程 TCP连接中断请求，或先前的连接中断请求的确认</div><div class="line">FIN-WAIT-2</div><div class="line"><span class="meta">#</span> 从远程 TCP等待连接中断请求 </div><div class="line">CLOSE-WAIT</div><div class="line"><span class="meta">#</span> 等待从本地用户发来的连接中断请求 </div><div class="line">CLOSING</div><div class="line"><span class="meta">#</span> 等待远程TCP对连接中断的确认 </div><div class="line">LAST-ACK</div><div class="line"><span class="meta">#</span> 等待原来的发向远程TCP的连接中断请求的确认 </div><div class="line">TIME-WAIT</div><div class="line"><span class="meta">#</span> 等待足够的时间，以确保远程TCP接收到连接中断请求的确认 </div><div class="line">CLOSED</div><div class="line"><span class="meta">#</span> 没有任何连接状态（或者关闭了连接）</div></pre></td></tr></table></figure>
<h2 id="系统命令"><a href="#系统命令" class="headerlink" title="系统命令"></a>系统命令</h2><h3 id="ps-查看进程信息"><a href="#ps-查看进程信息" class="headerlink" title="ps 查看进程信息"></a>ps 查看进程信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> 更多的命令可以用 man ps 来查看。</div><div class="line"></div><div class="line"><span class="meta">#</span> 示例</div><div class="line"><span class="meta">#</span> 显示当前进程信息</div><div class="line">ps -ef</div><div class="line"> </div><div class="line"><span class="meta">#</span> 显示 ssh 进程（ grep -v grep 表示排除关键词grep，因为使用 grep匹配ssh，也会把grep自己的进程匹配进去的）</div><div class="line">ps -ef|grep -v grep|grep ssh</div></pre></td></tr></table></figure>
<p>名词解释</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">UID ：启动进程的用户</div><div class="line">PID ：进程标识符（进程 1代表init 是整个系统的父进程）</div><div class="line">PPID ：父进程标识符（进程 1代表init 是整个系统的父进程）</div><div class="line">C ：CPU占用率 %</div><div class="line">STIME ：启动进程的日期</div><div class="line">TTY ：终端号</div><div class="line">TIME ：进程运行时间（非休眠状态）</div><div class="line">CMD ：启动进程的命令（或进程名/进程程序所在目录）</div></pre></td></tr></table></figure>
<h3 id="kill-结束进程"><a href="#kill-结束进程" class="headerlink" title="kill 结束进程"></a>kill 结束进程</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> 当我们想要结束一个进程的时候，我们可以用 kill 命令</div><div class="line"><span class="meta">#</span> PID是每个进程的一个唯一标识符，可以使用上面的 ps 命令来查看你要结束进程的PID。</div><div class="line"> </div><div class="line"><span class="meta">#</span> 假设我们要结束 Nginx的进程，那么这样做（ grep -v grep 表示排除关键词grep，因为使用 grep匹配ssh，也会把grep自己的进程匹配进去的）：</div><div class="line">ps -ef|grep -v grep|grep "nginx"</div><div class="line"> </div><div class="line"><span class="meta">#</span> 输出示例</div><div class="line">UID PID PPID C STIME TTY TIME CMD #注意使用上面命令的话是不会显示表头这一行的，我只是为了更好理解加上的</div><div class="line">root 2356 1 0 04/03 ? 00:03:12 nginx</div><div class="line"> </div><div class="line"><span class="meta">#</span> 然后我们可以看到第二列的 PID 进程标识符，然后我们 kill 即可。</div><div class="line">kill -9 2356</div><div class="line"> </div><div class="line"><span class="meta">#</span> 中断进程 -2 相当于 程序运行在前台，然后输入 Ctrl+C 的效果，但是进程有权利忽略，所以不一定能结束进程</div><div class="line">kill -2 PID</div><div class="line"><span class="meta">#</span> 强制结束进程 -9 ，注意：强制结束某个进程后，可能会造成进程数据丢失等问题！</div><div class="line">kill -9 PID</div></pre></td></tr></table></figure>
<h3 id="free-查看内存使用信息"><a href="#free-查看内存使用信息" class="headerlink" title="free 查看内存使用信息"></a>free 查看内存使用信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">-b ：以 字节(bytes/B) 为单位显示</div><div class="line">-k ：以 KB 为单位显示</div><div class="line">-m ：以 MB 为单位显示</div><div class="line">-g ：以 GB 为单位显示</div><div class="line">--tera ：以 TB 为单位显示</div><div class="line">-h ：以 人类易读的方式输出</div><div class="line">--si ：以 1000为单位转换，而不是 1024（1MB=1*1024KB改成 1MB=1*1000KB）</div><div class="line">-t ：显示 内存总数 行</div><div class="line">-s 时间 ：每隔 X秒输出一次（重复输出监视内存，使用 Ctrl+C 终止）</div><div class="line">-c 次数 ：每隔 1秒输出 X次</div><div class="line"> </div><div class="line"><span class="meta">#</span> 更多的命令可以用 free --help 来查看。</div><div class="line"></div><div class="line"><span class="meta">#</span> 示例</div><div class="line"></div><div class="line"><span class="meta">#</span> 显示当前系统内存（默认 free = free -k，单位为 KB）</div><div class="line">free</div><div class="line"> </div><div class="line"><span class="meta">#</span> 以单位 B/KB/MB/GB/TG 显示当前系统内存</div><div class="line">free -b / free -k / free -m / free -g / free --tera</div><div class="line"> </div><div class="line"><span class="meta">#</span> 以人类易读的方式 显示当前系统内存</div><div class="line">free -h</div><div class="line"></div><div class="line"><span class="meta">#</span> 以 1000为单位转换并使用 MB为单位 显示当前系统内存（1MB=1*1024KB改成 1MB=1*1000KB）</div><div class="line">free -m --si</div><div class="line"> </div><div class="line"><span class="meta">#</span> 每隔 3秒并使用 MB为单位 显示一次当前系统内存</div><div class="line">free -ms 3</div><div class="line"> </div><div class="line"><span class="meta">#</span> 每隔 1秒并使用 MB为单位 显示 5次当前系统内存</div><div class="line">free -mc 5</div><div class="line"> </div><div class="line"><span class="meta">#</span> 每隔 2秒并使用 MB为单位 总共显示 6次当前系统内存</div><div class="line">free -m -c 6 -s 2</div><div class="line"> </div><div class="line"><span class="meta">#</span> 更多的命令可以用 free --help 来查看。</div></pre></td></tr></table></figure>
<p>名词解释</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> 说明示例</div><div class="line">             total       used       free     shared    buffers     cached</div><div class="line">Mem:          244M       232M        12M         0B        33M        69M</div><div class="line">-/+ buffers/cache:       129M       115M</div><div class="line">Swap:         627M       1.7M       626M</div><div class="line"><span class="meta">#</span> Mem 行，表示物理内存统计</div><div class="line">total :系统 总物理内存</div><div class="line">used :系统 已分配物理内存（但非全部都在使用，包含buffers好cached）</div><div class="line">free :系统 未分配物理内存</div><div class="line">shared :系统 共享内存，一般都是 0</div><div class="line">buffers :系统 分配但未使用的 buffers数量</div><div class="line">cached :系统 分配但未使用的 cached数量</div><div class="line"> </div><div class="line"><span class="meta">#</span> -/+ buffers/cache 行，表示物理内存的缓存统计</div><div class="line">used :系统 实际使用的内存</div><div class="line"><span class="meta">#</span> user= Mem行 used-buffers-cached（232-33-69=130，因单位转换问题 所以会有一点差距）</div><div class="line">free :系统 实际可用的内存</div><div class="line"><span class="meta">#</span> free= Mem行 free+buffers+cached（12+33+69=114，因单位转换问题 所以会有一点差距）</div><div class="line"> </div><div class="line"><span class="meta">#</span> 所以我们看系统的真实 使用/剩余内存 只需要看这一行即可！</div><div class="line"> </div><div class="line"><span class="meta">#</span> Swap 行，表示硬盘的交换分区（虚拟内存）统计</div><div class="line">total :系统 总虚拟内存</div><div class="line">used :系统 已分配虚拟内存</div><div class="line">free :系统 未分配虚拟内存</div><div class="line"> </div><div class="line"><span class="meta">#</span> KVM虚拟化的VPS，可以用这个教程手动添加 SWAP虚拟内存：https://doub.bid/linux-jc7/</div></pre></td></tr></table></figure>
<h3 id="date-查看-设置-系统时间"><a href="#date-查看-设置-系统时间" class="headerlink" title="date 查看/设置 系统时间"></a>date 查看/设置 系统时间</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div></pre></td><td class="code"><pre><div class="line"> -d ：以指定的时间格式 显示时间</div><div class="line"> -f ：显示 DATE FILE文件中的每行时间（我也不懂）</div><div class="line"> -r ：显示 文件/文件夹 最后修改时间</div><div class="line"> -s ：设置 系统时间</div><div class="line"> -u ：显示 UTC时间</div><div class="line"> </div><div class="line"><span class="meta">#</span> 时间格式</div><div class="line"> </div><div class="line"><span class="meta">%</span>% - 显示字符%</div><div class="line"><span class="meta">%</span>a - 星期几的缩写(Sun..Sat)</div><div class="line"><span class="meta">%</span>A - 星期几的完整名称（Sunday...Saturday）</div><div class="line"><span class="meta">%</span>b - 月份的缩写(Jan..Dec)</div><div class="line"><span class="meta">%</span>B - 月份的完整名称(January..December)</div><div class="line"><span class="meta">%</span>c - 日期与时间。只输入date指令也会显示同样的结果</div><div class="line"><span class="meta">%</span>C - 世纪(年份除100后去整) [00-99]</div><div class="line"><span class="meta">%</span>d - 日期(以01-31来表示)。</div><div class="line"><span class="meta">%</span>D - 日期(含年月日)。</div><div class="line"><span class="meta">%</span>e - 一个月的第几天 ( 1..31)</div><div class="line"><span class="meta">%</span>F - 日期，同%Y-%m-%d</div><div class="line"><span class="meta">%</span>g - 年份(yy)</div><div class="line"><span class="meta">%</span>G - 年份(yyyy)</div><div class="line"><span class="meta">%</span>h - 同%b</div><div class="line"><span class="meta">%</span>H - 小时(00..23)</div><div class="line"><span class="meta">%</span>I - 小时(01..12)</div><div class="line"><span class="meta">%</span>j - 一年的第几天(001..366)</div><div class="line"><span class="meta">%</span>k - 小时( 0..23)</div><div class="line"><span class="meta">%</span>l - 小时( 1..12)</div><div class="line"><span class="meta">%</span>m - 月份(01..12)</div><div class="line"><span class="meta">%</span>M - 分钟(00..59)</div><div class="line"><span class="meta">%</span>n - 换行</div><div class="line"><span class="meta">%</span>N - 纳秒(000000000..999999999)</div><div class="line"><span class="meta">%</span>p - AM or PM</div><div class="line"><span class="meta">%</span>P - am or pm</div><div class="line"><span class="meta">%</span>r - 12小时制时间(hh:mm:ss [AP]M)</div><div class="line"><span class="meta">%</span>R - 24小时制时间(hh:mm)</div><div class="line"><span class="meta">%</span>s - 从00:00:00 1970-01-01 UTC开始的秒数</div><div class="line"><span class="meta">%</span>S - 秒(00..60)</div><div class="line"><span class="meta">%</span>t - 制表符</div><div class="line"><span class="meta">%</span>T - 24小时制时间(hh:mm:ss)</div><div class="line"><span class="meta">%</span>u - 一周的第几天(1..7); 1 表示星期一</div><div class="line"><span class="meta">%</span>U - 一年的第几周，周日为每周的第一天(00..53)</div><div class="line"><span class="meta">%</span>V - 一年的第几周，周一为每周的第一天 (01..53)</div><div class="line"><span class="meta">%</span>w - 一周的第几天 (0..6); 0 代表周日</div><div class="line"><span class="meta">%</span>W - 一年的第几周，周一为每周的第一天(00..53)</div><div class="line"><span class="meta">%</span>x - 日期(mm/dd/yy)</div><div class="line"><span class="meta">%</span>X - 时间(%H:%M:%S)</div><div class="line"><span class="meta">%</span>y - 年份(00..99)</div><div class="line"><span class="meta">%</span>Y - 年份 (1970…)</div><div class="line"><span class="meta">%</span>z - RFC-2822 风格数字格式时区(-0500)</div><div class="line"><span class="meta">%</span>Z - 时区(e.g., EDT), 无法确定时区则为空</div><div class="line"> </div><div class="line"><span class="meta">#</span> 更多的命令可以用 date --help 来查看。</div><div class="line">使用示例：</div><div class="line"></div><div class="line"><span class="meta">#</span> 显示 当前系统时间</div><div class="line">date</div><div class="line"><span class="meta">#</span> 输出：Wed Apr 5 12:38:44 CST 2017</div><div class="line"> </div><div class="line"><span class="meta">#</span> 显示当前系统的 UTC时间</div><div class="line">date -u</div><div class="line"><span class="meta">#</span> 输出：Wed Apr 5 04:30:06 UTC 2017</div><div class="line"><span class="meta">#</span> 显示 log.txt 文件的最后修改时间</div><div class="line">date -r log.txt</div><div class="line"><span class="meta">#</span> 显示 当前日期的年份</div><div class="line">date +%Y</div><div class="line"><span class="meta">#</span> 输出：2017</div><div class="line"> </div><div class="line"><span class="meta">#</span> 显示 当前日期的月份</div><div class="line">date +%m</div><div class="line"><span class="meta">#</span> 输出：4</div><div class="line"> </div><div class="line"><span class="meta">#</span> 显示 各种格式类型的日期</div><div class="line">date +%D</div><div class="line"><span class="meta">#</span> 输出：04/05/17</div><div class="line"> </div><div class="line">date +%Y-%m-%d</div><div class="line"><span class="meta">#</span> 输出：2017-04-05</div><div class="line"> </div><div class="line">date +%m/%d/%y</div><div class="line"><span class="meta">#</span> 输出：04/05/17</div><div class="line"> </div><div class="line">date +%m/%d/%Y</div><div class="line"><span class="meta">#</span> 输出：04/05/2017</div><div class="line"> </div><div class="line"><span class="meta">#</span> 显示 Unix时间戳</div><div class="line">date +%s</div><div class="line"><span class="meta">#</span> 输出：1491367399</div><div class="line"> </div><div class="line"><span class="meta">#</span> 显示一个完整的时间（年、月、日、小时、分钟、秒钟、周几 时区）</div><div class="line">date "+%Y-%m-%d %H:%I:%S %u %Z"</div><div class="line"><span class="meta">#</span> 输出：2017-04-05 12:12:15 3 CST</div><div class="line"> </div><div class="line"><span class="meta">#</span> 设置 系统时间（年、月、日）</div><div class="line">date -s "2017-04-05"</div><div class="line"> </div><div class="line"><span class="meta">#</span> 设置 系统时间（小时、分钟、秒钟）</div><div class="line">date -s "10:29:05"</div><div class="line"> </div><div class="line"><span class="meta">#</span> 设置 系统时间（年、月、日、小时、分钟、秒钟）</div><div class="line">date -s "2017-04-05 10:29:05"</div><div class="line"> </div><div class="line"><span class="meta">#</span> 更多的命令可以用 date --help 来查看。</div><div class="line">再教你们一个修改时区为上海（北京）时区的方法：</div><div class="line"></div><div class="line">cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</div><div class="line">然后再用 date 查看时间，就会发现时区变为 CST 了。</div></pre></td></tr></table></figure>
<h3 id="chmod-修改-文件-文件夹-权限"><a href="#chmod-修改-文件-文件夹-权限" class="headerlink" title="chmod 修改 文件/文件夹 权限"></a>chmod 修改 文件/文件夹 权限</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">-c :只输出被改变权限的文件信息</div><div class="line">-f :当chmod不能改变文件模式时，不通知文件的用户</div><div class="line">-R :可递归遍历子目录，把修改应到目录下所有文件和子目录</div><div class="line">-v :无论修改是否成功，输出每个文件的信息</div><div class="line"> </div><div class="line"><span class="meta">#</span> 操作符号：</div><div class="line"> </div><div class="line">+ :添加某个权限。</div><div class="line">- :取消某个权限。</div><div class="line">= :赋予给定权限并取消其他所有权限（如果有的话）。</div><div class="line"> </div><div class="line"><span class="meta">#</span> 权限设置字母：</div><div class="line"> </div><div class="line">r :可读</div><div class="line">w :可写</div><div class="line">x :可执行</div><div class="line">X :只有目标文件对某些用户是可执行的或该目标文件是目录时才追加x 属性</div><div class="line">s :在文件执行时把进程的属主或组ID置为该文件的文件属主。方式“u＋s”设置文件的用户ID位，“g＋s”设置组ID位</div><div class="line">t :保存程序的文本到交换设备上</div><div class="line">u :当前用户的权限</div><div class="line">g :当前用户同组的权限</div><div class="line">o :其他用户的权限</div><div class="line"> </div><div class="line"><span class="meta">#</span> 权限设定数字：</div><div class="line"> </div><div class="line"><span class="meta">#</span> 数字表示的属性含义：</div><div class="line">0 ：表示没有权限</div><div class="line">1 ：表示可执行权限</div><div class="line">2 ：表示可写权限</div><div class="line">4 ：表示可读权限</div><div class="line"> </div><div class="line"><span class="meta">#</span> 然后将其相加，所以数字属性的格式应为3个从0到7的八进制数，其顺序是（u）（g）（o）。</div><div class="line"><span class="meta">#</span> 如果想让某个文件的属主有“读/写”二种权限，需要把4（可读）+2（可写）＝6（读/写）。</div><div class="line"> </div><div class="line"><span class="meta">#</span> 更多的命令可以用 chmod --help 来查看。</div><div class="line">使用示例：</div><div class="line"></div><div class="line"><span class="meta">#</span> 当需要运行 可执行的脚本或者程序（比如 Go语言编写的软件）的时候，需要赋予执行权限</div><div class="line">chmod +x ssr.sh</div><div class="line"> </div><div class="line"><span class="meta">#</span> 赋予 log.txt 文件可读权限</div><div class="line">chmod 444 log.txt</div><div class="line"> </div><div class="line"><span class="meta">#</span> 赋予 /ver/log 文件夹 可读、可写权限</div><div class="line">chmod 666 log.txt</div><div class="line"> </div><div class="line"><span class="meta">#</span> 赋予 /home/www 文件夹 可读、可写、可执行权限</div><div class="line">chmod 777 log.txt</div><div class="line"> </div><div class="line"><span class="meta">#</span> 赋予 /home/www 文件夹极其所有子目录和文件 可读、可写、可执行权限</div><div class="line">chmod -R 777 log.txt</div><div class="line"><span class="meta">#</span> 更多的命令可以用 chmod --help 来查看。</div></pre></td></tr></table></figure>
<h3 id="uname-获取操作系统信息"><a href="#uname-获取操作系统信息" class="headerlink" title="uname 获取操作系统信息"></a>uname 获取操作系统信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">-a：显示 全部信息</div><div class="line">-m：显示 系统位数</div><div class="line">-n：显示 主机名称</div><div class="line">-r：显示 操作系统的发行编号</div><div class="line">-s：显示 操作系统的名称</div><div class="line">-v：显示 操作系统的版本</div><div class="line">-p：输出 处理器类型 或"unknown"</div><div class="line">-i：输出 硬件平台 或"unknown"</div><div class="line">-o：输出 操作系统名称</div><div class="line"> </div><div class="line"><span class="meta">#</span> 更多的命令可以用 uname --help 来查看</div><div class="line"></div><div class="line"><span class="meta">#</span> 示例</div><div class="line"></div><div class="line"><span class="meta">#</span>在使用 uname 的时候，相当于是使用 uname -s</div><div class="line">uname</div><div class="line">uname -a</div><div class="line">uname -m      </div><div class="line">uname -n</div><div class="line">uname -r</div><div class="line">uname -s</div><div class="line">uname -v</div><div class="line">uname -p</div><div class="line">uname -i</div><div class="line">uname -o</div></pre></td></tr></table></figure>
<h3 id="df-du-获取磁盘信息"><a href="#df-du-获取磁盘信息" class="headerlink" title="df du 获取磁盘信息"></a>df du 获取磁盘信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> 查看磁盘各分区信息</div><div class="line">df -h</div><div class="line"><span class="meta">#</span> 查看foo目录的大小</div><div class="line">du -sh foo</div><div class="line"><span class="meta">#</span> 查看当前目录各个文件、目录的大小</div><div class="line">du -sh *</div></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://doub.bid/linux-jc8/" target="_blank" rel="external">Linux 常用命令简单介绍 —— 基础篇</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;包管理器&quot;&gt;&lt;a href=&quot;#包管理器&quot; class=&quot;headerlink&quot; title=&quot;包管理器&quot;&gt;&lt;/a&gt;包管理器&lt;/h2&gt;&lt;h3 id=&quot;apt-get&quot;&gt;&lt;a href=&quot;#apt-get&quot; class=&quot;headerlink&quot; title=&quot;apt
    
    </summary>
    
      <category term="Linux" scheme="https://blog.ajavac.com/categories/Linux/"/>
    
    
      <category term="Basic" scheme="https://blog.ajavac.com/tags/Basic/"/>
    
      <category term="Linux" scheme="https://blog.ajavac.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Mac OS 日常记录</title>
    <link href="https://blog.ajavac.com/2017/04/08/Common/mac/"/>
    <id>https://blog.ajavac.com/2017/04/08/Common/mac/</id>
    <published>2017-04-08T10:34:45.000Z</published>
    <updated>2017-06-25T13:13:07.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="科学上网"><a href="#科学上网" class="headerlink" title="科学上网"></a>科学上网</h2><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>ShadowsocksX-NG</p>
<h3 id="单独设置git的代理"><a href="#单独设置git的代理" class="headerlink" title="单独设置git的代理"></a>单独设置git的代理</h3><h4 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">git config --global https.proxy http://127.0.0.1:1080</div><div class="line"></div><div class="line">git config --global https.proxy https://127.0.0.1:1080</div><div class="line"></div><div class="line"><span class="meta">#</span> socks5</div><div class="line">git config --global http.proxy 'socks5://127.0.0.1:1080'</div><div class="line">git config --global https.proxy 'socks5://127.0.0.1:1080'</div></pre></td></tr></table></figure>
<h4 id="取消代理"><a href="#取消代理" class="headerlink" title="取消代理"></a>取消代理</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git config --global --unset http.proxy</div><div class="line"></div><div class="line">git config --global --unset https.proxy</div></pre></td></tr></table></figure>
<h3 id="设置终端的代理"><a href="#设置终端的代理" class="headerlink" title="设置终端的代理"></a>设置终端的代理</h3><h4 id="临时代理"><a href="#临时代理" class="headerlink" title="临时代理"></a>临时代理</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> 命令执行中,一次性的代理</div><div class="line">http_proxy=http://localhost:1087 curl www.google.com</div><div class="line">https_proxy=http://localhost:1087 curl https://www.google.com</div><div class="line"><span class="meta">#</span> 终端使用过程中,一次性的代理</div><div class="line">export http_proxy=http://127.0.0.1:1087 https_proxy=http://127.0.0.1:1087</div></pre></td></tr></table></figure>
<h4 id="永久全局代理"><a href="#永久全局代理" class="headerlink" title="永久全局代理"></a>永久全局代理</h4><p>在.zshrc等文件最后添加以下环境变量<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export http_proxy=http://127.0.0.1:1087 https_proxy=http://127.0.0.1:1087</div></pre></td></tr></table></figure></p>
<h4 id="自定义代理命令"><a href="#自定义代理命令" class="headerlink" title="自定义代理命令"></a>自定义代理命令</h4><p>在.zshrc等文件最后添加以下别名设置<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alias proxy='export http_proxy=http://127.0.0.1:1087 https_proxy=http://127.0.0.1:1087'</div></pre></td></tr></table></figure></p>
<p>以后需要代理的时候只要输入proxy命令,当前终端下之后的命令执行都会进行代理</p>
<h2 id="语言选择"><a href="#语言选择" class="headerlink" title="语言选择"></a>语言选择</h2><blockquote>
<p>如果在首次使用 mac OS 的时候选择了中文作为第一语言，然后之后又设置英文作为操作系统第一语言，每次系统更新之后都可能出现部分系统界面显示中文（关机、重启、登录）</p>
</blockquote>
<p>解决办法如下（在终端中输入命令）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo "/System/Library/CoreServices/Language Chooser.app/Contents/MacOS/Language Chooser"</div></pre></td></tr></table></figure>
<p>然后重新选择第一语言，问题解决</p>
<h2 id="常用软件"><a href="#常用软件" class="headerlink" title="常用软件"></a>常用软件</h2><ol>
<li>Home Brew</li>
<li>Home Brew Cask</li>
<li>Alfred</li>
</ol>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;科学上网&quot;&gt;&lt;a href=&quot;#科学上网&quot; class=&quot;headerlink&quot; title=&quot;科学上网&quot;&gt;&lt;/a&gt;科学上网&lt;/h2&gt;&lt;h3 id=&quot;工具&quot;&gt;&lt;a href=&quot;#工具&quot; class=&quot;headerlink&quot; title=&quot;工具&quot;&gt;&lt;/a&gt;工具&lt;/h
    
    </summary>
    
      <category term="Mac" scheme="https://blog.ajavac.com/categories/Mac/"/>
    
    
      <category term="Mac" scheme="https://blog.ajavac.com/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>《Effective Java》读书笔记——第3章</title>
    <link href="https://blog.ajavac.com/2017/03/27/EffectiveJava/chapter3/"/>
    <id>https://blog.ajavac.com/2017/03/27/EffectiveJava/chapter3/</id>
    <published>2017-03-27T15:13:02.000Z</published>
    <updated>2017-04-09T08:24:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对于所有对象都通用的方法"><a href="#对于所有对象都通用的方法" class="headerlink" title="对于所有对象都通用的方法"></a>对于所有对象都通用的方法</h2><h3 id="No-8-覆盖equals时请遵守通用约定"><a href="#No-8-覆盖equals时请遵守通用约定" class="headerlink" title="No.8 覆盖equals时请遵守通用约定"></a>No.8 覆盖equals时请遵守通用约定</h3><blockquote>
<p>类具有自己特有的”逻辑相等”概念时应该覆盖Object.equals方法</p>
</blockquote>
<p>覆盖equals时，必须要遵守它的通用约定：</p>
<ol>
<li>自反性（reflexive）对于任何非null的引用值x，x.equals(x)必须为true</li>
<li>对称性（symmetric）对于任何非null的引用值x和y，当且仅当x.equals(y)为true时，y.equals(x)必须返回true</li>
<li>传递性（transitive）对于任何非null的引用值x、y和z，如果x.equals(y)为true，并且y.equals(z)为true，那么x.equals(z)也必须为true</li>
<li>一致性（consistent）只要操作对象信息未被修改，多次调用equals结果必须一致</li>
<li>非空性（Non-nullity）对于任何非null的引用值x，x.equals(null)必须为false</li>
</ol>
<p>实现高质量equals方法的诀窍：</p>
<ol>
<li>使用<code>==</code>检查“参数是否为这个对象的引用”</li>
<li>使用<code>instanceof</code>检查”参数是否为正确类型”</li>
<li>把参数转换成正确类型</li>
<li>检查参数中的关键（significant）域与该对象中对应的域是否相匹配</li>
<li>检查是否达到了对称性、传递性、一致性的要求</li>
<li>覆盖equals时总要覆盖hashCode</li>
<li>不要企图让equals方法过于智能</li>
<li>不要将equals声明中的Object对象替换成其他的类型</li>
<li>使用<code>@Override</code>注解</li>
</ol>
<h3 id="No-9-覆盖equals时总要覆盖hashCode"><a href="#No-9-覆盖equals时总要覆盖hashCode" class="headerlink" title="No.9 覆盖equals时总要覆盖hashCode"></a>No.9 覆盖equals时总要覆盖hashCode</h3><blockquote>
<p>每个覆盖了equals方法的类中，也必须覆盖hashCode方法</p>
</blockquote>
<p>约定：</p>
<ol>
<li>应用程序的一次执行中，对同一个对象的调用多次，hashCode方法必须始终如一的返回同一个整数。在同一个程序的多次执行过程中，每次执行锁返回的整数可以不一致</li>
<li>如果两个对象的根据equals方法比较是相等的，那么调用它们的hashCode方法的整数结果也必须相等</li>
<li>如果两个对象的根据equals方法比较是不相等的，那么调用它们的hashCode方法的整数结果不一定要不相等</li>
</ol>
<p>推荐散列算法:</p>
<ol>
<li><code>int result = 17;</code></li>
<li>为所有的域分别计算<code>int</code>类型的散列码(若是对象则调用其<code>hashCode()</code>方法):<ol>
<li><code>boolean</code>类型：<code>f ? 1 : 0</code></li>
<li><code>byte</code>、<code>char</code>、<code>short</code>、<code>int</code>类型：<code>(int) f</code></li>
<li><code>long</code>类型：<code>(int) (f ^ (f &gt;&gt;&gt; 32))</code></li>
<li><code>float</code>类型：<code>Float.floatToIntBits(f)</code></li>
<li><code>double</code>类型：<code>Double.doubleToLongBits(f)</code>后按<code>long</code>类型处理</li>
<li>引用类型(对象)：调用其<code>hashCode()</code>方法（若域为<code>null</code>则为0）</li>
<li>数组类型：对每个元素当做单独的域处理或者使用<code>Arrays.hashCode()</code>方法</li>
</ol>
</li>
<li>将每个域计算出的散列码合并：<code>result = 31 * result + c;</code></li>
<li>返回<code>result</code></li>
<li>验证该散列算法是否符合约定，“相等的实例是否都具有相等的散列码”</li>
</ol>
<p>总结：</p>
<ol>
<li><strong>相等的对象具有相等的散列码</strong></li>
<li><strong>不相等的对象的散列码不一定不相等</strong></li>
<li>不要试图从散列码计算中排除掉一个对象的关键部分来提高性能</li>
<li>一个比较好的散列算法：<code>31*i</code>，因为<code>31*i == (i &lt;&lt; 5) - 1</code></li>
</ol>
<h3 id="No-10-始终要覆盖toString"><a href="#No-10-始终要覆盖toString" class="headerlink" title="No.10 始终要覆盖toString"></a>No.10 始终要覆盖toString</h3><blockquote>
<p>toString 方法旨在返回一个”简洁的，但信息丰富，并且易于阅读的表达形式”，建议所有的子类都覆盖这个方法</p>
</blockquote>
<ol>
<li>toString 方法应该返回对象中包含的所有值得关注的信息</li>
<li>当对象被传递给println、printf、字符串级联操作符（+）、assert、调试器打印等情况时，toString方法会被自动调用</li>
</ol>
<h3 id="No-11-谨慎地覆盖clone"><a href="#No-11-谨慎地覆盖clone" class="headerlink" title="No.11 谨慎地覆盖clone"></a>No.11 谨慎地覆盖clone</h3><ol>
<li>所有实现了Cloneable接口的类都应该用一个公有的方法覆盖clone，此公有方法1首先应该调用<code>super.clone()</code>，然后修正任何需要修正的域。</li>
<li>其他接口都不应该扩展（extends）这个接口（Cloneable）</li>
<li>为了继承而设计的类也不应该实现（implement）这个接口（Cloneable）</li>
</ol>
<h3 id="No-12-考虑实现Comparable接口"><a href="#No-12-考虑实现Comparable接口" class="headerlink" title="No.12 考虑实现Comparable接口"></a>No.12 考虑实现Comparable接口</h3><ol>
<li>对实现了Comparable接口的对象数组a进行排序只需要<code>Arrays.sort(a);</code></li>
<li>如果在编写一个值类，它具有非常明显的内在排序关系，那么应该坚决考虑实现这个接口</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;对于所有对象都通用的方法&quot;&gt;&lt;a href=&quot;#对于所有对象都通用的方法&quot; class=&quot;headerlink&quot; title=&quot;对于所有对象都通用的方法&quot;&gt;&lt;/a&gt;对于所有对象都通用的方法&lt;/h2&gt;&lt;h3 id=&quot;No-8-覆盖equals时请遵守通用约定&quot;&gt;&lt;a
    
    </summary>
    
      <category term="book" scheme="https://blog.ajavac.com/categories/book/"/>
    
    
      <category term="Java" scheme="https://blog.ajavac.com/tags/Java/"/>
    
      <category term="Effective_Java" scheme="https://blog.ajavac.com/tags/Effective-Java/"/>
    
      <category term="book" scheme="https://blog.ajavac.com/tags/book/"/>
    
  </entry>
  
  <entry>
    <title>Java 8 新特性</title>
    <link href="https://blog.ajavac.com/2017/03/26/Java/java8/"/>
    <id>https://blog.ajavac.com/2017/03/26/Java/java8/</id>
    <published>2017-03-26T10:35:55.000Z</published>
    <updated>2017-03-27T08:25:44.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Oracle 公司于 2014 年 3 月 18 日发布 Java 8 ，添加了许多新特性</p>
</blockquote>
<table>
<thead>
<tr>
<th>序号</th>
<th>特性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Lambda表达式</td>
<td>允许函数作为参数传递给方法</td>
</tr>
<tr>
<td>2</td>
<td>默认方法</td>
<td>在接口里面实现方法</td>
</tr>
<tr>
<td>3</td>
<td>方法引用</td>
<td>简化代码</td>
</tr>
<tr>
<td>4</td>
<td>函数式接口</td>
<td>使Java支持真正的函数式编程</td>
</tr>
<tr>
<td>5</td>
<td>Stream</td>
<td>使Java支持真正的函数式编程</td>
</tr>
<tr>
<td>6</td>
<td>Base64</td>
<td>提供Base64编码、解码方法</td>
</tr>
<tr>
<td>7</td>
<td>Optional类</td>
<td>用来解决NullPointException</td>
</tr>
<tr>
<td>8</td>
<td>新日期时间API</td>
<td>使用方便程度不如<code>joda-time</code></td>
</tr>
<tr>
<td>9</td>
<td>Nashorn JavaScript 引擎</td>
<td>新JS引擎，一般情况下用不上</td>
</tr>
</tbody>
</table>
<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 类型声明</span></div><div class="line">(<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; a + b;</div><div class="line"><span class="comment">// 类型不声明</span></div><div class="line">(a, b) -&gt; a + b;</div><div class="line"><span class="comment">// 大括号,超过一行表达式的情况下必须要大括号</span></div><div class="line">(a, b) -&gt; &#123; <span class="keyword">return</span> a + b;&#125;;</div><div class="line"><span class="comment">// 最简情况下不需要括号</span></div><div class="line">a -&gt; <span class="number">3</span>*a;</div></pre></td></tr></table></figure>
<h2 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h2><blockquote>
<p>默认方法就是借口可以实现方法，其实现类可以不实现该方法。目的是为了解决接口的修改与现有的实现不兼容的问题。</p>
</blockquote>
<ol>
<li>默认接口方法：使用<code>default</code>关键字标识</li>
<li>默认静态方法：使用<code>static</code>关键字标识</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 用例</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Test</span> </span>&#123;</div><div class="line">  </div><div class="line">  <span class="comment">// 默认接口方法</span></div><div class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">defaultMethod</span><span class="params">()</span></span>&#123;</div><div class="line">    System.out.println(<span class="string">"Test default"</span>);</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">// 默认静态方法</span></div><div class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span></span>&#123;</div><div class="line">    System.out.println(<span class="string">"Test static"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><ol>
<li>构造器引用：<code>Test::new</code></li>
<li>方法引用：<code>Test::test</code></li>
</ol>
<h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><blockquote>
<p>函数式接口就是一个具有一个方法的普通接口，可以被隐式转换为lambda表达式</p>
</blockquote>
<p>JDK 8 新增了许多函数式接口在<code>java.util.function</code>中</p>
<h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><blockquote>
<p>Java 8 新增了一个概念称为流Stream，可以以一种声明的方式处理数据</p>
</blockquote>
<p>生成流的方法：</p>
<ol>
<li>串行流：stream()</li>
<li>并行流：parallelStream()</li>
</ol>
<p>流的方法：</p>
<ol>
<li>遍历：forEach()</li>
<li>映射每个元素对应的结果：map()</li>
<li>过滤出元素：filter()</li>
<li>指定获取数量：limit()</li>
<li>排序：sorted()</li>
<li>将流转换为集合：collect()</li>
<li>统计：summaryStatistics()</li>
<li>计算个数：count()</li>
</ol>
<h2 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h2><blockquote>
<p>Java 8 内置了三种Base64编解码器</p>
</blockquote>
<h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><blockquote>
<p>输出被映射到一组字符A-Za-z0-9+/，编码不添加任何行标，输出的解码仅支持A-Za-z0-9+/</p>
</blockquote>
<p>编码器：<code>Base64.getEncoder()</code></p>
<p>解码器：<code>Base64.getDecoder()</code></p>
<h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><blockquote>
<p>输出映射到一组字符A-Za-z0-9+_，输出是URL和文件</p>
</blockquote>
<p>编码器：<code>Base64.getUrlEncoder()</code></p>
<p>解码器：<code>Base64.getUrlDecoder()</code></p>
<h3 id="MIME"><a href="#MIME" class="headerlink" title="MIME"></a>MIME</h3><blockquote>
<p>输出映射到MIME友好格式。输出每行不超过76字符，并且使用’\r’并跟随’\n’作为分割。编码输出最后没有行分割</p>
</blockquote>
<p>编码器：<code>Base64.getMimeEncoder()</code></p>
<p>解码器：<code>Base64.getMimeDecoder()</code></p>
<h2 id="Optional类"><a href="#Optional类" class="headerlink" title="Optional类"></a>Optional类</h2><blockquote>
<p>Optional类的引入很好的解决空指针异常</p>
</blockquote>
<h2 id="新日期时间API"><a href="#新日期时间API" class="headerlink" title="新日期时间API"></a>新日期时间API</h2><blockquote>
<p>旧的Java中日期时间API设计比较差（非线程安全、设计差、时区处理麻烦），所以提出了新的日期时间API</p>
</blockquote>
<p>Java 8 在<code>java.time</code>包下提供了许多新的日期时间API，主要有</p>
<ol>
<li><code>java.time.LocalDate</code></li>
<li><code>java.time.LocalTime</code></li>
<li><code>java.time.LocalDateTime</code></li>
<li><code>java.time.ZonedDateTime</code></li>
</ol>
<p>PS：个人觉得还是<code>joda-time</code>使用方便</p>
<h2 id="Nashorn-JavaScript-引擎"><a href="#Nashorn-JavaScript-引擎" class="headerlink" title="Nashorn JavaScript 引擎"></a>Nashorn JavaScript 引擎</h2><blockquote>
<p>一个JavaScript引擎，用来在Java中调用JavaScript或者在JavaScript中调用Java。与之前的Rhino实现相比，带来2到10倍的性能提升。一般开发不怎么用到。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Oracle 公司于 2014 年 3 月 18 日发布 Java 8 ，添加了许多新特性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;序号&lt;/th&gt;
&lt;th&gt;特性&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/t
    
    </summary>
    
      <category term="Java" scheme="https://blog.ajavac.com/categories/Java/"/>
    
    
      <category term="Java" scheme="https://blog.ajavac.com/tags/Java/"/>
    
      <category term="Basic" scheme="https://blog.ajavac.com/tags/Basic/"/>
    
  </entry>
  
  <entry>
    <title>JDK之String</title>
    <link href="https://blog.ajavac.com/2017/03/26/Java/jdk_string/"/>
    <id>https://blog.ajavac.com/2017/03/26/Java/jdk_string/</id>
    <published>2017-03-26T10:35:55.000Z</published>
    <updated>2017-05-15T06:07:49.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p><code>java.lang.String</code>是Java编程中最常见的类之一</p>
<p>Java中使用Unicode字符集，使用UTF-16的编码实现方式，一个基本多语言平面（Basic Multilingual Plane，简称BMP）字符占用一个char（16bit），一个辅助平面（Supplementary Plane）字符占用两个char（16bit * 2）。</p>
<p>比如说emoji表情就占用了两个char</p>
</blockquote>
<h2 id="String的特点"><a href="#String的特点" class="headerlink" title="String的特点"></a>String的特点</h2><ol>
<li>是一个不可变类，一旦创建便不可改变</li>
<li>类定义为<code>public final class String</code>，是一个终类，不可被继承</li>
<li>实现了<code>java.io.Serializable</code>接口，可序列化和反序列化</li>
<li>实现了<code>java.lang.Comparable&lt;String&gt;</code>接口，可以进行比较和排序</li>
<li>实现了<code>java.lang.CharSequence</code>接口，是一个可读的字符序列</li>
<li>String最多可存储<code>2^31-1</code>个char(每个char占用16bit)</li>
<li>String最多可存储<code>(2^30-1)~(2^31-1)</code>个Unicode字符，原因在于Java中的Unicode编码方式（UTF-16），一个Unicode字符最多可能占用2个char</li>
</ol>
<p>​</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol>
<li><code>length()</code>方法获取的是String字符串中char的长度</li>
<li>String不宜直接存储密码等敏感数据，有dump风险，可用<code>char[]</code>存储（用完后清除），或者对敏感数据进行加盐hash</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;java.lang.String&lt;/code&gt;是Java编程中最常见的类之一&lt;/p&gt;
&lt;p&gt;Java中使用Unicode字符集，使用UTF-16的编码实现方式，一个基本多语言平面（Basic Multilingual Plane，简称B
    
    </summary>
    
      <category term="Java" scheme="https://blog.ajavac.com/categories/Java/"/>
    
    
      <category term="Java" scheme="https://blog.ajavac.com/tags/Java/"/>
    
      <category term="Basic" scheme="https://blog.ajavac.com/tags/Basic/"/>
    
  </entry>
  
  <entry>
    <title>Java基础</title>
    <link href="https://blog.ajavac.com/2017/03/25/Java/java_basic/"/>
    <id>https://blog.ajavac.com/2017/03/25/Java/java_basic/</id>
    <published>2017-03-25T13:55:25.000Z</published>
    <updated>2017-06-07T08:14:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="内置类型——基本数据类型"><a href="#内置类型——基本数据类型" class="headerlink" title="内置类型——基本数据类型"></a>内置类型——基本数据类型</h3><table>
<thead>
<tr>
<th>名称</th>
<th>大小</th>
<th>默认值</th>
<th>取值说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean</td>
<td>1bit</td>
<td><code>false</code></td>
<td>布尔值，作二元判断，<code>true</code>或者<code>false</code></td>
</tr>
<tr>
<td>byte</td>
<td>8bit</td>
<td><code>0x00</code></td>
<td>有符号整数，范围<code>-128 ~ 127</code>，转换成int时需注意高位补齐</td>
</tr>
<tr>
<td>short</td>
<td>16bit</td>
<td><code>0</code></td>
<td>有符号整数，范围<code>-32768 ~ 32767</code></td>
</tr>
<tr>
<td>char</td>
<td>16bit</td>
<td><code>\u0000</code></td>
<td>Unicode字符，少数字符使用2个<code>char</code>表示</td>
</tr>
<tr>
<td>int</td>
<td>32bit</td>
<td><code>0</code></td>
<td>有符号整数，范围<code>-2^31 ~ (2^31 - 1)</code></td>
</tr>
<tr>
<td>float</td>
<td>32bit</td>
<td><code>0.0F</code></td>
<td>浮点数，范围<code>1.4E-45~3.4028235E38</code></td>
</tr>
<tr>
<td>long</td>
<td>64bit</td>
<td><code>0L</code></td>
<td>有符号整数，范围<code>-2^63 ~ (2^63 - 1)</code></td>
</tr>
<tr>
<td>double</td>
<td>64bit</td>
<td><code>0.0D</code></td>
<td>浮点数，范围<code>4.9E-324~1.7976931348623157E308</code></td>
</tr>
</tbody>
</table>
<p>ps：浮点数有精度，要不失真使用<code>java.math.BigDecimal</code>和<code>java.math.BigInteger</code></p>
<h3 id="扩展类型——引用数据类型"><a href="#扩展类型——引用数据类型" class="headerlink" title="扩展类型——引用数据类型"></a>扩展类型——引用数据类型</h3><p>形如:</p>
<p><code>String str = &quot;I am a String !&quot;;</code></p>
<h2 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h2><p>面向对象编程有三大特性：</p>
<ol>
<li>封装</li>
<li>继承</li>
<li>多态</li>
</ol>
<h2 id="类访问权限"><a href="#类访问权限" class="headerlink" title="类访问权限"></a>类访问权限</h2><table>
<thead>
<tr>
<th></th>
<th style="text-align:center">同一个类</th>
<th style="text-align:center">同一个包</th>
<th style="text-align:center">不同包的子类</th>
<th style="text-align:center">不同包的非子类</th>
</tr>
</thead>
<tbody>
<tr>
<td>private</td>
<td style="text-align:center">✔️</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>default</td>
<td style="text-align:center">✔️</td>
<td style="text-align:center">✔️</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>protected</td>
<td style="text-align:center">✔️</td>
<td style="text-align:center">✔️</td>
<td style="text-align:center">✔️</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>public</td>
<td style="text-align:center">✔️</td>
<td style="text-align:center">✔️</td>
<td style="text-align:center">✔️</td>
<td style="text-align:center">✔️</td>
</tr>
</tbody>
</table>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><blockquote>
<p>所谓多态意指相同的消息给予不同的对象会引发不同的动作称之。</p>
<p> ——维基百科</p>
</blockquote>
<p>存在的必要条件：</p>
<ol>
<li>继承</li>
<li>重写</li>
<li>向上转型（父类引用指向子类对象）</li>
</ol>
<p>实现方式：</p>
<ol>
<li>重写</li>
<li>接口</li>
<li>抽象类和抽象方法</li>
</ol>
<p>比如：<code>List&lt;String&gt; list = new ArrayList&lt;&gt;)();</code></p>
<h2 id="重载（Overload）、重写（Override）"><a href="#重载（Overload）、重写（Override）" class="headerlink" title="重载（Overload）、重写（Override）"></a>重载（Overload）、重写（Override）</h2><p><strong>重载(Overload)</strong>指的是一个类里面有同名方法，其<strong>参数</strong>不同，除了参数要独一无二外没什么特殊限制。</p>
<p><strong>重写(Override)</strong>指的是子类对父类方法的实现进行重新编写。</p>
<table>
<thead>
<tr>
<th>区别</th>
<th>重载（Overload）</th>
<th>重写（Override）</th>
</tr>
</thead>
<tbody>
<tr>
<td>参数列表</td>
<td>必须修改</td>
<td>不可修改</td>
</tr>
<tr>
<td>返回类型</td>
<td>可以修改</td>
<td>不可修改</td>
</tr>
<tr>
<td>异常</td>
<td>可以修改</td>
<td>可以减小异常范围（子类异常或无异常）</td>
</tr>
<tr>
<td>访问权限</td>
<td>可以修改</td>
<td>可以降低访问限制(如protected–&gt;public)</td>
</tr>
</tbody>
</table>
<h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><blockquote>
<p>Java内存模型的主要目标是定义程序中各个变量（不包括局部变量，因为局部变量是线程私有的，不会被共享，不存在竞争问题）的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。</p>
</blockquote>
<ol>
<li>所有变量都存储在主内存（Main Memory）中</li>
<li>每条线程有自己的工作内存（Working Memory），保存了该线程用到的变量的主内存副本拷贝（不会整个对象拷贝）</li>
<li>线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量</li>
<li>不同线程间不能直接访问对方工作内存中的变量，线程间的变量值得传递需要通过主内存来完成</li>
</ol>
<p><img src="/img/java/java_memory.jpg" alt="Java内存模型"></p>
<h2 id="Object方法"><a href="#Object方法" class="headerlink" title="Object方法"></a>Object方法</h2><blockquote>
<p>Java是单根继承结构，有一个终极基类<code>Object</code>，它的存在保证所有对象都具备某些功能（具有一个共同接口），使得垃圾回收器的实现变得容易。</p>
</blockquote>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>getClass</td>
<td>获得运行时对象的类型</td>
</tr>
<tr>
<td>hashCode</td>
<td>计算对象的hash值</td>
</tr>
<tr>
<td>equals</td>
<td>判一个对象是否与自身相等</td>
</tr>
<tr>
<td>toString</td>
<td>将对象表示为字符串,在一些字符串操作的地方会自动调用</td>
</tr>
<tr>
<td>notify</td>
<td>(当该对象作为锁时可用)唤醒该对象监视下的一个等待的线程</td>
</tr>
<tr>
<td>notifyAll</td>
<td>(当该对象作为锁时可用)唤醒该对象监视下的所有等待的线程</td>
</tr>
<tr>
<td>wait</td>
<td>(当该对象作为锁时可用)线程进入等待状态，可以设置等待时长</td>
</tr>
<tr>
<td>clone</td>
<td>复制对象，需要实现Cloneable接口</td>
</tr>
<tr>
<td>finalize</td>
<td>对象终结时候执行的方法</td>
</tr>
</tbody>
</table>
<h2 id="sleep、notify、wait"><a href="#sleep、notify、wait" class="headerlink" title="sleep、notify、wait"></a>sleep、notify、wait</h2><table>
<thead>
<tr>
<th></th>
<th>sleep(静态方法)</th>
<th>notify</th>
<th>wait</th>
</tr>
</thead>
<tbody>
<tr>
<td>所属类</td>
<td>Thread</td>
<td>Object</td>
<td>Object</td>
</tr>
<tr>
<td>作用</td>
<td>程序停止一定时间（传入参数），让给其他程序执行</td>
<td>唤醒一个等待的线程，不确定是哪个</td>
<td>进入等待状态直到被唤醒，若带参数则会自动唤醒</td>
</tr>
<tr>
<td>锁的持有情况</td>
<td>不变</td>
<td>不变</td>
<td>放弃</td>
</tr>
</tbody>
</table>
<h2 id="String、StringBuffer、StringBuilder"><a href="#String、StringBuffer、StringBuilder" class="headerlink" title="String、StringBuffer、StringBuilder"></a>String、StringBuffer、StringBuilder</h2><table>
<thead>
<tr>
<th></th>
<th>String</th>
<th>StringBuffer</th>
<th>StringBuilder</th>
</tr>
</thead>
<tbody>
<tr>
<td>是否可变</td>
<td>❌</td>
<td>✔️</td>
<td>✔️</td>
</tr>
<tr>
<td>线程安全</td>
<td>✔️</td>
<td>✔️</td>
<td>❌</td>
</tr>
<tr>
<td>内部实现</td>
<td>final修饰的char数组</td>
<td>char数组，自动扩容、拷贝</td>
<td>char数组，自动扩容、拷贝</td>
</tr>
<tr>
<td>作用</td>
<td>表示字符串</td>
<td>构建字符串，同步，单线程下效率较StringBuilder低</td>
<td>构建字符串，非同步，效率高</td>
</tr>
</tbody>
</table>
<ol>
<li>提防<code>+</code>或者<code>+=</code>连续拼接大量字符串，会使得性能低下 ，大量字符串拼接应考虑<code>StringBuilder</code>（单线程下首选）或者<code>StringBuffer</code>（需要线程安全的情况下）</li>
<li>Java编译会对的<code>+</code>或者<code>+=</code>字符串拼接进行优化（优化成<code>StringBuilder</code>或者<code>StringBuffer</code>），所以简单的拼接可以直接使用</li>
</ol>
<h2 id="原子性、可见性和有序性"><a href="#原子性、可见性和有序性" class="headerlink" title="原子性、可见性和有序性"></a>原子性、可见性和有序性</h2><ul>
<li>原子性（Atomicity）：基本数据类型的读写具备原子性（虽然非协定要求，但是long和double在现代虚拟机中也实现了原子性），在<code>synchronized</code>代码块之间的操作也具备原子性</li>
<li>可见性（Visibility）：一个线程修改了共享变量的值，其他线程能立刻得知这个修改，<code>volatile</code>保证的多线程操作时变量的可见性，而普通变量则不能保证这一点，<code>synchronized</code>和<code>final</code>也可以保证可见性</li>
<li>有序性（Ordering）：如果在本线程内观察，所有的操作都是有序的（县线程内表现为串行的语义，Within-Thread As-If-Serial Semantics）。如果在一个线程中观察另一个线程，所有操作都是无序的（”指令重排序现象“和”工作内存与主内存同步延迟现象“）。<code>volatile</code>和<code>synchronized</code>来保证线程间操作的有序性</li>
</ul>
<h2 id="先行发生（happens-before）原则"><a href="#先行发生（happens-before）原则" class="headerlink" title="先行发生（happens-before）原则"></a>先行发生（happens-before）原则</h2><p>如果连个操作之间的关系不在以下规则之中，并且无法从以下规则推到出来，它们就没有顺序性保障，虚拟机可以对它们随意的进行重排序</p>
<ul>
<li>程序次序规则（Program Order Rule）：在一个线程内，按照程序代码的控制流顺序，书写在前面的代码先行发生于书写在后面的代码</li>
<li>管程锁定规则（Monitor Lock Rule）：一个unlock操作先行发生于后面（时间上先后）对于同一个锁的lock操作</li>
<li><code>volatile</code>变量规则（Volatile Variable Rule）：对一个<code>volatile</code>变量的写操作先行发生于后面（时间上先后）对这个变量的读操作</li>
<li>线程启动规则（Thread Start Rule）：Thread对象的start()方法先行发生于此线程的每一个动作</li>
<li>线程终止规则（Thread Termination Rule）：线程中的每一个动作都先行发生于对此线程的终止检测</li>
<li>线程中断规则（Thread Interruption Rule）：对线程中interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li>
<li>对象终结规则（Finalizer Rule）：一个对象的初始化完成先行于它的finalize()方法的开始</li>
<li>传递性（Transitivity）：如果操作A先行发生于操作B，操作B先行发生于操作C，那么，操作A先行发生于操作C</li>
</ul>
<blockquote>
<p>一个操作”时间上的先发生“不代表这个操作会是”先行发生“；一个操作”先行发生“也不能代表这个操作”时间上的先发生“（指令重排序）。衡量并发安全问题不要受到时间顺序的干扰，一切必须以先行发生原则为准。</p>
</blockquote>
<h2 id="volatile和synchronized"><a href="#volatile和synchronized" class="headerlink" title="volatile和synchronized"></a>volatile和synchronized</h2><blockquote>
<p>关键字<code>volatile</code>可以说是Java虚拟机提供的最轻量级的同步机制</p>
</blockquote>
<p>一个变量被声明为<code>volatile</code>后具备两种特性：</p>
<ol>
<li>保证此变量对所有线程的可见性，即修改可以被立即得知，此变量在各个线程的工作内存中不存在一致性问题（每次使用前都要先刷新）</li>
<li>禁止指令重排序优化</li>
</ol>
<p>因为在Java中的运算并非原子操作，所以<code>volatile</code>变量的运算在并发下一样是<strong>不安全的</strong>，<code>volatile</code>只能保证<strong>可见性</strong>，在不符合以下规则的场景下需要通过加锁（使用<code>synchronized</code>或<code>java.util.concurrent</code>中的原子类）来保证<strong>原子性</strong>：</p>
<ol>
<li>运算结果不依赖变量的<strong>当前值</strong>，或者能保证只有<strong>单一线程</strong>修改变量的值</li>
<li>变量不需要与<strong>其他的状态变量</strong>（可能存在不一致）共同参与不变约束</li>
</ol>
<p><code>volatile</code>与<code>synchronized</code>的区别</p>
<table>
<thead>
<tr>
<th></th>
<th>volatile</th>
<th>synchronized</th>
</tr>
</thead>
<tbody>
<tr>
<td>是否加锁</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>是否造成线程阻塞</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>是否具备可见性</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>是否具备原子性</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>是否可以被编译器优化</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>同步机制重量级</td>
<td>轻</td>
<td>重</td>
</tr>
<tr>
<td>使用的地方</td>
<td>变量</td>
<td>变量、方法</td>
</tr>
</tbody>
</table>
<h2 id="线程间通信方式"><a href="#线程间通信方式" class="headerlink" title="线程间通信方式"></a>线程间通信方式</h2><ol>
<li>同步：通过<code>synchronized</code>实现线程间通信</li>
<li><code>while</code>轮询：不断地检测条件，会浪费CPU资源，存在可见性问题（可能造成死循环）</li>
<li><code>wait/notify</code>机制：存在通知过早问题，会打乱程序的执行逻辑</li>
<li>管道通信：类似消息传递机制，使用<code>java.io.PipedInputStream</code>和<code>java.io.PipedOutputStream</code>进行通信</li>
</ol>
<h2 id="线程的各种状态"><a href="#线程的各种状态" class="headerlink" title="线程的各种状态"></a>线程的各种状态</h2><blockquote>
<p>Java语言定义了5种线程状态（新建、运行、等待、阻塞、结束），任意时间点，线程有且只能有其中一种状态。Java中一般使用抢占式的线程调度方式</p>
</blockquote>
<ol>
<li>新建（New）：创建后尚未启动的线程</li>
<li>运行（Runable）：包括Running和Ready</li>
<li>无限期等待（Waiting）：等待被其他线程显式地唤醒，进入该状态的方法有<code>无参Thread.join()</code>、<code>无参Object.wait()</code>和<code>LockSupport.park()</code>等</li>
<li>限期等待（Timed Waiting）：到时间后会自动唤醒，进入该状态的方法有<code>Thread.sleep()</code>、<code>带参Thread.join()</code>、<code>带参Object.wait()</code>、<code>LockSupport.parkNanos()</code>和<code>LockSupport.parkUntil()</code>等</li>
<li>阻塞（Blocked）：线程被阻塞了，等待获取到一个排他锁，在另一个线程放弃这个锁的时候发生</li>
<li>结束（Terminated）：已终止线程的状态，线程已经结束执行。</li>
</ol>
<p>阻塞状态在等待另一个线程释放排它锁，而等待状态在等待时间到或者被唤醒。</p>
<p><img src="/img/java/thread_status.jpg" alt="线程状态"></p>
<h2 id="关于Java中的finally"><a href="#关于Java中的finally" class="headerlink" title="关于Java中的finally"></a>关于Java中的finally</h2><h3 id="finally可能没被执行"><a href="#finally可能没被执行" class="headerlink" title="finally可能没被执行"></a>finally可能没被执行</h3><ol>
<li>在try语句执行前程序就返回(结束了)</li>
<li>在try块中有System.exit(0),虚拟机停止</li>
</ol>
<h3 id="finally语句执行情况"><a href="#finally语句执行情况" class="headerlink" title="finally语句执行情况"></a>finally语句执行情况</h3><ol>
<li>finally语句在return语句执行之后return返回之前执行的</li>
<li>finally块中的return语句会覆盖try块中的return返回</li>
<li>如果finally语句中没有return语句覆盖返回值，那么原来的返回值可能因为finally里的修改而改变也可能不变(传值问题)</li>
<li>try块里的return语句在异常的情况下不会被执行，这样具体返回哪个看情况</li>
<li>当发生异常后，catch中的return执行情况与未发生异常时try中return的执行情况完全一样</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li>《Thinking in Java》</li>
<li>《深入理解Java虚拟机》</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerlink&quot; title=&quot;数据类型&quot;&gt;&lt;/a&gt;数据类型&lt;/h2&gt;&lt;h3 id=&quot;内置类型——基本数据类型&quot;&gt;&lt;a href=&quot;#内置类型——基本数据类型&quot; class=&quot;headerlink&quot; 
    
    </summary>
    
      <category term="Java" scheme="https://blog.ajavac.com/categories/Java/"/>
    
    
      <category term="Java" scheme="https://blog.ajavac.com/tags/Java/"/>
    
      <category term="Basic" scheme="https://blog.ajavac.com/tags/Basic/"/>
    
  </entry>
  
  <entry>
    <title>Web大规模并发的解决思路</title>
    <link href="https://blog.ajavac.com/2017/03/23/Common/web_seckill/"/>
    <id>https://blog.ajavac.com/2017/03/23/Common/web_seckill/</id>
    <published>2017-03-23T09:20:35.000Z</published>
    <updated>2017-03-23T09:20:37.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>特点：短时间内海量的请求，比如1秒5w请求（5wQPS）</p>
</blockquote>
<h2 id="大规模并发带来的挑战"><a href="#大规模并发带来的挑战" class="headerlink" title="大规模并发带来的挑战"></a>大规模并发带来的挑战</h2><ol>
<li>请求接口的合理设计，动静态资源分离（CDN），负载均衡，分布式，使用内存数据库</li>
<li>快速反馈，合理设计，防止雪崩</li>
<li>重启和过载保护，拒绝超载的请求</li>
</ol>
<h2 id="防止作弊手段"><a href="#防止作弊手段" class="headerlink" title="防止作弊手段"></a>防止作弊手段</h2><ol>
<li>一个账号多个请求，参与记录判断（只接受一个请求），使用Redis的watch乐观锁，或者使用队列实现</li>
<li>多个账号同个IP多个请求，使用验证码，禁止IP（容易误伤）</li>
<li>多个账号不同IP多个请求，数据挖掘清理僵尸号（有一些特点），提高活动门槛</li>
<li>火车票抢购，没有很好的解决方案，数据挖掘清理僵尸号</li>
</ol>
<h2 id="高并发下的数据安全——超发"><a href="#高并发下的数据安全——超发" class="headerlink" title="高并发下的数据安全——超发"></a>高并发下的数据安全——超发</h2><ol>
<li>使用悲观锁，但是性能低下</li>
<li>使用队列，容易爆队列</li>
<li>使用乐观锁，会增大CPU计算开销，但是是比较好的解决方案</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.csdn.net/article/2014-11-28/2822858" target="_blank" rel="external">【问底】徐汉彬：Web系统大规模并发——电商秒杀与抢购</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;特点：短时间内海量的请求，比如1秒5w请求（5wQPS）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;大规模并发带来的挑战&quot;&gt;&lt;a href=&quot;#大规模并发带来的挑战&quot; class=&quot;headerlink&quot; title=&quot;大规模并发带来的挑
    
    </summary>
    
      <category term="Web" scheme="https://blog.ajavac.com/categories/Web/"/>
    
    
      <category term="Common" scheme="https://blog.ajavac.com/tags/Common/"/>
    
      <category term="Web" scheme="https://blog.ajavac.com/tags/Web/"/>
    
      <category term="Seckill" scheme="https://blog.ajavac.com/tags/Seckill/"/>
    
  </entry>
  
  <entry>
    <title>HashMap的实现原理</title>
    <link href="https://blog.ajavac.com/2017/03/23/Java/hash_map/"/>
    <id>https://blog.ajavac.com/2017/03/23/Java/hash_map/</id>
    <published>2017-03-23T06:48:33.000Z</published>
    <updated>2017-03-23T07:50:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>HashMap 是基于哈希表的 Map 接口的<strong>非同步</strong>实现，允许null作为键或值，不保证顺序恒久不变，是无序的。</p>
</blockquote>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>Java中最基本的结构是数组和引用，HashMap就是通过这两个数据结构进行实现。实际上是一个“链表散列”的数据结构，是数组和链表的结合体（1.8后还加入了红黑树）</p>
<p><img src="/img/java/hash_map.jpg" alt="hash_map"></p>
<p>HashMap 中存储数据的是一个<code>Node&lt;K,V&gt;[] table</code>数组，其中的内容可以是：</p>
<ol>
<li><code>null</code>代表没有数据</li>
<li><code>Node&lt;K,V&gt;</code>代表一个键值对（只有一个节点）</li>
<li><code>Node&lt;K,V&gt;</code>代表一个链表（有多个节点，2~8，当长度大于8转换成红黑树树）</li>
<li><code>TreeNode&lt;K,V&gt;</code>代表一个红黑树（有多个节点，8~）</li>
</ol>
<h2 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h2><h2 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h2><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><ol>
<li>HashMap() 构造一个初始容量16，负载因子为0.75的HashMap</li>
<li>HashMap(int initialCapacity) 指定初始容量，负载因子为0.75</li>
<li>HashMap(int initialCapacity, float loadFactor) 指定初始容量和负载因子</li>
</ol>
<ul>
<li>初始容量 <code>initialCapacity</code> 和负载因子 <code>loadFactor</code> 两个参数共同决定了HashMap的最大容量：<code>threshold = (int)(capacity * loadFactor);</code></li>
<li>当HashMap的元素数目超过<code>threshold</code>就需要进行<code>resize()</code>，把容量变为原来的<strong>两倍</strong>，元素的位置也会进行重新分配</li>
<li><code>loadFactor</code> 表示散列表空间使用程度，越大空间利用率越高，但是查询效率越低</li>
</ul>
<h2 id="Fail-Fast-机制"><a href="#Fail-Fast-机制" class="headerlink" title="Fail-Fast 机制"></a>Fail-Fast 机制</h2><blockquote>
<p>HashMap 不是线程安全的，利用了<code>modCount</code>参数来记录每次修改，所以在用<code>Iterator</code>遍历过程中若发生并发修改会抛出<code>ConcurrentModificationException</code>异常</p>
</blockquote>
<h2 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h2><ol>
<li><code>map.entrySet()</code> 遍历entrySet，同时遍历key和value</li>
<li><code>map.keySet()</code> 效率低，遍历key，需要get才能获取value</li>
<li><code>map.forEach((k,v)-&gt; System.out.println(k+&quot; : &quot;+v));</code> 效率高，需要JDK1.8以上</li>
</ol>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://wiki.jikexueyuan.com/project/java-collection/hashmap.html" target="_blank" rel="external">HashMap的实现原理</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;HashMap 是基于哈希表的 Map 接口的&lt;strong&gt;非同步&lt;/strong&gt;实现，允许null作为键或值
    
    </summary>
    
      <category term="Java" scheme="https://blog.ajavac.com/categories/Java/"/>
    
    
      <category term="Java" scheme="https://blog.ajavac.com/tags/Java/"/>
    
      <category term="Collection" scheme="https://blog.ajavac.com/tags/Collection/"/>
    
      <category term="HashMap" scheme="https://blog.ajavac.com/tags/HashMap/"/>
    
      <category term="Map" scheme="https://blog.ajavac.com/tags/Map/"/>
    
      <category term="Hash" scheme="https://blog.ajavac.com/tags/Hash/"/>
    
  </entry>
  
  <entry>
    <title>《Effective Java》读书笔记——第2章</title>
    <link href="https://blog.ajavac.com/2017/03/22/EffectiveJava/chapter2/"/>
    <id>https://blog.ajavac.com/2017/03/22/EffectiveJava/chapter2/</id>
    <published>2017-03-22T11:03:24.000Z</published>
    <updated>2017-03-24T08:11:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建和销毁对象"><a href="#创建和销毁对象" class="headerlink" title="创建和销毁对象"></a>创建和销毁对象</h2><h3 id="No-1-考虑用静态工厂方法代替构造器"><a href="#No-1-考虑用静态工厂方法代替构造器" class="headerlink" title="No.1 考虑用静态工厂方法代替构造器"></a>No.1 考虑用静态工厂方法代替构造器</h3><p>静态工厂方法的优点：</p>
<ol>
<li>它们有名称</li>
<li>不必再每次调用它们的时候都创建一个新对象</li>
<li>它们可以返回原返回类型的任何子类型的对象</li>
<li>在创建参数化类型实例的时候，它们使代码变得更加简洁</li>
</ol>
<p>静态工厂方法的缺点：</p>
<ol>
<li>类如果不含公有的或者受保护的构造器，就不能被子类化</li>
<li>它们与其他的静态方法实际上没有任何区别</li>
</ol>
<p>静态工厂方法的一些惯用名称：</p>
<ul>
<li>valueOf</li>
<li>of</li>
<li>getInstance</li>
<li>newInstance</li>
<li>getType</li>
<li>newType</li>
</ul>
<h3 id="No-2-遇到多个构造器参数时要考虑用构建器"><a href="#No-2-遇到多个构造器参数时要考虑用构建器" class="headerlink" title="No.2 遇到多个构造器参数时要考虑用构建器"></a>No.2 遇到多个构造器参数时要考虑用构建器</h3><blockquote>
<p>静态工厂方法和构造器都不能很好地扩展到大量的可选参数，JavaBeans模式有着严重的缺点（构造过程中可能处于不一致的状态，无法保证一致性），而Builder模式在大量可选参数的情况下可以满足可读性、一致性等要求。</p>
</blockquote>
<p>总之，如果类的构造器或者静态工厂方法中具有多个参数（<strong>大于4个</strong>），设计这种类的时候，Builder模式就是不错的选择，尤其是在大多数参数是可选的时候。与传统的重叠构造器模式相比，Builder模式的客户端代码将更易于阅读和编写，构建器也比JavaBeans更加安全。</p>
<h3 id="No-3-用私有构造器或者枚举类型强化Singleton属性"><a href="#No-3-用私有构造器或者枚举类型强化Singleton属性" class="headerlink" title="No.3 用私有构造器或者枚举类型强化Singleton属性"></a>No.3 用私有构造器或者枚举类型强化Singleton属性</h3><ol>
<li>静态final域和私有构造器仍可能受到攻击</li>
</ol>
<ol>
<li><strong>单元素的枚举类型</strong>已经成为实现Singleton的最佳方法。</li>
</ol>
<h3 id="No-4-通过私有构造器强化不可实例化的能力"><a href="#No-4-通过私有构造器强化不可实例化的能力" class="headerlink" title="No.4 通过私有构造器强化不可实例化的能力"></a>No.4 通过私有构造器强化不可实例化的能力</h3><blockquote>
<p>工具类只有静态方法，实例化没有意义</p>
</blockquote>
<ol>
<li>企图通过将类做成抽象类来强制该类不可被实例化，这是行不通的。该类可以被子类化，并且其子类可以被实例化</li>
<li>将构造器私有化可以强化该类不可实例化的能力，但是它也使得该类不可被子类化</li>
</ol>
<h3 id="No-5-避免创建不必要的对象"><a href="#No-5-避免创建不必要的对象" class="headerlink" title="No.5 避免创建不必要的对象"></a>No.5 避免创建不必要的对象</h3><blockquote>
<p>要避免创建不必要的对象</p>
</blockquote>
<ol>
<li>如果对象是不可变的（immutable），它就始终可以被重用</li>
<li>可以通过静态工厂方法避免创建不必要的对象，比如<code>Boolean.valueOf(String)</code></li>
<li>重用那些已知不会被修改的对象</li>
<li>优先使用<strong>基本类型</strong>而不是<strong>装箱基本类型</strong>，当心无意识的<strong>自动装箱</strong></li>
<li>小对象的创建和回收动作是廉价的，所以不能绝对化的认为要避免创建对象，通过创建附加对象，提升程序的清晰性、简洁性和功能性，这通常是好事</li>
</ol>
<p>实践：</p>
<ol>
<li>比如<code>String str= new String(&quot;test&quot;);</code>就是很不好的例子，应该使用<code>String str= &quot;test&quot;;</code></li>
<li>字符串的多次拼接应该考虑使用<code>StringBuilder</code>而不是简单的<code>+</code>或者<code>+=</code> ，除非只是一次性的拼接（编译器会自动优化）</li>
</ol>
<h3 id="No-6-消除过期的对象引用"><a href="#No-6-消除过期的对象引用" class="headerlink" title="No.6 消除过期的对象引用"></a>No.6 消除过期的对象引用</h3><ol>
<li>清空对象引用应该是一种例外，而不是一种规范行为</li>
<li>只要类是自己管理内存，程序员就应该警惕内存泄漏问题</li>
<li>内存泄漏的另一个常见来源是缓存</li>
<li>内存泄漏的第三个常见来源是监听器和其他回调</li>
<li>最好能在内存泄漏发生之前就知道如何预测此类问题，并阻止它们发生</li>
</ol>
<p>解决方案：</p>
<ol>
<li>使用弱引用<code>WeakHashMap</code></li>
<li>后台线程定期清理没用的缓存项，比如<code>LinkedHashMap</code>的<code>removeEldestEntry</code></li>
<li>对于更加复杂的缓存，必须直接使用<code>java.lang.ref</code></li>
</ol>
<h3 id="No-7-避免使用终结方法"><a href="#No-7-避免使用终结方法" class="headerlink" title="No.7 避免使用终结方法"></a>No.7 避免使用终结方法</h3><ol>
<li>终结方法（finalizer）通常是不可预测的，也是很危险的，一般情况下是不必要的</li>
<li>不应该依赖终结方法来更新重要的持久状态，因为不保证终结方法会被执行</li>
<li>使用终结方法有一个非常严重的（Severe）性能损失</li>
<li>最好使用<strong>显式终结方法</strong>，通常与<code>try...finally</code>结构结合起来使用，以确保及时终止。比如<code>InputStream</code>、<code>OutputStream</code>和<code>java.sql.Connection</code></li>
</ol>
<p>用途：</p>
<ol>
<li>终结方法可以充当“<strong>安全网</strong>（safety net）“，在客户端为进行显式终止来正常结束的情况下释放资源，但是如果终结方法发现资源还未被终止，则应该在日志中记录这一警告，比如<code>FileInputStream</code></li>
<li>第二个用途与对象的本地对等体（native peer）有关，终结方法应该完成所有必要的工作，<strong>释放关键的资源</strong></li>
</ol>
<p>注意：</p>
<ol>
<li>如果子类覆盖了超类的终结方法，但是忘了手动调用超类的终结方法，那么超类的终结方法将永远的不到调用</li>
<li>可以将终结方法放在一个匿名的类中，它的唯一用途就是终结外围实例（enclosing instance），被称为终结方法守卫者（finalizer guardian）</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;创建和销毁对象&quot;&gt;&lt;a href=&quot;#创建和销毁对象&quot; class=&quot;headerlink&quot; title=&quot;创建和销毁对象&quot;&gt;&lt;/a&gt;创建和销毁对象&lt;/h2&gt;&lt;h3 id=&quot;No-1-考虑用静态工厂方法代替构造器&quot;&gt;&lt;a href=&quot;#No-1-考虑用静态工厂方法
    
    </summary>
    
      <category term="book" scheme="https://blog.ajavac.com/categories/book/"/>
    
    
      <category term="Java" scheme="https://blog.ajavac.com/tags/Java/"/>
    
      <category term="Effective_Java" scheme="https://blog.ajavac.com/tags/Effective-Java/"/>
    
      <category term="book" scheme="https://blog.ajavac.com/tags/book/"/>
    
  </entry>
  
  <entry>
    <title>关于MySQL中InnoDB的MVCC</title>
    <link href="https://blog.ajavac.com/2017/03/22/MySQL/mysql_innod_mvcc/"/>
    <id>https://blog.ajavac.com/2017/03/22/MySQL/mysql_innod_mvcc/</id>
    <published>2017-03-22T10:35:40.000Z</published>
    <updated>2017-03-22T10:36:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于MySQL中InnoDB的MVCC"><a href="#关于MySQL中InnoDB的MVCC" class="headerlink" title="关于MySQL中InnoDB的MVCC"></a>关于MySQL中InnoDB的MVCC</h1><h2 id="MySQL中的实现"><a href="#MySQL中的实现" class="headerlink" title="MySQL中的实现"></a>MySQL中的实现</h2><blockquote>
<p>在InnoDB中的每行数据后都有额外的<strong>两个隐藏值</strong>来记录数据何时被<strong>创建</strong>(修改)和<strong>过期</strong>(删除)，这里的时间不是我们日常中的时间，而是事务的版本号，每开启一个新事务，版本号会递增。</p>
</blockquote>
<p>在MySQL默认隔离级别<code>Repeatable Read</code>下：</p>
<p>设数据行创建版本号为<code>create</code>，删除版本号为<code>delete</code>，当前事务版本号为<code>now</code></p>
<ul>
<li><code>SELECT</code>，读取的数据行满足创建版本号&lt;=当前事务版本号，删除版本号为空或&gt;当前事务版本号，即 <code>(create &lt;= now &amp;&amp; (delete == null || delete &gt; now))</code></li>
<li><code>INSERT</code>，保存当前事务版本号为行的创建版本号（<code>commit</code>时生效），即<code>create=now</code></li>
<li><code>DELETE</code>，保存当前事务版本号为行的删除版本号（<code>commit</code>时生效），即<code>delete=now</code></li>
<li><code>UPDATE</code>，插入一条新纪录，保存当前事务版本号为行创建版本号，同时保存当前事务版本号到原来删除的行（<code>commit</code>时生效），即新行<code>create=now</code>旧行<code>delte=now</code></li>
</ul>
<p>通过MVVC，虽然每行记录需要额外的存储空间，但是减少了锁的使用，使读数据性能很好。在MySQL的RR级别中，解决了幻读的读问题（快照读）。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://tech.meituan.com/innodb-lock.html" target="_blank" rel="external">Innodb中的事务隔离级别和锁的关系</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;关于MySQL中InnoDB的MVCC&quot;&gt;&lt;a href=&quot;#关于MySQL中InnoDB的MVCC&quot; class=&quot;headerlink&quot; title=&quot;关于MySQL中InnoDB的MVCC&quot;&gt;&lt;/a&gt;关于MySQL中InnoDB的MVCC&lt;/h1&gt;&lt;h2 i
    
    </summary>
    
      <category term="MySQL" scheme="https://blog.ajavac.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://blog.ajavac.com/tags/MySQL/"/>
    
      <category term="DataBase" scheme="https://blog.ajavac.com/tags/DataBase/"/>
    
      <category term="Transaction" scheme="https://blog.ajavac.com/tags/Transaction/"/>
    
  </entry>
  
  <entry>
    <title>spring 事务传播特性和隔离级别</title>
    <link href="https://blog.ajavac.com/2017/03/22/MySQL/transaction/"/>
    <id>https://blog.ajavac.com/2017/03/22/MySQL/transaction/</id>
    <published>2017-03-22T10:35:00.000Z</published>
    <updated>2017-03-22T10:35:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="spring-事务传播特性和隔离级别"><a href="#spring-事务传播特性和隔离级别" class="headerlink" title="spring 事务传播特性和隔离级别"></a>spring 事务传播特性和隔离级别</h1><h2 id="事务四大特性"><a href="#事务四大特性" class="headerlink" title="事务四大特性:"></a>事务四大特性:</h2><ol>
<li>原子性(Atomicity)  :强调的事务的不可分割.</li>
<li>一致性(Consistency)    :强调的事务的执行前后,数据库的的完整性保持一致.</li>
<li>隔离性(Isolation)  :强调的事务的并发的访问,一个事务的执行,不应该受到另一个事务的打扰.</li>
<li>持久性(Durability) :强调的事务结束之后,数据就永久的保存的数据库中.</li>
</ol>
<h1 id="安全性问题"><a href="#安全性问题" class="headerlink" title="安全性问题"></a>安全性问题</h1><ol>
<li>脏读:一个事务,读到了另一个事务未提交数据.</li>
<li>不可重复读 :一个事务,读到了另一个事务的提交数据（update）.导致查询结果不一致.</li>
<li>虚读(幻读) :一个事务,读到了另一个事务的提交数据(insert).导致查询结果不一致</li>
<li>丢失更新:一个事务更新了数据,另一个事务也更新数据,后面的事务覆盖了前一个事务的更新</li>
</ol>
<h2 id="事务的几种传播特性"><a href="#事务的几种传播特性" class="headerlink" title="事务的几种传播特性"></a>事务的几种传播特性</h2><ol>
<li><strong>PROPAGATION_REQUIRED</strong>: 如果存在一个事务，则支持当前事务。如果没有事务则开启,默认</li>
<li><strong>PROPAGATION_SUPPORTS</strong>: 如果存在一个事务，则支持当前事务。如果没有事务，则非事务的执行</li>
<li><strong>PROPAGATION_MANDATORY</strong>: 如果存在一个事务，则支持当前事务。如果没有一个活动的事务，则抛出异常。</li>
<li><strong>PROPAGATION_REQUIRES_NEW</strong>: 总是开启一个新的事务。如果一个事务已经存在，则将这个存在的事务挂起。</li>
<li><strong>PROPAGATION_NOT_SUPPORTED</strong>: 总是非事务地执行，并挂起任何存在的事务。</li>
<li><strong>PROPAGATION_NEVER</strong>: 总是非事务地执行，如果存在一个活动事务，则抛出异常</li>
<li><strong>PROPAGATION_NESTED</strong>：如果一个活动的事务存在，则运行在一个嵌套的事务中. 如果没有活动事务, 则按TransactionDefinition.PROPAGATION_REQUIRED 属性执行</li>
</ol>
<h2 id="Spring事务的隔离级别"><a href="#Spring事务的隔离级别" class="headerlink" title="Spring事务的隔离级别"></a>Spring事务的隔离级别</h2><ol>
<li>ISOLATION_DEFAULT： 这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别.MySQL默认<strong>repeatable read</strong>,Oracle默认<strong>read committed</strong></li>
<li>另外四个与JDBC的隔离级别相对应</li>
<li>ISOLATION_READ_UNCOMMITTED： 这是事务最低的隔离级别，它充许令外一个事务可以看到这个事务未提交的数据。 这种隔离级别会产生脏读，不可重复读和幻像读。</li>
<li>ISOLATION_READ_COMMITTED： 保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据</li>
<li>ISOLATION_REPEATABLE_READ： 这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。 它除了保证一个事务不能读取另一个事务未提交的数据外，还保证了避免下面的情况产生(不可重复读)。</li>
<li>ISOLATION_SERIALIZABLE 这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。 除了防止脏读，不可重复读外，还避免了幻像读。</li>
</ol>
<p>悲观锁\乐观锁解决丢失更新</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;spring-事务传播特性和隔离级别&quot;&gt;&lt;a href=&quot;#spring-事务传播特性和隔离级别&quot; class=&quot;headerlink&quot; title=&quot;spring 事务传播特性和隔离级别&quot;&gt;&lt;/a&gt;spring 事务传播特性和隔离级别&lt;/h1&gt;&lt;h2 id=&quot;事
    
    </summary>
    
      <category term="MySQL" scheme="https://blog.ajavac.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://blog.ajavac.com/tags/MySQL/"/>
    
      <category term="DataBase" scheme="https://blog.ajavac.com/tags/DataBase/"/>
    
      <category term="Transaction" scheme="https://blog.ajavac.com/tags/Transaction/"/>
    
  </entry>
  
  <entry>
    <title>《Effective Java》读书笔记——第1章</title>
    <link href="https://blog.ajavac.com/2017/03/14/EffectiveJava/chapter1/"/>
    <id>https://blog.ajavac.com/2017/03/14/EffectiveJava/chapter1/</id>
    <published>2017-03-14T08:20:00.000Z</published>
    <updated>2017-03-22T11:03:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>有效地使用Java及其基本类库十分重要，尤其是：</p>
<ol>
<li><code>java.lang</code></li>
<li><code>java.util</code></li>
<li><code>java.util.concurrent</code></li>
<li><code>java.io</code></li>
</ol>
<p>编写程序的目标是：清晰、正确、可用、健壮、灵活和可维护</p>
<ol>
<li>Java语言支持四种类型：接口（interface）、类（class）、数组（array）和基本类型（primitive）</li>
<li>前三种为引用类型（reference type），类实例和数组是对象（object），而基本类型的值则不是对象</li>
<li>类的成员（member）由它的域（field）、方法（method）、成员类（member class）和成员接口（member interface）组成</li>
<li>方法的签名（signature）由它的名称和所有参数类型组成，签名不包括它的返回类型</li>
<li>API（Application Programming Interface）指类、接口、构造器（constructor）、成员和序列化形式（serialized form），通过他们可以访问类、接口或者包</li>
<li>一个包导出的API由该包中的每个公有（public）类或者接口中所有公有的或者受保护的（protected）成员和构造器组成</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;有效地使用Java及其基本类库十分重要，尤其是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;java.lang&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;
    
    </summary>
    
      <category term="book" scheme="https://blog.ajavac.com/categories/book/"/>
    
    
      <category term="Java" scheme="https://blog.ajavac.com/tags/Java/"/>
    
      <category term="Effective_Java" scheme="https://blog.ajavac.com/tags/Effective-Java/"/>
    
      <category term="book" scheme="https://blog.ajavac.com/tags/book/"/>
    
  </entry>
  
  <entry>
    <title>字符编码</title>
    <link href="https://blog.ajavac.com/2017/01/13/Common/character/"/>
    <id>https://blog.ajavac.com/2017/01/13/Common/character/</id>
    <published>2017-01-13T08:27:31.000Z</published>
    <updated>2017-05-15T01:43:50.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>编程过程中偶尔会遇到乱码问题,对字符编码进行一定的理解可以加快解决问题的速度.</p>
</blockquote>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ol>
<li><code>字符集</code>:系统支持的所有抽象字符的集合。</li>
<li><code>常见字符集</code>：ASCII、ISO-8859-1、GB2312、GBK、GB18030、BIG5、Unicode等。</li>
<li><code>编码</code>(encoding): 编码是信息从一种形式或格式<code>转换</code>为另一种形式的过程。解码，是编码的<code>逆过程</code>。</li>
<li><code>字符编码</code>(character encoding): 把字符集中的字符编码为指定集合中某一对象（例如：比特模式、自然数序列、8位元组或者电脉冲），以便文本在计算机中存储和通过通信网络的传递。一般一种字符集对应一种字符编码方式，其中Unicode字符集有多种编码方式，比如UTF-8、UTF-16、UTF-32。不同字符集间转换一般使用Unicode字符集作为中介，先转换为Unicode字符，然后再查码表进行转换。</li>
</ol>
<h1 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h1><blockquote>
<p>Unicode (万国码,国际码,统一码,单一码)是计算机领域的一项业界标准,对世界上大部分文字系统进行整理和编码,使电脑可以用更为简单的方式类呈现和处理文字.</p>
</blockquote>
<ol>
<li>Java程序在运行时，内存中的字符使用Unicode字符集，使用UTF-16的编码方式（一般为2个字节，辅助平面字符需要4个字节）</li>
<li>Unicode使用16位的编码空间，每个字符占用2个字节(附加字符需要4个字节)</li>
<li>一个字符的Unicode编码是确定的</li>
<li>Unicode的实现方式称为Unicode转换格式（Unicode Transformation Format，简称为UTF）.</li>
</ol>
<h1 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h1><blockquote>
<p>UTF-8（8-bit Unicode Transformation Format）是一种针对Unicode的可变长度字元编码，也是一种前缀码。它可以用来表示Unicode标准中的任何字元，且其编码中的第一个位元组仍与ASCII相容，这使得原来处理ASCII字元的软体无须或只须做少部份修改，即可继续使用。因此，它逐渐成为电子邮件、网页及其他储存或传送文字的应用中，<code>优先采用</code>的编码。</p>
</blockquote>
<ol>
<li>只包含7位ASCII字符的文件在ASCII和UTF-8两种编码方式下是一樣的</li>
<li>UTF-8是一种变长编码方式(1-4个字节),兼容ASCII</li>
<li>其中英文字符占用1个字节,中文字符占用3个字节,所以相对来说,占用存储空间较少</li>
</ol>
<h1 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h1><ol>
<li>采用2个字节或者4个字节(辅助平面字符)的编码方式,是Java中字符的编码方式</li>
<li>英文也占用2个字节,所以比较浪费空间</li>
<li>优点是编解码方便,效率高,字符定位容易</li>
<li>缺点是占用空间大,采用顺序编码,若字符损坏无法进行校验</li>
</ol>
<h1 id="UTF-32"><a href="#UTF-32" class="headerlink" title="UTF-32"></a>UTF-32</h1><ol>
<li>采用4个字节的定长编码方式</li>
<li>英文也占用4个字节</li>
<li>占用空间大</li>
<li>有大小端的区别</li>
</ol>
<h1 id="Java中的编码"><a href="#Java中的编码" class="headerlink" title="Java中的编码"></a>Java中的编码</h1><ol>
<li>Java程序默认使用UTF-16编码(字符串<code>String</code>的编码)</li>
<li>JVM编码:Uninx默认使用UTF-8,Windows默认使用GBK(文件系统编码方式),所以最好指定编码方式,加入JVM参数<code>-Dfile.encoding=utf8</code></li>
<li>String的getBytes()方法默认使用的是JVM默认的编码方式来编码(不同操作系统可能会不一样,所以最好指定编码方式)</li>
<li>String的getBytes(Charset)方法指定编码方式来编码字符串</li>
<li>new String(byte[])方法默认使用的是JVM默认的编码方式来解码(不同操作系统可能会不一样,所以最好指定编码方式)</li>
<li>new String(byte[],Charset)方法可以对byte[]进行指定编码方式解码</li>
<li>乱码需要使用当时编码时候用的<code>错误解码方式</code>进行编码后再重新解码</li>
<li>很多框架使用<code>ISO-8859-1</code>编码,存在黑洞问题,容易造成中文丢失,<code>new String(str.getBytes(&quot;utf-8&quot;),&quot;iso-8859-1&quot;);</code>有可能能解决问题</li>
</ol>
<h1 id="不同编码方式占用字节-byte"><a href="#不同编码方式占用字节-byte" class="headerlink" title="不同编码方式占用字节(byte)"></a>不同编码方式占用字节(byte)</h1><blockquote>
<p> 非特殊字符情况下</p>
</blockquote>
<table>
<thead>
<tr>
<th>编码方式</th>
<th>1个英文字符(ASCII)</th>
<th>1个中文字符</th>
</tr>
</thead>
<tbody>
<tr>
<td>GB2312</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>GBK</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>UTF-8</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>UTF-16</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>UTF-32</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>Unicode</td>
<td>2</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>其中GBK兼容GB2312,可以说GBK是GB2312的超集</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接:"></a>参考链接:</h1><p><a href="https://zh.wikipedia.org/wiki/编码" target="_blank" rel="external">WIKI_编码</a></p>
<p><a href="https://zh.wikipedia.org/wiki/字符编码" target="_blank" rel="external">WIKI_字符编码</a></p>
<p><a href="https://zh.wikipedia.org/wiki/Unicode" target="_blank" rel="external">WIKI_Unicode</a></p>
<p><a href="http://www.cnblogs.com/skynet/archive/2011/05/03/2035105.html" target="_blank" rel="external">字符集和字符编码（Charset &amp; Encoding）</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;编程过程中偶尔会遇到乱码问题,对字符编码进行一定的理解可以加快解决问题的速度.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;
    
    </summary>
    
      <category term="Charset" scheme="https://blog.ajavac.com/categories/Charset/"/>
    
    
      <category term="Common" scheme="https://blog.ajavac.com/tags/Common/"/>
    
      <category term="Charset" scheme="https://blog.ajavac.com/tags/Charset/"/>
    
  </entry>
  
  <entry>
    <title>MySQL数据类型</title>
    <link href="https://blog.ajavac.com/2017/01/06/MySQL/mysql_data_type/"/>
    <id>https://blog.ajavac.com/2017/01/06/MySQL/mysql_data_type/</id>
    <published>2017-01-06T05:53:52.000Z</published>
    <updated>2017-03-26T08:03:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL-数据类型"><a href="#MySQL-数据类型" class="headerlink" title="MySQL 数据类型"></a>MySQL 数据类型</h1><h2 id="char与varchar"><a href="#char与varchar" class="headerlink" title="char与varchar"></a>char与varchar</h2><ol>
<li>char性能优于varchar（会用1-2个字节存储字符串长度），也不易产生碎片，适合用于存储长度较为固定的字符串</li>
<li>进行字符比较时候默认是不区分大小写的</li>
<li>char(4)可以存4个<strong>字符</strong>，根据编码方式占据不同的字节（UTF-8每个字符占据3字节）</li>
<li>varchar(4)可以存4个字符，根据编码方式以及存放字节长度占据不同的字节（会用1-2个字节存储字符串长度）</li>
<li>char和varchar末尾有空格的话，char会自动去掉空格后存储，varchar虽然不会去掉空格，但在进行字符串比较时，会去掉空格进行比较</li>
</ol>
<p><strong>字符比较区分大小写的方法：</strong></p>
<ol>
<li>select时候加上binary，如：<code>select * from test where name like binary  &#39;%王%&#39;;</code></li>
<li>建表时候或者修改表列数据类型为<code>varchar(32) binary</code>这种格式</li>
</ol>
<h2 id="binary"><a href="#binary" class="headerlink" title="binary"></a>binary</h2><ol>
<li>binary保存二进制字符串，它保存的是<strong>字节</strong>，没有<strong>字符集</strong>限制，比较时候比较的是<strong>字节</strong>，区分大小写，按字节比较比字符简单快速</li>
<li>binary(8)可以保存8个字节的数据，结尾使用\0填充，而不是空格</li>
</ol>
<h2 id="Blob与Text"><a href="#Blob与Text" class="headerlink" title="Blob与Text"></a>Blob与Text</h2><ol>
<li>BLOB是二进制大对象，容纳可变数量的数据。有4种类型：TINYBLOB、BLOB、MEDIUMBLOB和LONGBLOB。可容纳值的最大长度不同。</li>
<li>TEXT类型也有四种：TINYTEXT、TEXT、MEDIUMTEXT和LONGTEXT。对应4种BLOB类型，有相同的最大长度和存储需求。</li>
<li>大体上可将BLOB列视为能够足够大的VARBINARY列，将TEXT列视为VARCHAR列。</li>
<li>BLOB和TEXT列不能有 默认值。</li>
</ol>
<p>由于BLOB和TEXT值可能会非常长，使用它们时可能遇到一些约束：</p>
<p>当排序时只使用该列的前max_sort_length个字节。max_sort_length的 默认值是1024；该值可以在启动mysqld服务器时使用–max_sort_length选项进行更改。</p>
<p>运行时增加max_sort_length的值可以在排序或组合时使更多的字节有意义。任何客户端可以更改其会话max_sort_length变量的值：<br>复制代码 代码如下:</p>
<p>mysql&gt; SET max_sort_length = 2000;</p>
<p>mysql&gt; SELECT id, comment FROM tbl_name</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-&gt; ORDER BY comment;</div></pre></td></tr></table></figure>
<p>当你想要使超过max_sort_length的字节有意义，对含长值的BLOB或TEXT列使用GROUP BY或ORDER BY的另一种方式是将列值转换为固定长度的对象。标准方法是使用SUBSTRING函数。例如，下面的语句对comment列的2000个字节进行排序：<br>复制代码 代码如下:</p>
<p>mysql&gt; SELECT id, SUBSTRING(comment,1,2000) FROM tbl_name</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-&gt; ORDER BY SUBSTRING(comment,1,2000);</div></pre></td></tr></table></figure>
<p>BLOB或TEXT对象的最大大小由其类型确定，但在客户端和服务器之间实际可以传递的最大值由可用内存数量和通信缓存区大小确定。你可以通过更改max_allowed_packet变量的值更改消息缓存区的大小，但必须同时修改服务器和客户端程序。例如，可以使用mysql和mysqldump来更改客户端的max_allowed_packet值。</p>
<p>每个BLOB或TEXT值分别由内部分配的对象表示。这与其它列类型形成对比，后者是当打开表时为每1列分配存储引擎。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;MySQL-数据类型&quot;&gt;&lt;a href=&quot;#MySQL-数据类型&quot; class=&quot;headerlink&quot; title=&quot;MySQL 数据类型&quot;&gt;&lt;/a&gt;MySQL 数据类型&lt;/h1&gt;&lt;h2 id=&quot;char与varchar&quot;&gt;&lt;a href=&quot;#char与varc
    
    </summary>
    
      <category term="MySQL" scheme="https://blog.ajavac.com/categories/MySQL/"/>
    
    
      <category term="Common" scheme="https://blog.ajavac.com/tags/Common/"/>
    
      <category term="MySQL" scheme="https://blog.ajavac.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Java Web 项目配置文件提取方案</title>
    <link href="https://blog.ajavac.com/2016/12/01/Java/java_web_config/"/>
    <id>https://blog.ajavac.com/2016/12/01/Java/java_web_config/</id>
    <published>2016-12-01T07:02:57.000Z</published>
    <updated>2016-12-01T07:05:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-Web-项目配置文件提取方案"><a href="#Java-Web-项目配置文件提取方案" class="headerlink" title="Java Web 项目配置文件提取方案"></a>Java Web 项目配置文件提取方案</h1><blockquote>
<p>如果使用war包部署项目,配置文件在war包里面会有很多不便,所以考虑将配置文件提取出来,当然,这是针对传统Java Web项目</p>
</blockquote>
<h2 id="开发时"><a href="#开发时" class="headerlink" title="开发时"></a>开发时</h2><p>在开发时候,配置文件使用项目中的配置文件</p>
<p>首先,修改web.xml,添加定制配置文件目录项目中的<code>/WEB-INF/config</code>作为基础配置文件目录</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>configDir<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/config<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></div></pre></td></tr></table></figure>
<p>在需要导入配置的地方可以用如下方式导入</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"$&#123;configDir&#125;/database.properties"</span> <span class="attr">ignore-unresolvable</span>=<span class="string">"true"</span>/&gt;</span></div></pre></td></tr></table></figure>
<p>比如,spring的配置注入</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"configProperties"</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.PropertiesFactoryBean"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"locations"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>$&#123;configDir&#125;/*.properties<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"propertyConfigurer"</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.PreferencesPlaceholderConfigurer"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"properties"</span> <span class="attr">ref</span>=<span class="string">"configProperties"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="生产环境"><a href="#生产环境" class="headerlink" title="生产环境"></a>生产环境</h2><blockquote>
<p>生产环境中,使用其他目录作为配置文件目录,已确保更新war包时候不会把原配置替换掉</p>
</blockquote>
<p>要自定义配置目录，则可以修改webapp的Context Descriptor。以tomcat为例：<br>在如下目录${CATALINA_HOME}/conf/Catalina/localhost/下建立[webapp_name].xml，这里是<br>registryService.xml，内容如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">Context</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">Parameter</span> <span class="attr">name</span>=<span class="string">"configDir"</span> <span class="attr">value</span>=<span class="string">"file:/app/config"</span> <span class="attr">override</span>=<span class="string">"false"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">Context</span>&gt;</span></div></pre></td></tr></table></figure>
<p>其中,<code>value=&quot;file:/app/config&quot;</code>表示配置文件都放在<code>/app/config</code>目录下</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java-Web-项目配置文件提取方案&quot;&gt;&lt;a href=&quot;#Java-Web-项目配置文件提取方案&quot; class=&quot;headerlink&quot; title=&quot;Java Web 项目配置文件提取方案&quot;&gt;&lt;/a&gt;Java Web 项目配置文件提取方案&lt;/h1&gt;&lt;bloc
    
    </summary>
    
      <category term="Java" scheme="https://blog.ajavac.com/categories/Java/"/>
    
    
      <category term="Java" scheme="https://blog.ajavac.com/tags/Java/"/>
    
      <category term="Tomcat" scheme="https://blog.ajavac.com/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>Nginx入门</title>
    <link href="https://blog.ajavac.com/2016/11/24/Nginx/nginx_guide/"/>
    <id>https://blog.ajavac.com/2016/11/24/Nginx/nginx_guide/</id>
    <published>2016-11-24T07:34:53.000Z</published>
    <updated>2016-11-24T07:35:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nginx入门"><a href="#Nginx入门" class="headerlink" title="Nginx入门"></a>Nginx入门</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Nginx是一个WebServer,它能够反向代理HTTP,HTTPS,SMTP,POP3,IMAP等的协议链接,可以实现负载均衡和HTTP缓存,功能十分强大.Nginx采用异步非阻塞的设计,性能强大,支持高并发,而且占用资源极低.</p>
<h2 id="安装与使用"><a href="#安装与使用" class="headerlink" title="安装与使用"></a>安装与使用</h2><h3 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h3><p>cmd切换到nginx目录下</p>
<p>启动:<code>start ngix</code></p>
<p>停止:<code>nginx -s stop</code></p>
<p>重新加载:<code>nginx -s  reload</code></p>
<h3 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h3><p><code>service nginx (start|stop|restart)</code></p>
<h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。</p>
<p>作用:</p>
<ol>
<li>保护网站安全:所有连接都经过该服务器</li>
<li>通过配置缓存功能加速Web请求</li>
<li>实现负载均衡</li>
<li>高可用/热更新/防盗链等等</li>
</ol>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>修改conf/nginx.conf</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">worker_processes  2;#worker进程数,一般配置为cpu核数</div><div class="line"></div><div class="line">events &#123;</div><div class="line">    worker_connections  1024;#每个worker处理的连接数</div><div class="line">&#125;</div><div class="line"></div><div class="line">http &#123;</div><div class="line"></div><div class="line"><span class="meta">	#</span>服务器集群,命名为tomcats</div><div class="line">	upstream tomcats &#123;</div><div class="line">        server 192.168.68.121:8080;#服务器1,此处可用域名,不带端口则默认80端口</div><div class="line">        server 192.168.68.121:8081;#服务器2</div><div class="line">        server 192.168.12.121:8081;#服务器3</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    server &#123;</div><div class="line">        listen       80;#nginx监听的端口号</div><div class="line">        server_name  localhost;#服务器域名</div><div class="line"></div><div class="line"><span class="meta">		#</span>所有的请求转向自定义的tomcats负载均衡服务器列表</div><div class="line">        location / &#123;</div><div class="line">			proxy_pass http://tomcats;#代理的服务器集群</div><div class="line"><span class="meta">			#</span>proxy_redirect  off;</div><div class="line"><span class="meta">			#</span>设置请求头</div><div class="line">			proxy_set_header Host $host:$server_port;</div><div class="line">			proxy_set_header X-Real-IP $remote_addr;</div><div class="line">			proxy_set_header REMOTE-HOST $remote_addr;</div><div class="line">			proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>负载均衡规则有:</p>
<ol>
<li>round-robin:循环,默认规则,请求会循环指向服务列表的各个服务器</li>
<li>least-connected :最少连接,请求会指向当前连接数最少的服务器</li>
<li>ip-hash:哈希,会根据请求的客户端ip的哈希值指向服务器列表中的某一个服务器,这样采用session的服务器才能更好地发挥作用,但是并不是很好的实现负载均衡功能</li>
<li>weight:按照权重来指向各个服务器</li>
</ol>
<p>配置:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> least-connected配置方法</div><div class="line">upstream myapp1 &#123;</div><div class="line">        least_conn;</div><div class="line">        server srv1.example.com;</div><div class="line">        server srv2.example.com;</div><div class="line">        server srv3.example.com;</div><div class="line">&#125;</div><div class="line"><span class="meta">#</span> ip-hash配置方法</div><div class="line">upstream myapp1 &#123;</div><div class="line">    ip_hash;</div><div class="line">    server srv1.example.com;</div><div class="line">    server srv2.example.com;</div><div class="line">    server srv3.example.com;</div><div class="line">&#125;</div><div class="line"><span class="meta">#</span> 权重配置</div><div class="line">upstream myapp1 &#123;</div><div class="line"><span class="meta">		#</span> 每5个连接会有3个到srv1,1个到srv2,1个到srv3</div><div class="line">        server srv1.example.com weight=3;</div><div class="line">        server srv2.example.com;</div><div class="line">        server srv3.example.com;</div><div class="line">&#125;</div><div class="line"><span class="meta">#</span> 健康检查</div><div class="line">upstream myapp1 &#123;</div><div class="line">    server srv1.example.com;#默认情况下max_fails=1 服务器一次访问失败就会被标记为宕机,不可用,默认10秒访问超时</div><div class="line">    server srv2.example.com max_fails=3 fail_timeout=20;#3次失败,20秒访问超时</div><div class="line">    server srv3.example.com max_fails=0;#不论几次失败都可用</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="location规则"><a href="#location规则" class="headerlink" title="location规则"></a>location规则</h3><p>语法规则： <code>location [=|~|~*|^~] /uri/ { … }</code></p>
<ol>
<li><p><code>=</code> 开头 表示精确匹配</p>
</li>
<li><p><code>^~</code> 开头 表示uri以某个常规字符串开头(支持正则)。nginx不对url做编码</p>
</li>
<li><p><code>~</code> 开头 表示<strong>区分</strong>大小写的正则匹配</p>
</li>
<li><p><code>~*</code> 开头 表示<strong>不区分</strong>大小写的正则匹配</p>
</li>
<li><p><code>!~</code>和<code>!~*</code>分别为区分大小写不匹配及不区分大小写<strong>不匹配</strong> 的正则</p>
</li>
<li><p><code>/</code> 通用匹配，任何请求都会匹配到</p>
</li>
</ol>
<p>匹配顺序:首先匹配 =，其次匹配^~, 其次是按文件中顺序的正则匹配，最后是交给 / 通用匹配。当有匹配成功时候，停止匹配，按当前匹配规则处理请求。同等级匹配多个则选择较长的匹配</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Nginx入门&quot;&gt;&lt;a href=&quot;#Nginx入门&quot; class=&quot;headerlink&quot; title=&quot;Nginx入门&quot;&gt;&lt;/a&gt;Nginx入门&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简
    
    </summary>
    
      <category term="Nginx" scheme="https://blog.ajavac.com/categories/Nginx/"/>
    
    
      <category term="Common" scheme="https://blog.ajavac.com/tags/Common/"/>
    
      <category term="Nginx" scheme="https://blog.ajavac.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>证书相关知识</title>
    <link href="https://blog.ajavac.com/2016/11/24/Common/certificate/"/>
    <id>https://blog.ajavac.com/2016/11/24/Common/certificate/</id>
    <published>2016-11-24T07:32:53.000Z</published>
    <updated>2016-12-28T15:15:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="证书相关知识"><a href="#证书相关知识" class="headerlink" title="证书相关知识"></a>证书相关知识</h1><h2 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h2><h3 id="对称密钥加密"><a href="#对称密钥加密" class="headerlink" title="对称密钥加密"></a>对称密钥加密</h3><blockquote>
<p>加/解密一般使用<strong>同一个密钥</strong>或者可互相推算的密钥,通常称之为”Session Key”,计算速度较快.</p>
</blockquote>
<p>常见的对称加密算法有DES、3DES、AES、Blowfish、IDEA、RC5、RC6。</p>
<h3 id="非对称密钥加密"><a href="#非对称密钥加密" class="headerlink" title="非对称密钥加密"></a>非对称密钥加密</h3><blockquote>
<p>加/解密使用<strong>不同的密钥</strong>,通常有两个密钥,成为”公钥”和”私钥”,需要配对使用.公钥加密的数据只有私钥可以解开,私钥加密的数据只有公钥才能解开.一般公钥是公开的,可被人知道,私钥需要妥善保存.计算速度慢.</p>
</blockquote>
<p>常见的公钥加密算法有：RSA、ElGamal、背包算法、Rabin（RSA的特例）等。</p>
<p>使用最广泛的是RSA算法。</p>
<h2 id="摘要算法"><a href="#摘要算法" class="headerlink" title="摘要算法"></a>摘要算法</h2><blockquote>
<p>散列函数（或散列算法，又称哈希函数，英语：Hash Function）是一种从任何一种数据中创建小的数字“指纹”的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。好的散列函数在输入域中很少出现散列冲突。</p>
</blockquote>
<p>常见摘要算法: MD5、SHA1、SHA256、SHA512</p>
<p>特点:</p>
<ol>
<li>摘要信息压缩了输入信息</li>
<li>摘要结果不可逆</li>
<li>源信息被修改则摘要结果改变(雪崩效应)</li>
<li>一般来说,摘要结果不同,说明输入信息不同</li>
</ol>
<p>常用来保证数据的完整性</p>
<h2 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h2><blockquote>
<p>是一种用于电脑的身份识别机制,一般由<strong>权威的值得信赖的第三方机构</strong>(一般是由政府审核并授权的机构)来统一对外发放,也成为CA证书</p>
</blockquote>
<p>比较常见的还有国际权威的数字证书认证机构，比如 GlobalSign、VeriSign、GeoTrust、Comodo， 一般收取高额费用。<br>也有免费的数字证书认证机构，比如CAcert和 StartSSL。</p>
<p>所以自签证书是个掩耳盗铃的事情</p>
<h3 id="证书颁发过程"><a href="#证书颁发过程" class="headerlink" title="证书颁发过程"></a>证书颁发过程</h3><blockquote>
<p>用户首先产生自己的密钥对，并将公共密钥及部分个人身份信息传送给认证中心。认证中心在核实身份后，将执行一些必要的步骤，以确信请求确实由用户发送而来，然后，认证中心将发给用户一个数字证书，该证书内包含用户的个人信息和他的公钥信息，同时还附有认证中心的签名信息(根证书私钥签名)。用户就可以使用自己的数字证书进行相关的各种活动。数字证书由独立的证书发行机构发布，数字证书各不相同，每种证书可提供不同级别的可信度。</p>
</blockquote>
<h3 id="证书内容"><a href="#证书内容" class="headerlink" title="证书内容"></a>证书内容</h3><ol>
<li>证书颁发机构的名称</li>
<li>证书本身的数字签名</li>
<li>证书持有者公钥</li>
<li>证书签名用到的Hash算法</li>
</ol>
<h3 id="证书有效性验证"><a href="#证书有效性验证" class="headerlink" title="证书有效性验证"></a>证书有效性验证</h3><p>浏览器默认都会内置CA根证书，其中根证书包含了CA的公钥</p>
<p>证书的签发是一级一级往下签发,还有一个CRL列表(吊销列表)</p>
<ol>
<li>证书颁发的机构是伪造的：浏览器不认识，直接认为是危险证书</li>
<li>证书颁发的机构是确实存在的，于是根据CA名，找到对应内置的CA根证书、CA的公钥。用CA的公钥，对伪造的证书的摘要进行解密，发现解不了，认为是危险证书。</li>
<li>对于篡改的证书，使用CA的公钥对数字签名进行解密得到摘要A，然后再根据签名的Hash算法计算出证书的摘要B，对比A与B，若相等则正常，若不相等则是被篡改过的。</li>
<li>证书可在其过期前被吊销，通常情况是该证书的私钥已经失密。较新的浏览器如Chrome、Firefox、Opera和Internet Explorer都实现了在线证书状态协议（OCSP）以排除这种情形：浏览器将网站提供的证书的序列号通过OCSP发送给证书颁发机构，后者会告诉浏览器证书是否还是有效的。</li>
</ol>
<blockquote>
<p>1、2点是对伪造证书进行的，3是对于篡改后的证书验证，4是对于过期失效的验证。</p>
</blockquote>
<h2 id="HTTPs"><a href="#HTTPs" class="headerlink" title="HTTPs"></a>HTTPs</h2><h3 id="HTTPS和HTTP的区别"><a href="#HTTPS和HTTP的区别" class="headerlink" title="HTTPS和HTTP的区别"></a>HTTPS和HTTP的区别</h3><ol>
<li>HTTP默认使用<strong>80端口</strong>，HTTPS默认使用<strong>443端口</strong></li>
<li>HTTPS协议需要CA证书</li>
<li>HTTP是超文本传输协议，信息是明文传输；HTTPsS则是具有安全性的SSL/TLS加密传输协议</li>
<li>HTTP和HTTPS使用的是完全不同的连接方式</li>
<li>HTTP的连接很简单，是无状态的</li>
<li>HTTPS协议是由SSL/TLS+HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP协议安全</li>
<li>HTTP协议相对简单,所以传输速度较HTTPS快,但是现在差别已经不是很大.</li>
<li>HTTPS部署相对复杂</li>
</ol>
<h3 id="SSL-与-TLS"><a href="#SSL-与-TLS" class="headerlink" title="SSL 与 TLS"></a>SSL 与 TLS</h3><p><strong>SSL(Secure Socket Layer)安全套接字层</strong></p>
<p>SSL为Netscape所研发，用以保障在Internet上数据传输之安全，利用数据加密(Encryption)技术，可确保数据在网络上之传输过程中不会被截取，当前为3.0版本。</p>
<p>SSL协议可分为两层： SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。 SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。</p>
<p><strong>TLS (Transport Layer Security，传输层安全协议)</strong><br>用于两个应用程序之间提供保密性和数据完整性。<br>TLS 1.0是IETF（Internet Engineering Task Force，Internet工程任务组）制定的一种新的协议，它建立在SSL 3.0协议规范之上，是SSL 3.0的后续版本，可以理解为SSL 3.1，它是写入了 RFC 的。该协议由两层组成： TLS 记录协议（TLS Record）和 TLS 握手协议（TLS Handshake）。较低的层为 TLS 记录协议，位于某个可靠的传输协议（例如 TCP）上面。</p>
<p><strong>SSL/TLS协议作用：</strong></p>
<ol>
<li>认证用户和服务器，确保数据发送到正确的客户机和服务器；</li>
<li>加密数据以防止数据中途被窃取；</li>
<li>维护数据的完整性，确保数据在传输过程中不被改变。</li>
</ol>
<p><strong>TLS比SSL的优势</strong></p>
<ol>
<li>对于消息认证使用密钥散列法：TLS 使用“消息认证代码的密钥散列法”（HMAC），当记录在开放的网络（如因特网）上传送时，该代码确保记录不会被变更。SSLv3.0还提供键控消息认证，但HMAC比SSLv3.0使用的（消息认证代码）MAC 功能更安全。</li>
<li>增强的伪随机功能（PRF）：PRF生成密钥数据。在TLS中，HMAC定义PRF。PRF使用两种散列算法保证其安全性。如果任一算法暴露了，只要第二种算法未暴露，则数据仍然是安全的。</li>
<li>改进的已完成消息验证：TLS和SSLv3.0都对两个端点提供已完成的消息，该消息认证交换的消息没有被变更。然而，TLS将此已完成消息基于PRF和HMAC值之上，这也比SSLv3.0更安全。</li>
<li>一致证书处理：与SSLv3.0不同，TLS试图指定必须在TLS之间实现交换的证书类型。</li>
<li>特定警报消息：TLS提供更多的特定和附加警报，以指示任一会话端点检测到的问题。TLS还对何时应该发送某些警报进行记录。</li>
</ol>
<p>https实际就是在TCP层与http层之间加入了SSL/TLS来为上层的安全保驾护航，主要用到对称加密、非对称加密、证书，等技术进行客户端与服务器的数据加密传输，最终达到保证整个通信的安全性。</p>
<p><img src="/img/https/1.png" alt="普通SSL"></p>
<p><img src="/img/https/2.png" alt="较安全的SSL"></p>
<p><img src="/img/https/3.png" alt="更安全的SSL"></p>
<h3 id="session的恢复"><a href="#session的恢复" class="headerlink" title="session的恢复"></a>session的恢复</h3><h4 id="session-ID"><a href="#session-ID" class="headerlink" title="session ID"></a>session ID</h4><p>session ID的思想很简单，就是每一次对话都有一个编号（session ID）。如果对话中断，下次重连的时候，只要客户端给出这个编号，且服务器有这个编号的记录，双方就可以重新使用已有的”对话密钥”，而不必重新生成一把。</p>
<p>session ID是目前所有浏览器都支持的方法，但是它的缺点在于session ID往往只保留在一台服务器上。所以，如果客户端的请求发到另一台服务器，就无法恢复对话</p>
<h4 id="session-ticket"><a href="#session-ticket" class="headerlink" title="session ticket"></a>session ticket</h4><p>客户端发送一个服务器在上一次对话中发送过来的session ticket。这个session ticket是加密的，只有服务器才能解密，其中包括本次对话的主要信息，比如对话密钥和加密方法。当服务器收到session ticket以后，解密后就不必重新生成对话密钥了。</p>
<p>目前只有Firefox和Chrome浏览器支持。</p>
<h2 id="可信时间戳"><a href="#可信时间戳" class="headerlink" title="可信时间戳"></a>可信时间戳</h2><blockquote>
<p>可信时间戳是由权威可信时间戳服务中心签发的一个能证明数据电文(电子文件）在一个时间点是已经存在的、完整的、可验证的，具备法律效力的电子凭证，可信时间戳主要用于电子文件防篡改和事后抵赖，确定电子文件产生的准确时间。</p>
</blockquote>
<p><img src="/img/https/4.jpeg" alt="可信时间戳"></p>
<h2 id="PKI"><a href="#PKI" class="headerlink" title="PKI"></a>PKI</h2><p><img src="/img/https/5.png" alt="PKI"></p>
<blockquote>
<p>The PKI role that assures valid and correct registration is called a registration authority (RA). An RA is responsible for accepting requests for digital certificates and authenticating the entity making the request.In a Microsoft PKI, a registration authority is usually called a subordinate CA. An entity must be uniquely identifiable within each CA domain on the basis of information about that entity. A third-party validation authority (VA) can provide this entity information on behalf of the CA.</p>
</blockquote>
<p>概念:</p>
<ol>
<li>CA 数字证书认证机构(Certificate Authority)</li>
<li>RA 审核注册管理机构(Registration Authority)</li>
<li>VA  有效性认证机构(Validation Authority )</li>
</ol>
<blockquote>
<p>PKI是“Public Key Infrastructure”的缩写，意为“公钥基础设施”。简单地说，PKI技术就是利用公钥理论和技术建立的提供信息安全服务的基础设施。公钥体制是目前应用最广泛的一种加密体制，在这一体制中，加密密钥与解密密钥各不相同，发送信息的人利用接收者的公钥发送加密信息，接收者再利用自己专有的私钥进行解密。这种方式既保证了信息的机密性，又能保证信息具有不可抵赖性。目前，公钥体制广泛地用于CA认证、数字签名和密钥交换等领域。PKI可以作为支持<strong>认证、完整性、机密性和不可否认性</strong>的技术基础，从技术上解决网上身份认证、信息完整性和抗抵赖等安全问题，为网络应用提供可靠的安全保障。</p>
</blockquote>
<p>参考文献:</p>
<p><a href="https://zh.wikipedia.org/wiki/對稱密鑰加密" target="_blank" rel="external">1.對稱密鑰加密</a></p>
<p><a href="https://zh.wikipedia.org/wiki/公开密钥加密" target="_blank" rel="external">2.公开密钥加密</a></p>
<p><a href="https://zh.wikipedia.org/wiki/散列函數" target="_blank" rel="external">3.散列函數</a></p>
<p><a href="https://zh.wikipedia.org/wiki/電子證書" target="_blank" rel="external">4.電子證書</a></p>
<p><a href="https://en.wikipedia.org/wiki/Public_key_infrastructure" target="_blank" rel="external">5.Public_key_infrastructure</a></p>
<p><a href="http://www.wxtlife.com/2016/03/27/详解https是如何确保安全的？/" target="_blank" rel="external">6.详解https是如何确保安全的</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html" target="_blank" rel="external">7.图解SSL/TLS协议</a></p>
<p><a href="http://baike.baidu.com/view/4770720.htm" target="_blank" rel="external">8.可信时间戳</a></p>
<p><a href="https://www.wosign.cn/Basic/PKImore.htm" target="_blank" rel="external">9.公钥基础设施 PKI 技术与应用发展</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;证书相关知识&quot;&gt;&lt;a href=&quot;#证书相关知识&quot; class=&quot;headerlink&quot; title=&quot;证书相关知识&quot;&gt;&lt;/a&gt;证书相关知识&lt;/h1&gt;&lt;h2 id=&quot;加密算法&quot;&gt;&lt;a href=&quot;#加密算法&quot; class=&quot;headerlink&quot; title=&quot;加
    
    </summary>
    
      <category term="HTTPS" scheme="https://blog.ajavac.com/categories/HTTPS/"/>
    
    
      <category term="HTTPS" scheme="https://blog.ajavac.com/tags/HTTPS/"/>
    
      <category term="Common" scheme="https://blog.ajavac.com/tags/Common/"/>
    
  </entry>
  
  <entry>
    <title>Git基础</title>
    <link href="https://blog.ajavac.com/2016/07/22/Common/git_primer/"/>
    <id>https://blog.ajavac.com/2016/07/22/Common/git_primer/</id>
    <published>2016-07-22T01:48:22.000Z</published>
    <updated>2016-12-28T15:10:37.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>参考链接:<a href="http://www.liaoxuefeng.com/" target="_blank" rel="external">廖雪峰的官方网站</a></p>
</blockquote>
<h1 id="Quick-Learn-Git"><a href="#Quick-Learn-Git" class="headerlink" title="Quick Learn Git !"></a>Quick Learn Git !</h1><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p><code>mkdir &lt;dirname&gt;</code> 创建文件夹</p>
<p><code>cd &lt;dirname&gt;</code>目录移动</p>
<p><code>pwd</code> 显示当前目录</p>
<p><code>git init</code> 把当前目录变成Git可以管理的仓库</p>
<p><code>ls -ah</code> 显示所有文件，包括隐藏</p>
<p><code>git add &lt;file1 file2&gt;</code> 添加文件到仓库</p>
<p><code>git commit -m &quot;description...&quot;</code> 提交变更</p>
<p><code>git status</code> 查看git状态</p>
<p><code>git diff &lt;file&gt;</code> 查看file的修改情况</p>
<p><code>git log</code> 查看git历史记录</p>
<p><code>git log -pretty=oneline</code> 单行查看git历史记录</p>
<p><code>git reset --hard HEAD^</code> git回上一个版本</p>
<p><code>cat &lt;file&gt;</code> 查看file的内容</p>
<p><code>git reset --hard 363824</code> 版本回到commit id为363824的版本</p>
<p><code>git reflog</code> 查看所有的历史git版本</p>
<p><code>git diff HEAD -- &lt;file&gt;</code> 查看工作区和版本库最新版本区别</p>
<p><code>git checkout -- &lt;file&gt;</code> 丢弃工作区的修改并回到版本库最新版本(stage和库取最新)</p>
<p><code>git reset HEAD &lt;file&gt;</code> 撤销掉stage版本（unstage）</p>
<p><code>git rm &lt;file&gt;</code> 从版本库删除文件</p>
<h2 id="git工作区、暂存区概念"><a href="#git工作区、暂存区概念" class="headerlink" title="git工作区、暂存区概念"></a>git工作区、暂存区概念</h2><p><img src="/img/git/1.jpeg" alt="git工作区"></p>
<h2 id="GItHub-设置"><a href="#GItHub-设置" class="headerlink" title="GItHub 设置"></a>GItHub 设置</h2><p><code>ssh-keygen -t rsa -C &quot;wyp0596@qq.com&quot;</code></p>
<p>一路回车</p>
<p>上GitHub添加Key</p>
<p><img src="/img/git/2.png" alt=""></p>
<h2 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h2><p><code>git remote add origin git@github.com:wyp0596/learngit.git</code> 关联</p>
<p><code>git push -u origin master</code> 推送。。第一次推送用－u 以后不需要</p>
<p><code>git clone git@github.com:wyp0596/learngit.git</code> 克隆</p>
<h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p><code>git checkout -b dev</code> 创建dev分支并切换分支</p>
<p>相当于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">$ git branch dev</div><div class="line"></div><div class="line">$ git checkout dev</div></pre></td></tr></table></figure>
<p><code>git branch</code> 查看当前分支</p>
<p><code>git checkout master</code> 切换回master分支</p>
<p><code>git merge dev</code> 把dev分支合并到master分支上</p>
<p><code>git branch -d dev</code> 删除dev分支</p>
<p><code>git log --graph --pretty=oneline --abbrev-commit</code></p>
<p>查看分支的合并情况</p>
<p><code>git merge --no-ff -m &quot;merge with no-ff&quot; dev</code> 不使用ff模式合并分支dev</p>
<h2 id="保存、恢复现场"><a href="#保存、恢复现场" class="headerlink" title="保存、恢复现场"></a>保存、恢复现场</h2><p><code>git stash</code> 保存现场</p>
<p><code>git stash list</code> 现场列表</p>
<p><code>git stash pop</code> 恢复现场，并删除存档（多现场要指定现场stash@{1}）</p>
<p><code>git stash apply</code> 恢复现场</p>
<p><code>git stash drop</code> 删除存档</p>
<h2 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h2><ol>
<li>首先，可以试图用<code>git push origin branch-name</code>推送自己的修改；</li>
</ol>
<ol>
<li>如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；</li>
</ol>
<ol>
<li>如果合并有冲突，则解决冲突，并在本地提交；</li>
</ol>
<ol>
<li>没有冲突或者解决掉冲突后，再用<code>git push origin branch-name</code>推送就能成功！</li>
</ol>
<p>如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream branch-name origin/branch-name</code>。</p>
<p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p>
<ul>
<li>查看远程库信息，使用git remote -v；</li>
</ul>
<ul>
<li>在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；</li>
</ul>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p><code>git tag</code> 标签列表</p>
<p><code>git tag v1.0</code> 添加标签v1.0到当前commit</p>
<p><code>git log --pretty=oneline --abbrev-commit</code> 查看commmit</p>
<p><code>git tag v0.9 622333</code> 添加标签v1.0到指定commit</p>
<p><code>git show v0.9</code></p>
<p><code>$ git tag -a v0.1 -m &quot;version 0.1 released&quot; 3628164</code></p>
<p>带说明的标签</p>
<p><code>$ git tag -s v0.2 -m &quot;signed version 0.2 released&quot; fec145a</code> 用私钥签名一个标签</p>
<p><code>git tag -d v0.1</code> 删除本地标签</p>
<p><code>git push origin v1.0</code> 上传标签</p>
<p><code>git push origin --tags</code> 推送所有未推送标签</p>
<p><code>git push origin :refs/tags/v0.9</code> 删除远程标签</p>
<h2 id="自定义Git"><a href="#自定义Git" class="headerlink" title="自定义Git"></a>自定义Git</h2><p><code>git config --global color.ui true</code> 加上颜色</p>
<p><a href="https://github.com/github/gitignore" target="_blank" rel="external">.gitignore</a></p>
<p>偷懒流</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">$ git config --global alias.st status</div><div class="line"></div><div class="line">$ git config --global alias.co checkout</div><div class="line"></div><div class="line">$ git config --global alias.ci commit</div><div class="line"></div><div class="line">$ git config --global alias.br branch</div><div class="line"></div><div class="line">$ git config --global alias.unstage &apos;reset HEAD&apos;</div><div class="line"></div><div class="line">$ git config --global alias.last &apos;log -1&apos;</div><div class="line"></div><div class="line">$ git config --global alias.lg &quot;log --color --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit&quot;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;参考链接:&lt;a href=&quot;http://www.liaoxuefeng.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;廖雪峰的官方网站&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Quick-Learn
    
    </summary>
    
      <category term="Git" scheme="https://blog.ajavac.com/categories/Git/"/>
    
    
      <category term="Common" scheme="https://blog.ajavac.com/tags/Common/"/>
    
      <category term="Git" scheme="https://blog.ajavac.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>MySQL基本操作</title>
    <link href="https://blog.ajavac.com/2016/07/14/MySQL/mysql_basic/"/>
    <id>https://blog.ajavac.com/2016/07/14/MySQL/mysql_basic/</id>
    <published>2016-07-14T07:48:22.000Z</published>
    <updated>2017-01-06T03:28:50.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>参考自:<a href="http://wiki.jikexueyuan.com/project/mysql-21-minutes/" target="_blank" rel="external">http://wiki.jikexueyuan.com/project/mysql-21-minutes/</a></p>
</blockquote>
<h1 id="导入数据库"><a href="#导入数据库" class="headerlink" title="导入数据库"></a>导入数据库</h1><h2 id="从sql脚本导入"><a href="#从sql脚本导入" class="headerlink" title="从sql脚本导入"></a>从sql脚本导入</h2><ol>
<li>首先建空数据库<br>mysql&gt;create database abc;</li>
<li>导入数据库<br>方法一：<br>（1）选择数据库<br><code>mysql&gt;use abc;</code><br>（2）设置数据库编码<br><code>mysql&gt;set names utf8;</code><br>（3）导入数据（注意sql文件的路径）<br><code>mysql&gt;source /home/abc/abc.sql;</code><br>方法二：<br><code>mysql -u用户名 -p 数据库名 &lt; 数据库名.sql</code><br><code>mysql -uabc_f -p abc &lt; abc.sql</code></li>
</ol>
<h2 id="从excel等导入"><a href="#从excel等导入" class="headerlink" title="从excel等导入"></a>从excel等导入</h2><ol>
<li>另存为csv用<code>，</code>分割</li>
<li><code>load data local infile &#39;C:\\abc.txt&#39; into table t fields terminated by &#39;,&#39;;</code></li>
</ol>
<h1 id="导出数据库"><a href="#导出数据库" class="headerlink" title="导出数据库"></a>导出数据库</h1><p>用mysqldump命令（注意MySQL的安装路径，即此命令的路径）：<br>1、导出数据和表结构：<br>mysqldump -u用户名 -p 数据库名 &gt; 数据库名.sql<br><code>/usr/local/mysql/bin/mysqldump -uroot -p abc &gt; abc.sql</code><br>敲回车后会提示输入密码</p>
<p>2、只导出表结构<br>mysqldump -u用户名 -p -d 数据库名 &gt; 数据库名.sql<br><code>/usr/local/mysql/bin/mysqldump -uroot -p -d abc &gt; abc.sql</code></p>
<h1 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h1><p>使用 <code>create database</code> 语句可完成对数据库的创建, 创建命令的格式如下:</p>
<p><code>create database 数据库名 [其他选项];</code><br>例如我们需要创建一个名为 samp 的数据库, 在命令行下执行以下命令:</p>
<p><code>create database samp;</code><br>提示: 可以使用 <code>show databases;</code> 命令查看已经创建了哪些数据库。</p>
<p>use 语句可以不加分号, 执行 <code>use samp</code> 来选择刚刚创建的数据库, 选择成功后会提示: Database changed</p>
<h1 id="创建数据库表"><a href="#创建数据库表" class="headerlink" title="创建数据库表"></a>创建数据库表</h1><p>使用 create table 语句可完成对表的创建, create table 的常见形式:</p>
<p><code>create table 表名称(列声明);</code></p>
<p>以创建 students 表为例, 表中将存放 学号(id)、姓名(name)、性别(sex)、年龄(age)、联系电话(tel) 这些内容:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">create table students</div><div class="line">（</div><div class="line">    id int unsigned not null auto_increment primary key,</div><div class="line">    name char(8) not null,</div><div class="line">    sex char(4) not null,</div><div class="line">    age tinyint unsigned not null,</div><div class="line">    tel char(13) null default &quot;-&quot;</div><div class="line">);</div></pre></td></tr></table></figure></p>
<h1 id="操作-MySQL-数据库"><a href="#操作-MySQL-数据库" class="headerlink" title="操作 MySQL 数据库"></a>操作 MySQL 数据库</h1><h2 id="向表中插入数据"><a href="#向表中插入数据" class="headerlink" title="向表中插入数据"></a>向表中插入数据</h2><p>insert 语句可以用来将一行或多行数据插到数据库表中, 使用的一般形式如下:</p>
<p><code>insert [into] 表名 [(列名1, 列名2, 列名3, ...)] values (值1, 值2, 值3, ...);</code><br>其中 [] 内的内容是可选的, 例如, 要给 samp_db 数据库中的 students 表插入一条记录, 执行语句:</p>
<p><code>insert into students values(NULL, &quot;王刚&quot;, &quot;男&quot;, 20, &quot;13811371377&quot;);</code></p>
<p>有时我们只需要插入部分数据, 或者不按照列的顺序进行插入, 可以使用这样的形式进行插入:</p>
<p><code>insert into students (name, sex, age) values(&quot;孙丽华&quot;, &quot;女&quot;, 21);</code></p>
<h2 id="查询表中的数据"><a href="#查询表中的数据" class="headerlink" title="查询表中的数据"></a>查询表中的数据</h2><p>select 语句常用来根据一定的查询规则到数据库中获取数据, 其基本的用法为:</p>
<p><code>select 列名称 from 表名称 [查询条件];</code><br>例如要查询 students 表中所有学生的名字和年龄, 输入语句 </p>
<p><code>select name, age from students;</code></p>
<p>也可以使用通配符 查询表中所有的内容, 语句: <code>select * from students;</code></p>
<p>按特定条件查询<br>where 关键词用于指定查询条件, 用法形式为: <code>select 列名称 from 表名称 where 条件;</code></p>
<p>以查询所有性别为女的信息为例, 输入查询语句: <code>select * from students where sex=&quot;女&quot;;</code></p>
<p>where 子句不仅仅支持 “where 列名 = 值” 这种名等于值的查询形式, 对一般的比较运算的运算符都是支持的, 例如 =、&gt;、&lt;、&gt;=、&lt;、!= 以及一些扩展运算符 is [not] null、in、like 等等。 还可以对查询条件使用 or 和 and 进行组合查询, 以后还会学到更加高级的条件查询方式, 这里不再多做介绍。</p>
<p>示例:</p>
<p>查询年龄在 21 岁以上的所有人信息: <code>select * from students where age &gt; 21;</code></p>
<p>查询名字中带有 “王” 字的所有人信息: <code>select * from students where name like &quot;%王%&quot;;</code></p>
<p>查询 id 小于 5 且年龄大于 20 的所有人信息: <code>select * from students where id&lt;5 and age&gt;20;</code></p>
<h2 id="更新表中的数据"><a href="#更新表中的数据" class="headerlink" title="更新表中的数据"></a>更新表中的数据</h2><p>update 语句可用来修改表中的数据, 基本的使用形式为:</p>
<p><code>update 表名称 set 列名称=新值 where 更新条件;</code></p>
<p>使用示例:</p>
<p>将 id 为 5 的手机号改为默认的”-“:<code>update students set tel=default where id=5;</code></p>
<p>将所有人的年龄增加 1: <code>update students set age=age+1;</code></p>
<p>将手机号为 13288097888 的姓名改为 “张伟鹏”, 年龄改为 19:<br><code>update students set name=&quot;张伟鹏&quot;, age=19 where tel=&quot;13288097888&quot;;</code></p>
<h2 id="删除表中的数据"><a href="#删除表中的数据" class="headerlink" title="删除表中的数据"></a>删除表中的数据</h2><p>delete 语句用于删除表中的数据, 基本用法为:</p>
<p><code>delete from 表名称 where 删除条件;</code></p>
<p>使用示例:</p>
<p>删除 id 为 2 的行: <code>delete from students where id=2;</code></p>
<p>删除所有年龄小于 21 岁的数据: <code>delete from students where age&lt;20;</code></p>
<p>删除表中的所有数据: <code>delete from students;</code></p>
<h1 id="创建后表的修改"><a href="#创建后表的修改" class="headerlink" title="创建后表的修改"></a>创建后表的修改</h1><p>alter table 语句用于创建后对表的修改, 基础用法如下:</p>
<h2 id="添加列"><a href="#添加列" class="headerlink" title="添加列"></a>添加列</h2><p>基本形式: <code>alter table 表名 add 列名 列数据类型 [after 插入位置];</code></p>
<p>示例:</p>
<p>在表的最后追加列 address: <code>alter table students add address char(60);</code></p>
<p>在名为 age 的列后插入列 birthday: <code>alter table students add birthday date after age;</code></p>
<h2 id="修改列"><a href="#修改列" class="headerlink" title="修改列"></a>修改列</h2><p>基本形式: <code>alter table 表名 change 列名称 列新名称 新数据类型;</code></p>
<p>示例:</p>
<p>将表 tel 列改名为 telphone: <code>alter table students change tel telphone char(13) default &quot;-&quot;;</code></p>
<p>将 name 列的数据类型改为 char(16): <code>alter table students change name name char(16) not null;</code></p>
<h2 id="删除列"><a href="#删除列" class="headerlink" title="删除列"></a>删除列</h2><p>基本形式: <code>alter table 表名 drop 列名称;</code></p>
<p>示例:</p>
<p>删除 birthday 列: <code>alter table students drop birthday;</code></p>
<h2 id="重命名表"><a href="#重命名表" class="headerlink" title="重命名表"></a>重命名表</h2><p>基本形式: <code>alter table 表名 rename 新表名;</code></p>
<p>示例:</p>
<p>重命名 students 表为 workmates: <code>alter table students rename workmates;</code></p>
<h2 id="删除整张表"><a href="#删除整张表" class="headerlink" title="删除整张表"></a>删除整张表</h2><p>基本形式: <code>drop table 表名;</code></p>
<p>示例: 删除 workmates 表: <code>drop table workmates;</code></p>
<h2 id="删除整个数据库"><a href="#删除整个数据库" class="headerlink" title="删除整个数据库"></a>删除整个数据库</h2><p>基本形式: <code>drop database 数据库名;</code></p>
<p>示例: 删除 samp_db 数据库: <code>drop database samp_db;</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;参考自:&lt;a href=&quot;http://wiki.jikexueyuan.com/project/mysql-21-minutes/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://wiki.jikexueyuan.c
    
    </summary>
    
      <category term="MySQL" scheme="https://blog.ajavac.com/categories/MySQL/"/>
    
    
      <category term="Common" scheme="https://blog.ajavac.com/tags/Common/"/>
    
      <category term="MySQL" scheme="https://blog.ajavac.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL安装和配置</title>
    <link href="https://blog.ajavac.com/2016/07/14/MySQL/mysql_install/"/>
    <id>https://blog.ajavac.com/2016/07/14/MySQL/mysql_install/</id>
    <published>2016-07-14T03:12:22.000Z</published>
    <updated>2017-03-26T08:04:59.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h1><h2 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h2><blockquote>
<p><a href="https://hub.docker.com/_/mysql/" target="_blank" rel="external">mysql官方镜像</a></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>1.最基础的运行方式,容器名为some-mysql,密码为admin</div><div class="line">docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=admin -d mysql</div><div class="line"><span class="meta">#</span>2.持久化文件保存到外部磁盘/docker/host/dir</div><div class="line">docker run --name some-mysql -v /docker/host/dir:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=admin -d mysql</div><div class="line"><span class="meta">#</span>3.宿主-容器端口映射3306:3306</div><div class="line">docker run --name some-mysql -v /docker/host/dir:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=admin -d -p 3306:3306 mysql</div><div class="line"><span class="meta">#</span>4.其他容器连接mysql</div><div class="line">docker run --name some-app --link some-mysql:mysql -d application-that-uses-mysql</div><div class="line"><span class="meta">#</span>5.mysql命令行测试连接</div><div class="line">docker run -it --link some-mysql:mysql --rm mysql sh -c 'exec mysql -h"$MYSQL_PORT_3306_TCP_ADDR" -P"$MYSQL_PORT_3306_TCP_PORT" -uroot -p"$MYSQL_ENV_MYSQL_ROOT_PASSWORD"'</div></pre></td></tr></table></figure>
<h2 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h2><p>ubuntu上安装mysql非常简单只需要几条命令就可以完成。</p>
<ol>
<li><code>sudo apt-get install mysql-server</code></li>
<li><code>sudo apt-get install mysql-client</code></li>
<li><code>sudo apt-get install libmysqlclient-dev</code><br>安装过程中会提示设置密码什么的，注意设置了不要忘了，安装完成之后可以使用如下命令来检查是否安装成功：<br><code>sudo netstat -tap | grep mysql</code></li>
</ol>
<p>通过上述命令检查之后，如果看到有mysql 的socket处于 listen 状态则表示安装成功。</p>
<p>登陆mysql数据库可以通过如下命令：<br><code>mysql -u root -p</code><br>此时输入密码就可以登录到mysql</p>
<h2 id="Mac安装"><a href="#Mac安装" class="headerlink" title="Mac安装"></a>Mac安装</h2><ol>
<li>HomeBrew安装</li>
<li>官网安装</li>
</ol>
<p>略</p>
<h2 id="Win安装"><a href="#Win安装" class="headerlink" title="Win安装"></a>Win安装</h2><ol>
<li>绿色安装<ol>
<li>按需修改<code>my.ini</code>(复制my-default.ini并改名为my.ini)</li>
<li>mysql的bin目录下执行<code>mysqld --initialize-insecure</code>来初始化mysql</li>
<li><code>mysqld —install</code>安装MySQL服务</li>
<li><code>net start mysql</code>启动mysql服务</li>
<li><code>mysql -uroot</code>免密码登录mysql</li>
<li><code>mysql&gt;alter user &#39;root&#39;@&#39;localhost&#39; identified by &#39;password&#39;;</code>修改root的密码</li>
</ol>
</li>
<li>官网安装</li>
</ol>
<h1 id="配置MySQL"><a href="#配置MySQL" class="headerlink" title="配置MySQL"></a>配置MySQL</h1><h2 id="添加远程用户"><a href="#添加远程用户" class="headerlink" title="添加远程用户"></a>添加远程用户</h2><ol>
<li><p><code>mysql&gt;GRANT ALL PRIVILEGES ON *.* TO username@&quot;%&quot; IDENTIFIED BY &#39;password&#39; WITH GRANT OPTION;</code><em>添加一个用户username/密码为password, 并授权可以从其他任何主机发起访问。</em></p>
</li>
<li><p><code>mysql&gt;flush privileges;</code>   <em>刷新刚才的内容</em></p>
<p>​</p>
</li>
</ol>
<h2 id="数据库编码格式修改"><a href="#数据库编码格式修改" class="headerlink" title="数据库编码格式修改"></a>数据库编码格式修改</h2><p>在Mac或Linux下，需要编辑MySQL的配置文件，把数据库默认的编码全部改为UTF-8。<br>Linux下MySQL的配置文件默认存放在<code>/etc/my.cnf</code>或者<code>/etc/mysql/my.cnf</code><br>Mac下MySQL的配置文件默认存放在<code>/usr/local/mysql/support-files/</code><br><code>sudo cp my-default.cnf /etc/my.cnf</code><br><code>sudo vim my.cnf</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">[mysql]</div><div class="line">default-character-set=utf8</div><div class="line">[mysqld]</div><div class="line">port = 3306</div><div class="line">max_connections=200</div><div class="line">character-set-server=utf8</div><div class="line">default-storage-engine=INNODB</div><div class="line">sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES</div><div class="line">key_buffer_size = 256M</div><div class="line">max_allowed_packet = 1M</div><div class="line">table_open_cache = 256</div><div class="line">sort_buffer_size = 1M</div><div class="line">read_buffer_size = 1M</div><div class="line">read_rnd_buffer_size = 4M</div><div class="line">myisam_sort_buffer_size = 64M</div><div class="line">thread_cache_size = 8M</div><div class="line">query_cache_size = 16M</div></pre></td></tr></table></figure>
<p>重启MySQL后，可以通过MySQL的客户端命令行检查编码：<br><code>show variables like &#39;%char%&#39;;</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">mysql&gt; show variables like &apos;%char%&apos;; </div><div class="line">+--------------------------+--------------------------------------------------------+</div><div class="line">| character_set_client     | utf8                                                   |</div><div class="line">| character_set_connection | utf8                                                   |</div><div class="line">| character_set_database   | utf8                                                   |</div><div class="line">| character_set_filesystem | binary                                                 |</div><div class="line">| character_set_results    | utf8                                                   |</div><div class="line">| character_set_server     | utf8                                                   |</div><div class="line">| character_set_system     | utf8                                                   |</div><div class="line">| character_sets_dir       | /usr/local/mysql-5.1.65-osx10.6-x86_64/share/charsets/ |</div><div class="line">+--------------------------+--------------------------------------------------------+</div><div class="line">8 rows in set (0.00 sec)</div></pre></td></tr></table></figure>
<p>看到utf8字样就表示编码设置正确。</p>
<h1 id="精简MySQL"><a href="#精简MySQL" class="headerlink" title="精简MySQL"></a>精简MySQL</h1><p>精简方法如下：</p>
<ol>
<li>删除docs，include，lib，mysql-test，scripts，sql-bench目录，只保留bin，data和share目录。</li>
<li>删除bin目录里后缀名为.pdb的文件(调试文件)。</li>
</ol>
<p>如果还想精简，那再继续下一步。</p>
<ol>
<li>删除bin目录下除mysqladmin.exe，mysqld.exe，mysql.exe以外的所有文件。</li>
<li>还可以删除data目录下的ib_logfile0，ib_logfile1，ibdata1以及后缀名为err和pid的Log文件。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;安装MySQL&quot;&gt;&lt;a href=&quot;#安装MySQL&quot; class=&quot;headerlink&quot; title=&quot;安装MySQL&quot;&gt;&lt;/a&gt;安装MySQL&lt;/h1&gt;&lt;h2 id=&quot;Docker安装&quot;&gt;&lt;a href=&quot;#Docker安装&quot; class=&quot;headerli
    
    </summary>
    
      <category term="MySQL" scheme="https://blog.ajavac.com/categories/MySQL/"/>
    
    
      <category term="Common" scheme="https://blog.ajavac.com/tags/Common/"/>
    
      <category term="MySQL" scheme="https://blog.ajavac.com/tags/MySQL/"/>
    
  </entry>
  
</feed>
